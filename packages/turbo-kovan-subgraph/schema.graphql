type AMMFactory @entity {
  id: ID!

  blockHash: String!

  blockNumber: Int!

  logIndex: Int!

  "A composite key of blockNumber+logIndex used for easily paging through logs"
  logPosition: String!

  name: String!

  transactionHash: String!

  origin: String!

  pool: String!

  marketFactory: String!

  marketId: Int!

  creator: String!

  lpTokenRecipient: String!
}

type Market @entity {
  id: ID!

  liquidity: [Liquidity!] @derivedFrom(field: "marketId")

  addLiquidity: [AddLiquidity!] @derivedFrom(field: "marketId")

  removeLiquidity: [RemoveLiquidity!] @derivedFrom(field: "marketId")

  trades: [Trade!] @derivedFrom(field: "marketId")

  claimedProceeds: [ClaimedProceeds!] @derivedFrom(field: "marketId")
}

type Liquidity @entity {
  id: ID!

  marketId: Market!

  marketFactory: String!

  user: String!

  recipient: String!

  "From the perspective of the user. E.g. collateral is negative when adding liquidity."
  collateral: String!

  lpTokens: String!

  sharesReturned: [BigInt!]

  totalSupply: BigInt
}

type Sender @entity {
  id: ID!
  addLiquidity: [AddLiquidity!] @derivedFrom(field: "sender")
  removeLiquidity: [RemoveLiquidity!] @derivedFrom(field: "sender")
  buy: [Buy!] @derivedFrom(field: "sender")
  sell: [Sell!] @derivedFrom(field: "sender")
  claimedProceeds: [ClaimedProceeds!] @derivedFrom(field: "sender")
  claimedFees: [ClaimedFees!] @derivedFrom(field: "sender")
}

type AddLiquidity @entity {
  id: ID!
  sender: Sender!
  marketId: Market!
  transactionHash: String!
  timestamp: BigInt!
  collateral: String!
  lpTokens: String!
  sharesReturned: [BigInt!]
  totalSupply: BigInt
}

type Outcomes @entity {
  id: ID!
  amount: String
  addLiquidity: AddLiquidity
  removeLiquidity: RemoveLiquidity
  buy: Buy
  sell: Sell
}

type RemoveLiquidity @entity {
  id: ID!
  sender: Sender!
  marketId: Market!
  transactionHash: String!
  timestamp: BigInt!
  outcomes: [Outcomes!]! @derivedFrom(field: "removeLiquidity")
  collateral: String!
  lpTokens: String!
  sharesReturned: [BigInt!]
  totalSupply: BigInt
}

type Buy @entity {
  id: ID!
  sender: Sender!
  transactionHash: String!
  timestamp: BigInt!
  outcomes: [Outcomes!]! @derivedFrom(field: "buy")
  collateral: String!
  shares: String!
  price: BigDecimal!
}

type Sell @entity {
  id: ID!
  sender: Sender!
  transactionHash: String!
  timestamp: BigInt!
  outcomes: [Outcomes!]! @derivedFrom(field: "sell")
  collateral: String!
  shares: String!
  price: BigDecimal!
}

type Trade @entity {
  id: ID!

  marketId: Market!

  marketFactory: String!

  user: String!

  outcome: String!

  "From the perspective of the user. E.g. collateral is negative when buying."
  collateral: String!

  shares: String!

  price: BigDecimal!

  transactionHash: String!

  timestamp: BigInt!
}

type ClaimedProceeds @entity {
  id: ID!
  sender: Sender!
  fees: String!
  outcome: String!
  marketId: Market
  payout: String!
  shares: String!
  transactionHash: String!
  timestamp: BigInt!
}

type ClaimedFees @entity {
  id: ID!
  sender: Sender!
  collateral: String!
  receiver: String!
  transactionHash: String!
  timestamp: BigInt!
}
