type AMMFactory @entity {
  id: ID!

  blockHash: String!

  blockNumber: Int!

  logIndex: Int!

  "A composite key of blockNumber+logIndex used for easily paging through logs"
  logPosition: String!

  name: String!

  transactionHash: String!

  origin: String!

  pool: String!

  marketFactory: String!

  marketId: Int!

  creator: String!

  lpTokenRecipient: String!
}

type Market @entity {
  id: ID!

  liquidity: [Liquidity!]! @derivedFrom(field: "marketId")

  addLiquidity: [AddLiquidity!]! @derivedFrom(field: "marketId")

  removeLiquidity: [RemoveLiquidity!]! @derivedFrom(field: "marketId")

  trades: [Trades!]! @derivedFrom(field: "marketId")
}

type Liquidity @entity {
  id: ID!

  marketId: Market!

  marketFactory: String!

  user: String!

  recipient: String!

  "From the perspective of the user. E.g. collateral is negative when adding liquidity."
  collateral: String!

  lpTokens: String!
}

type Sender @entity {
  id: ID!
  addLiquidity: AddLiquidity
  removeLiquidity: RemoveLiquidity
  buy: Buy
  sell: Sell
  claimedProceeds: ClaimedProceeds
  claimedFees: ClaimedFees
}

type AddLiquidity @entity {
  id: ID!
  sender: [Sender!]! @derivedFrom(field: "addLiquidity")
  marketId: Market!
  transactionHash: String!
  timestamp: BigInt!
  collateral: String!
  lpTokens: String!
}

type Outcomes @entity {
  id: ID!
  amount: String
  addLiquidity: AddLiquidity
  removeLiquidity: RemoveLiquidity
  buy: Buy
  sell: Sell
}

type RemoveLiquidity @entity {
  id: ID!
  sender: [Sender!]! @derivedFrom(field: "removeLiquidity")
  marketId: Market!
  transactionHash: String!
  timestamp: BigInt!
  outcomes: [Outcomes!]! @derivedFrom(field: "removeLiquidity")
}

type Buy @entity {
  id: ID!
  sender: [Sender!]! @derivedFrom(field: "buy")
  transactionHash: String!
  timestamp: BigInt!
  outcomes: [Outcomes!]! @derivedFrom(field: "buy")
  price: String
  cash: String
}

type Sell @entity {
  id: ID!
  sender: [Sender!]! @derivedFrom(field: "sell")
  transactionHash: String!
  timestamp: BigInt!
  outcomes: [Outcomes!]! @derivedFrom(field: "sell")
  amount: String
  price: String
  cash: String
}

type Trades @entity {
  id: ID!

  marketId: Market!

  marketFactory: String!

  user: String!

  outcome: String!

  "From the perspective of the user. E.g. collateral is negative when buying."
  collateral: String!

  shares: String!
}

type User @entity {
  id: ID!

  winningsClaimed: [WinningsClaimed!]! @derivedFrom(field: "user")
}

type WinningsClaimed @entity {
  id: ID!

  user: User!

  marketId: String!

  winningShares: String!
}

type ClaimedProceeds @entity {
  id: ID!
  sender: [Sender!]! @derivedFrom(field: "claimedProceeds")
  fees: String!
  outcome: String!
  marketId: String!
  cash: String!
  transactionHash: String!
  timestamp: BigInt!
}

type ClaimedFees @entity {
  id: ID!
  sender: [Sender!]! @derivedFrom(field: "claimedFees")
  cash: String!
  marketId: String!
  transactionHash: String!
  timestamp: BigInt!
}