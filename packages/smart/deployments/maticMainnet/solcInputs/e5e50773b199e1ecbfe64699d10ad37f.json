{
  "language": "Solidity",
  "sources": {
    "contracts/balancer/BColor.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\ninterface BColor {\n    function getColor() external view returns (bytes32);\n}\n\ncontract BBronze is BColor {\n    function getColor() external pure override returns (bytes32) {\n        return bytes32(\"BRONZE\");\n    }\n}\n"
    },
    "contracts/balancer/BConst.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"./BColor.sol\";\n\ncontract BConst is BBronze {\n    uint256 public constant BONE = 10**18;\n\n    uint256 public constant MIN_BOUND_TOKENS = 2;\n    uint256 public constant MAX_BOUND_TOKENS = 8;\n\n    uint256 public constant MIN_FEE = BONE / 10**6;\n    uint256 public constant MAX_FEE = BONE / 10;\n    uint256 public constant EXIT_FEE = 0;\n\n    uint256 public constant MIN_WEIGHT = BONE;\n    uint256 public constant MAX_WEIGHT = BONE * 50;\n    uint256 public constant MAX_TOTAL_WEIGHT = BONE * 50;\n    uint256 public constant MIN_BALANCE = BONE / 10**12;\n\n    uint256 public constant INIT_POOL_SUPPLY = BONE * 100;\n\n    uint256 public constant MIN_BPOW_BASE = 1 wei;\n    uint256 public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\n    uint256 public constant BPOW_PRECISION = BONE / 10**10;\n\n    uint256 public constant MAX_IN_RATIO = BONE / 2;\n    uint256 public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\n}\n"
    },
    "contracts/balancer/BNum.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"./BConst.sol\";\n\ncontract BNum is BConst {\n    function btoi(uint256 a) internal pure returns (uint256) {\n        return a / BONE;\n    }\n\n    function bfloor(uint256 a) internal pure returns (uint256) {\n        return btoi(a) * BONE;\n    }\n\n    function badd(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\n        return c;\n    }\n\n    function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (uint256 c, bool flag) = bsubSign(a, b);\n        require(!flag, \"ERR_SUB_UNDERFLOW\");\n        return c;\n    }\n\n    function bsubSign(uint256 a, uint256 b) internal pure returns (uint256, bool) {\n        if (a >= b) {\n            return (a - b, false);\n        } else {\n            return (b - a, true);\n        }\n    }\n\n    function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c0 = a * b;\n        require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\n        uint256 c1 = c0 + (BONE / 2);\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\n        uint256 c2 = c1 / BONE;\n        return c2;\n    }\n\n    function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"ERR_DIV_ZERO\");\n        uint256 c0 = a * BONE;\n        require(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\n        uint256 c1 = c0 + (b / 2);\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\n        uint256 c2 = c1 / b;\n        return c2;\n    }\n\n    // DSMath.wpow\n    function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\n        uint256 z = n % 2 != 0 ? a : BONE;\n\n        for (n /= 2; n != 0; n /= 2) {\n            a = bmul(a, a);\n\n            if (n % 2 != 0) {\n                z = bmul(z, a);\n            }\n        }\n        return z;\n    }\n\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\n    // of approximation of b^0.w\n    function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\n        require(base >= MIN_BPOW_BASE, \"ERR_BPOW_BASE_TOO_LOW\");\n        require(base <= MAX_BPOW_BASE, \"ERR_BPOW_BASE_TOO_HIGH\");\n\n        uint256 whole = bfloor(exp);\n        uint256 remain = bsub(exp, whole);\n\n        uint256 wholePow = bpowi(base, btoi(whole));\n\n        if (remain == 0) {\n            return wholePow;\n        }\n\n        uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\n        return bmul(wholePow, partialResult);\n    }\n\n    function bpowApprox(\n        uint256 base,\n        uint256 exp,\n        uint256 precision\n    ) internal pure returns (uint256) {\n        // term 0:\n        uint256 a = exp;\n        (uint256 x, bool xneg) = bsubSign(base, BONE);\n        uint256 term = BONE;\n        uint256 sum = term;\n        bool negative = false;\n\n        // term(k) = numer / denom\n        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\n        // continue until term is less than precision\n        for (uint256 i = 1; term >= precision; i++) {\n            uint256 bigK = i * BONE;\n            (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\n            term = bmul(term, bmul(c, x));\n            term = bdiv(term, bigK);\n            if (term == 0) break;\n\n            if (xneg) negative = !negative;\n            if (cneg) negative = !negative;\n            if (negative) {\n                sum = bsub(sum, term);\n            } else {\n                sum = badd(sum, term);\n            }\n        }\n\n        return sum;\n    }\n}\n"
    },
    "contracts/turbo/AMMFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"../balancer/BFactory.sol\";\nimport \"../libraries/SafeMathUint256.sol\";\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"../balancer/BNum.sol\";\n\ncontract AMMFactory is BNum {\n    using SafeMathUint256 for uint256;\n\n    uint256 private constant MAX_UINT = 2**256 - 1;\n\n    BFactory public bFactory;\n    // MarketFactory => Market => BPool\n    mapping(address => mapping(uint256 => BPool)) public pools;\n    uint256 fee;\n\n    event PoolCreated(\n        address pool,\n        address indexed marketFactory,\n        uint256 indexed marketId,\n        address indexed creator,\n        address lpTokenRecipient\n    );\n    event LiquidityChanged(\n        address indexed marketFactory,\n        uint256 indexed marketId,\n        address indexed user,\n        address recipient,\n        // from the perspective of the user. e.g. collateral is negative when adding liquidity\n        int256 collateral,\n        int256 lpTokens,\n        uint256[] sharesReturned\n    );\n    event SharesSwapped(\n        address indexed marketFactory,\n        uint256 indexed marketId,\n        address indexed user,\n        uint256 outcome,\n        // from the perspective of the user. e.g. collateral is negative when buying\n        int256 collateral,\n        int256 shares,\n        uint256 price\n    );\n\n    constructor(BFactory _bFactory, uint256 _fee) {\n        bFactory = _bFactory;\n        fee = _fee;\n    }\n\n    function createPool(\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        uint256 _initialLiquidity,\n        address _lpTokenRecipient\n    ) public returns (uint256) {\n        require(pools[address(_marketFactory)][_marketId] == BPool(0), \"Pool already created\");\n\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n\n        //  Turn collateral into shares\n        IERC20Full _collateral = _marketFactory.collateral();\n        require(\n            _collateral.allowance(msg.sender, address(this)) >= _initialLiquidity,\n            \"insufficient collateral allowance for initial liquidity\"\n        );\n\n        uint256 _sets = _marketFactory.calcShares(_initialLiquidity);\n\n        _collateral.transferFrom(msg.sender, address(this), _initialLiquidity);\n        _collateral.approve(address(_marketFactory), MAX_UINT);\n\n        _marketFactory.mintShares(_marketId, _sets, address(this));\n\n        // Create pool\n        BPool _pool = bFactory.newBPool();\n\n        // Add each outcome to the pool. Collateral is NOT added.\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            OwnedERC20 _token = _market.shareTokens[i];\n            _token.approve(address(_pool), MAX_UINT);\n            _pool.bind(address(_token), _sets, _market.initialOdds[i]);\n        }\n\n        // Set the swap fee.\n        _pool.setSwapFee(fee);\n\n        // Finalize pool setup\n        _pool.finalize();\n\n        pools[address(_marketFactory)][_marketId] = _pool;\n\n        // Pass along LP tokens for initial liquidity\n        uint256 _lpTokenBalance = _pool.balanceOf(address(this)) - (BONE / 1000);\n\n        // Burn (BONE / 1000) lp tokens to prevent the bpool from locking up. When all liquidity is removed.\n        _pool.transfer(address(0x0), (BONE / 1000));\n        _pool.transfer(_lpTokenRecipient, _lpTokenBalance);\n\n        uint256[] memory _balances = new uint256[](_market.shareTokens.length);\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            _balances[i] = 0;\n        }\n\n        emit PoolCreated(address(_pool), address(_marketFactory), _marketId, msg.sender, _lpTokenRecipient);\n        emit LiquidityChanged(\n            address(_marketFactory),\n            _marketId,\n            msg.sender,\n            _lpTokenRecipient,\n            -int256(_initialLiquidity),\n            int256(_lpTokenBalance),\n            _balances\n        );\n\n        return _lpTokenBalance;\n    }\n\n    function addLiquidity(\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        uint256 _collateralIn,\n        uint256 _minLPTokensOut,\n        address _lpTokenRecipient\n    ) public returns (uint256 _poolAmountOut, uint256[] memory _balances) {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        require(_pool != BPool(0), \"Pool needs to be created\");\n\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n\n        //  Turn collateral into shares\n        IERC20Full _collateral = _marketFactory.collateral();\n        _collateral.transferFrom(msg.sender, address(this), _collateralIn);\n        _collateral.approve(address(_marketFactory), MAX_UINT);\n        uint256 _sets = _marketFactory.calcShares(_collateralIn);\n        _marketFactory.mintShares(_marketId, _sets, address(this));\n\n        // Find poolAmountOut\n        _poolAmountOut = MAX_UINT;\n\n        {\n            uint256 _totalSupply = _pool.totalSupply();\n            uint256[] memory _maxAmountsIn = new uint256[](_market.shareTokens.length);\n            for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n                _maxAmountsIn[i] = _sets;\n\n                OwnedERC20 _token = _market.shareTokens[i];\n                uint256 _bPoolTokenBalance = _pool.getBalance(address(_token));\n\n                // This is the result the following when solving for poolAmountOut:\n                // uint256 ratio = bdiv(poolAmountOut, poolTotal);\n                // uint256 tokenAmountIn = bmul(ratio, bal);\n                uint256 _tokenPoolAmountOut =\n                    (((((_sets * BONE) - (BONE / 2)) * _totalSupply) / _bPoolTokenBalance) - (_totalSupply / 2)) / BONE;\n\n                if (_tokenPoolAmountOut < _poolAmountOut) {\n                    _poolAmountOut = _tokenPoolAmountOut;\n                }\n            }\n            _pool.joinPool(_poolAmountOut, _maxAmountsIn);\n        }\n\n        require(_poolAmountOut >= _minLPTokensOut, \"Would not have received enough LP tokens\");\n\n        _pool.transfer(_lpTokenRecipient, _poolAmountOut);\n\n        // Transfer the remaining shares back to _lpTokenRecipient.\n        _balances = new uint256[](_market.shareTokens.length);\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            OwnedERC20 _token = _market.shareTokens[i];\n            _balances[i] = _token.balanceOf(address(this));\n            if (_balances[i] > 0) {\n                _token.transfer(_lpTokenRecipient, _balances[i]);\n            }\n        }\n\n        emit LiquidityChanged(\n            address(_marketFactory),\n            _marketId,\n            msg.sender,\n            _lpTokenRecipient,\n            -int256(_collateralIn),\n            int256(_poolAmountOut),\n            _balances\n        );\n    }\n\n    function removeLiquidity(\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        uint256 _lpTokensIn,\n        uint256 _minCollateralOut,\n        address _collateralRecipient\n    ) public returns (uint256 _collateralOut, uint256[] memory _balances) {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        require(_pool != BPool(0), \"Pool needs to be created\");\n\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n\n        _pool.transferFrom(msg.sender, address(this), _lpTokensIn);\n\n        uint256[] memory exitPoolEstimate;\n        {\n            uint256[] memory minAmountsOut = new uint256[](_market.shareTokens.length);\n            exitPoolEstimate = _pool.calcExitPool(_lpTokensIn, minAmountsOut);\n            _pool.exitPool(_lpTokensIn, minAmountsOut);\n        }\n\n        // Find the number of sets to sell.\n        uint256 _setsToSell = MAX_UINT;\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            uint256 _acquiredTokenBalance = exitPoolEstimate[i];\n            if (_acquiredTokenBalance < _setsToSell) _setsToSell = _acquiredTokenBalance;\n        }\n\n        // Must be a multiple of share factor.\n        _setsToSell = (_setsToSell / _marketFactory.shareFactor()) * _marketFactory.shareFactor();\n\n        bool _resolved = _marketFactory.isMarketResolved(_marketId);\n        if (_resolved) {\n            _collateralOut = _marketFactory.claimWinnings(_marketId, _collateralRecipient);\n        } else {\n            _collateralOut = _marketFactory.burnShares(_marketId, _setsToSell, _collateralRecipient);\n        }\n        require(_collateralOut > _minCollateralOut, \"Amount of collateral returned too low.\");\n\n        // Transfer the remaining shares back to _collateralRecipient.\n        _balances = new uint256[](_market.shareTokens.length);\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            OwnedERC20 _token = _market.shareTokens[i];\n            if (_resolved && _token == _market.winner) continue; // all winning shares claimed when market is resolved\n            _balances[i] = exitPoolEstimate[i] - _setsToSell;\n            if (_balances[i] > 0) {\n                _token.transfer(_collateralRecipient, _balances[i]);\n            }\n        }\n\n        emit LiquidityChanged(\n            address(_marketFactory),\n            _marketId,\n            msg.sender,\n            _collateralRecipient,\n            int256(_collateralOut),\n            -int256(_lpTokensIn),\n            _balances\n        );\n    }\n\n    function buy(\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        uint256 _outcome,\n        uint256 _collateralIn,\n        uint256 _minTokensOut\n    ) external returns (uint256) {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        require(_pool != BPool(0), \"Pool needs to be created\");\n\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n\n        IERC20Full _collateral = _marketFactory.collateral();\n        _collateral.transferFrom(msg.sender, address(this), _collateralIn);\n        uint256 _sets = _marketFactory.calcShares(_collateralIn);\n        _marketFactory.mintShares(_marketId, _sets, address(this));\n\n        uint256 _totalDesiredOutcome = _sets;\n        {\n            OwnedERC20 _desiredToken = _market.shareTokens[_outcome];\n\n            for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n                if (i == _outcome) continue;\n                OwnedERC20 _token = _market.shareTokens[i];\n                (uint256 _acquiredToken, ) =\n                    _pool.swapExactAmountIn(address(_token), _sets, address(_desiredToken), 0, MAX_UINT);\n                _totalDesiredOutcome += _acquiredToken;\n            }\n            require(_totalDesiredOutcome >= _minTokensOut, \"Slippage exceeded\");\n\n            _desiredToken.transfer(msg.sender, _totalDesiredOutcome);\n        }\n\n        emit SharesSwapped(\n            address(_marketFactory),\n            _marketId,\n            msg.sender,\n            _outcome,\n            -int256(_collateralIn),\n            int256(_totalDesiredOutcome),\n            bdiv(_sets, _totalDesiredOutcome)\n        );\n\n        return _totalDesiredOutcome;\n    }\n\n    function sellForCollateral(\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        uint256 _outcome,\n        uint256[] memory _shareTokensIn,\n        uint256 _minSetsOut\n    ) external returns (uint256) {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        require(_pool != BPool(0), \"Pool needs to be created\");\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n\n        uint256 _setsOut = MAX_UINT;\n        uint256 _totalUndesiredTokensIn = 0;\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            _totalUndesiredTokensIn += _shareTokensIn[i];\n        }\n\n        {\n            _market.shareTokens[_outcome].transferFrom(msg.sender, address(this), _totalUndesiredTokensIn);\n            _market.shareTokens[_outcome].approve(address(_pool), MAX_UINT);\n\n            for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n                if (i == _outcome) continue;\n                OwnedERC20 _token = _market.shareTokens[i];\n                (uint256 tokenAmountOut, ) =\n                    _pool.swapExactAmountIn(\n                        address(_market.shareTokens[_outcome]),\n                        _shareTokensIn[i],\n                        address(_token),\n                        0,\n                        MAX_UINT\n                    );\n\n                //Ensure tokenAmountOut is a multiple of shareFactor.\n                tokenAmountOut = (tokenAmountOut / _marketFactory.shareFactor()) * _marketFactory.shareFactor();\n                if (tokenAmountOut < _setsOut) _setsOut = tokenAmountOut;\n            }\n\n            require(_setsOut >= _minSetsOut, \"Minimum sets not available.\");\n            _marketFactory.burnShares(_marketId, _setsOut, msg.sender);\n        }\n\n        // Transfer undesired token balance back.\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            OwnedERC20 _token = _market.shareTokens[i];\n            uint256 _balance = _token.balanceOf(address(this));\n            if (_balance > 0) {\n                _token.transfer(msg.sender, _balance);\n            }\n        }\n\n        uint256 _collateralOut = _marketFactory.calcCost(_setsOut);\n        emit SharesSwapped(\n            address(_marketFactory),\n            _marketId,\n            msg.sender,\n            _outcome,\n            int256(_collateralOut),\n            -int256(_totalUndesiredTokensIn),\n            bdiv(_setsOut, _totalUndesiredTokensIn)\n        );\n\n        return _collateralOut;\n    }\n\n    // Returns an array of token values for the outcomes of the market, relative to the first outcome.\n    // So the first outcome is 10**18 and all others are higher or lower.\n    // Prices can be derived due to the fact that the total of all outcome shares equals one collateral, possibly with a scaling factor,\n    function tokenRatios(AbstractMarketFactoryV3 _marketFactory, uint256 _marketId)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        // Pool does not exist. Do not want to revert because multicall.\n        if (_pool == BPool(0)) {\n            return new uint256[](0);\n        }\n\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n        address _basisToken = address(_market.shareTokens[0]);\n        uint256[] memory _ratios = new uint256[](_market.shareTokens.length);\n        _ratios[0] = 10**18;\n        for (uint256 i = 1; i < _market.shareTokens.length; i++) {\n            uint256 _price = _pool.getSpotPrice(_basisToken, address(_market.shareTokens[i]));\n            _ratios[i] = _price;\n        }\n        return _ratios;\n    }\n\n    function getPoolBalances(AbstractMarketFactoryV3 _marketFactory, uint256 _marketId)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        // Pool does not exist. Do not want to revert because multicall.\n        if (_pool == BPool(0)) {\n            return new uint256[](0);\n        }\n\n        address[] memory _tokens = _pool.getCurrentTokens();\n        uint256[] memory _balances = new uint256[](_tokens.length);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            _balances[i] = _pool.getBalance(_tokens[i]);\n        }\n        return _balances;\n    }\n\n    function getPoolWeights(AbstractMarketFactoryV3 _marketFactory, uint256 _marketId)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        // Pool does not exist. Do not want to revert because multicall.\n        if (_pool == BPool(0)) {\n            return new uint256[](0);\n        }\n\n        address[] memory _tokens = _pool.getCurrentTokens();\n        uint256[] memory _weights = new uint256[](_tokens.length);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            _weights[i] = _pool.getDenormalizedWeight(_tokens[i]);\n        }\n        return _weights;\n    }\n\n    function getSwapFee(AbstractMarketFactoryV3 _marketFactory, uint256 _marketId) external view returns (uint256) {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        return _pool.getSwapFee();\n    }\n\n    function getPoolTokenBalance(\n        AbstractMarketFactoryV3 _marketFactory,\n        uint256 _marketId,\n        address whom\n    ) external view returns (uint256) {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        return _pool.balanceOf(whom);\n    }\n\n    function getPool(AbstractMarketFactoryV3 _marketFactory, uint256 _marketId) external view returns (BPool) {\n        return pools[address(_marketFactory)][_marketId];\n    }\n}\n"
    },
    "contracts/balancer/BFactory.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is disstributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\n// Builds new BPools, logging their addresses and providing `isBPool(address) -> (bool)`\n\nimport \"./BPool.sol\";\n\ncontract BFactory is BBronze {\n    event LOG_NEW_POOL(address indexed caller, address indexed pool);\n\n    event LOG_BLABS(address indexed caller, address indexed blabs);\n\n    mapping(address => bool) private _isBPool;\n\n    function isBPool(address b) external view returns (bool) {\n        return _isBPool[b];\n    }\n\n    function newBPool() external returns (BPool) {\n        BPool bpool = new BPool();\n        _isBPool[address(bpool)] = true;\n        emit LOG_NEW_POOL(msg.sender, address(bpool));\n        bpool.setController(msg.sender);\n        return bpool;\n    }\n\n    address private _blabs;\n\n    constructor() {\n        _blabs = msg.sender;\n    }\n\n    function getBLabs() external view returns (address) {\n        return _blabs;\n    }\n\n    function setBLabs(address b) external {\n        require(msg.sender == _blabs, \"ERR_NOT_BLABS\");\n        emit LOG_BLABS(msg.sender, b);\n        _blabs = b;\n    }\n\n    function collect(BPool pool) external {\n        require(msg.sender == _blabs, \"ERR_NOT_BLABS\");\n        uint256 collected = IERC20Balancer(pool).balanceOf(address(this));\n        bool xfer = pool.transfer(_blabs, collected);\n        require(xfer, \"ERR_ERC20_FAILED\");\n    }\n}\n"
    },
    "contracts/libraries/SafeMathUint256.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\n/**\n * @title SafeMathUint256\n * @dev Uint256 math operations with safety checks that throw on error\n */\nlibrary SafeMathUint256 {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        return a - b;\n    }\n\n    function subS(\n        uint256 a,\n        uint256 b,\n        string memory message\n    ) internal pure returns (uint256) {\n        require(b <= a, message);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a <= b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a >= b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            uint256 x = (y + 1) / 2;\n            z = y;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function getUint256Min() internal pure returns (uint256) {\n        return 0;\n    }\n\n    function getUint256Max() internal pure returns (uint256) {\n        // 2 ** 256 - 1\n        return 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    }\n\n    function isMultipleOf(uint256 a, uint256 b) internal pure returns (bool) {\n        return a % b == 0;\n    }\n\n    // Float [fixed point] Operations\n    function fxpMul(\n        uint256 a,\n        uint256 b,\n        uint256 base\n    ) internal pure returns (uint256) {\n        return div(mul(a, b), base);\n    }\n\n    function fxpDiv(\n        uint256 a,\n        uint256 b,\n        uint256 base\n    ) internal pure returns (uint256) {\n        return div(mul(a, base), b);\n    }\n}\n"
    },
    "contracts/turbo/AbstractMarketFactoryV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./TurboShareTokenFactory.sol\";\nimport \"./FeePot.sol\";\n\nabstract contract AbstractMarketFactoryV3 is TurboShareTokenFactory, Ownable {\n    using SafeMathUint256 for uint256;\n\n    event MarketCreated(uint256 id, string[] names, uint256[] initialOdds);\n    event MarketResolved(uint256 id, address winner, uint256 winnerIndex, string winnerName);\n    event MarketActivated(uint256 id);\n\n    event SharesMinted(uint256 id, uint256 amount, address receiver);\n    event SharesBurned(uint256 id, uint256 amount, address receiver);\n    event WinningsClaimed(\n        uint256 id,\n        address winningOutcome,\n        uint256 winningIndex,\n        string winningName,\n        uint256 amount,\n        uint256 settlementFee,\n        uint256 payout,\n        address indexed receiver\n    );\n\n    IERC20Full public collateral;\n    FeePot public feePot;\n\n    // fees are out of 1e18 and only apply to new markets\n    uint256 public stakerFee;\n    uint256 public settlementFee;\n    uint256 public protocolFee;\n\n    address public protocol; // collects protocol fees\n\n    uint256 public accumulatedProtocolFee = 0;\n    // settlement address => amount of collateral\n    mapping(address => uint256) public accumulatedSettlementFees;\n\n    // How many shares equals one collateral.\n    // Necessary to account for math errors from small numbers in balancer.\n    // shares = collateral / shareFactor\n    // collateral = shares * shareFactor\n    uint256 public shareFactor;\n\n    struct Market {\n        address settlementAddress;\n        OwnedERC20[] shareTokens;\n        OwnedERC20 winner;\n        uint256 winnerIndex;\n        uint256 settlementFee;\n        uint256 protocolFee;\n        uint256 stakerFee;\n        uint256 creationTimestamp;\n        uint256[] initialOdds;\n        bool active; // false if not ready to use or if resolved\n    }\n    Market[] internal markets;\n\n    uint256 private constant MAX_UINT = 2**256 - 1;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256[3] memory _fees, // staker, settlement, protocol\n        address _protocol\n    ) {\n        owner = _owner; // controls fees for new markets\n        collateral = _collateral;\n        shareFactor = _shareFactor;\n        feePot = _feePot;\n        stakerFee = _fees[0];\n        settlementFee = _fees[1];\n        protocolFee = _fees[2];\n        protocol = _protocol;\n\n        _collateral.approve(address(_feePot), MAX_UINT);\n\n        // First market is always empty so that marketid zero means \"no market\"\n        markets.push(makeEmptyMarket());\n    }\n\n    // Returns an empty struct if the market doesn't exist.\n    // Can check market existence before calling this by comparing _id against markets.length.\n    // Can check market existence of the return struct by checking that shareTokens[0] isn't the null address\n    function getMarket(uint256 _id) public view returns (Market memory) {\n        if (_id >= markets.length) {\n            return makeEmptyMarket();\n        } else {\n            return markets[_id];\n        }\n    }\n\n    function marketCount() public view returns (uint256) {\n        return markets.length;\n    }\n\n    // Returns factory-specific details about a market.\n    // function getMarketDetails(uint256 _id) public view returns (MarketDetails memory);\n\n    function mintShares(\n        uint256 _id,\n        uint256 _shareToMint,\n        address _receiver\n    ) public {\n        require(markets.length > _id);\n        require(markets[_id].active);\n\n        uint256 _cost = calcCost(_shareToMint);\n        collateral.transferFrom(msg.sender, address(this), _cost);\n\n        Market memory _market = markets[_id];\n        for (uint256 _i = 0; _i < _market.shareTokens.length; _i++) {\n            _market.shareTokens[_i].trustedMint(_receiver, _shareToMint);\n        }\n\n        emit SharesMinted(_id, _shareToMint, _receiver);\n    }\n\n    function burnShares(\n        uint256 _id,\n        uint256 _sharesToBurn,\n        address _receiver\n    ) public returns (uint256) {\n        require(markets.length > _id);\n        require(markets[_id].active);\n\n        Market memory _market = markets[_id];\n        for (uint256 _i = 0; _i < _market.shareTokens.length; _i++) {\n            // errors if sender doesn't have enough shares\n            _market.shareTokens[_i].trustedBurn(msg.sender, _sharesToBurn);\n        }\n\n        uint256 _payout = calcCost(_sharesToBurn);\n        uint256 _protocolFee = _payout.mul(_market.protocolFee).div(10**18);\n        uint256 _stakerFee = _payout.mul(_market.stakerFee).div(10**18);\n        _payout = _payout.sub(_protocolFee).sub(_stakerFee);\n\n        accumulatedProtocolFee += _protocolFee;\n        collateral.transfer(_receiver, _payout);\n        feePot.depositFees(_stakerFee);\n\n        emit SharesBurned(_id, _sharesToBurn, msg.sender);\n        return _payout;\n    }\n\n    function claimWinnings(uint256 _id, address _receiver) public returns (uint256) {\n        require(isMarketResolved(_id), \"market unresolved\");\n\n        Market memory _market = markets[_id];\n        uint256 _winningShares = _market.winner.trustedBurnAll(msg.sender);\n        _winningShares = (_winningShares / shareFactor) * shareFactor; // remove unusable dust\n\n        uint256 _payout = calcCost(_winningShares); // will fail if there are no winnings to claim\n        uint256 _settlementFee = _payout.mul(_market.settlementFee).div(10**18);\n        _payout = _payout.sub(_settlementFee);\n\n        accumulatedSettlementFees[_market.settlementAddress] += _settlementFee;\n        collateral.transfer(_receiver, _payout);\n\n        uint256 _winningIndex = _market.winnerIndex;\n        string memory _winningName = _market.winner.name();\n\n        emit WinningsClaimed(\n            _id,\n            address(_market.winner),\n            _winningIndex,\n            _winningName,\n            _winningShares,\n            _settlementFee,\n            _payout,\n            _receiver\n        );\n        return _payout;\n    }\n\n    function claimManyWinnings(uint256[] memory _ids, address _receiver) public returns (uint256) {\n        uint256 _totalWinnings = 0;\n        for (uint256 i = 0; i < _ids.length; i++) {\n            _totalWinnings = _totalWinnings.add(claimWinnings(_ids[i], _receiver));\n        }\n        return _totalWinnings;\n    }\n\n    function claimSettlementFees(address _receiver) public returns (uint256) {\n        uint256 _fees = accumulatedSettlementFees[msg.sender];\n        if (_fees > 0) {\n            accumulatedSettlementFees[msg.sender] = 0;\n            collateral.transfer(_receiver, _fees);\n        }\n        return _fees;\n    }\n\n    function claimProtocolFees() public returns (uint256) {\n        require(msg.sender == protocol || msg.sender == address(this));\n        uint256 _fees = accumulatedProtocolFee;\n        if (_fees > 0) {\n            accumulatedProtocolFee = 0;\n            collateral.transfer(protocol, _fees);\n        }\n        return _fees;\n    }\n\n    function setSettlementFee(uint256 _newFee) external onlyOwner {\n        settlementFee = _newFee;\n    }\n\n    function setStakerFee(uint256 _newFee) external onlyOwner {\n        stakerFee = _newFee;\n    }\n\n    function setProtocolFee(uint256 _newFee) external onlyOwner {\n        protocolFee = _newFee;\n    }\n\n    function setProtocol(address _newProtocol, bool _claimFirst) external onlyOwner {\n        if (_claimFirst) {\n            claimProtocolFees();\n        }\n        protocol = _newProtocol;\n    }\n\n    function startMarket(\n        address _settlementAddress,\n        string[] memory _names,\n        uint256[] memory _initialOdds,\n        bool _active\n    ) internal returns (uint256 _marketId) {\n        _marketId = markets.length;\n        markets.push(\n            Market(\n                _settlementAddress,\n                createShareTokens(_names, address(this)),\n                OwnedERC20(0),\n                0,\n                settlementFee,\n                protocolFee,\n                stakerFee,\n                block.timestamp,\n                _initialOdds,\n                _active\n            )\n        );\n        emit MarketCreated(_marketId, _names, _initialOdds);\n        if (_active) {\n            emit MarketActivated(_marketId);\n        }\n    }\n\n    function activateMarket(uint256 _marketId) internal {\n        markets[_marketId].active = true;\n        emit MarketActivated(_marketId);\n    }\n\n    function makeEmptyMarket() private pure returns (Market memory) {\n        OwnedERC20[] memory _tokens = new OwnedERC20[](0);\n        uint256[] memory _initialOdds = new uint256[](0);\n        return Market(address(0), _tokens, OwnedERC20(0), 0, 0, 0, 0, 0, _initialOdds, false);\n    }\n\n    function endMarket(uint256 _marketId, uint256 _winningOutcome) internal {\n        OwnedERC20 _winner = markets[_marketId].shareTokens[_winningOutcome];\n        markets[_marketId].winner = _winner;\n        markets[_marketId].active = false;\n        markets[_marketId].winnerIndex = _winningOutcome;\n        string memory _outcomeName = _winner.name();\n        emit MarketResolved(_marketId, address(_winner), _winningOutcome, _outcomeName);\n    }\n\n    function isMarketResolved(uint256 _id) public view returns (bool) {\n        Market memory _market = markets[_id];\n        return _market.winner != OwnedERC20(0);\n    }\n\n    // shares => collateral\n    // Shares must be both greater than (or equal to) and divisible by shareFactor.\n    function calcCost(uint256 _shares) public view returns (uint256) {\n        require(_shares >= shareFactor && _shares % shareFactor == 0);\n        return _shares / shareFactor;\n    }\n\n    // collateral => shares\n    function calcShares(uint256 _collateralIn) public view returns (uint256) {\n        return _collateralIn * shareFactor;\n    }\n\n    function onTransferOwnership(address, address) internal override {}\n}\n"
    },
    "contracts/balancer/BPool.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"./BToken.sol\";\nimport \"./BMath.sol\";\n\ncontract BPool is BBronze, BToken, BMath {\n    struct Record {\n        bool bound; // is token bound to pool\n        uint256 index; // private\n        uint256 denorm; // denormalized weight\n        uint256 balance;\n    }\n\n    event LOG_SWAP(\n        address indexed caller,\n        address indexed tokenIn,\n        address indexed tokenOut,\n        uint256 tokenAmountIn,\n        uint256 tokenAmountOut\n    );\n\n    event LOG_JOIN(address indexed caller, address indexed tokenIn, uint256 tokenAmountIn);\n\n    event LOG_EXIT(address indexed caller, address indexed tokenOut, uint256 tokenAmountOut);\n\n    event LOG_CALL(bytes4 indexed sig, address indexed caller, bytes data) anonymous;\n\n    modifier _logs_() {\n        emit LOG_CALL(msg.sig, msg.sender, msg.data);\n        _;\n    }\n\n    modifier _lock_() {\n        require(!_mutex, \"ERR_REENTRY\");\n        _mutex = true;\n        _;\n        _mutex = false;\n    }\n\n    modifier _viewlock_() {\n        require(!_mutex, \"ERR_REENTRY\");\n        _;\n    }\n\n    bool private _mutex;\n\n    address private _factory; // BFactory address to push token exitFee to\n    address private _controller; // has CONTROL role\n    bool private _publicSwap; // true if PUBLIC can call SWAP functions\n\n    // `setSwapFee` and `finalize` require CONTROL\n    // `finalize` sets `PUBLIC can SWAP`, `PUBLIC can JOIN`\n    uint256 private _swapFee;\n    bool private _finalized;\n\n    address[] private _tokens;\n    mapping(address => Record) private _records;\n    uint256 private _totalWeight;\n\n    constructor() {\n        _controller = msg.sender;\n        _factory = msg.sender;\n        _swapFee = MIN_FEE;\n        _publicSwap = false;\n        _finalized = false;\n    }\n\n    function isPublicSwap() external view returns (bool) {\n        return _publicSwap;\n    }\n\n    function isFinalized() external view returns (bool) {\n        return _finalized;\n    }\n\n    function isBound(address t) external view returns (bool) {\n        return _records[t].bound;\n    }\n\n    function getNumTokens() external view returns (uint256) {\n        return _tokens.length;\n    }\n\n    function getCurrentTokens() external view _viewlock_ returns (address[] memory tokens) {\n        return _tokens;\n    }\n\n    function getFinalTokens() external view _viewlock_ returns (address[] memory tokens) {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n        return _tokens;\n    }\n\n    function getDenormalizedWeight(address token) external view _viewlock_ returns (uint256) {\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\n        return _records[token].denorm;\n    }\n\n    function getTotalDenormalizedWeight() external view _viewlock_ returns (uint256) {\n        return _totalWeight;\n    }\n\n    function getNormalizedWeight(address token) external view _viewlock_ returns (uint256) {\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\n        uint256 denorm = _records[token].denorm;\n        return bdiv(denorm, _totalWeight);\n    }\n\n    function getBalance(address token) external view _viewlock_ returns (uint256) {\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\n        return _records[token].balance;\n    }\n\n    function getSwapFee() external view _viewlock_ returns (uint256) {\n        return _swapFee;\n    }\n\n    function getController() external view _viewlock_ returns (address) {\n        return _controller;\n    }\n\n    function setSwapFee(uint256 swapFee) external _logs_ _lock_ {\n        require(!_finalized, \"ERR_IS_FINALIZED\");\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        require(swapFee >= MIN_FEE, \"ERR_MIN_FEE\");\n        require(swapFee <= MAX_FEE, \"ERR_MAX_FEE\");\n        _swapFee = swapFee;\n    }\n\n    function setController(address manager) external _logs_ _lock_ {\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        _controller = manager;\n    }\n\n    function setPublicSwap(bool public_) external _logs_ _lock_ {\n        require(!_finalized, \"ERR_IS_FINALIZED\");\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        _publicSwap = public_;\n    }\n\n    function finalize() external _logs_ _lock_ {\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        require(!_finalized, \"ERR_IS_FINALIZED\");\n        require(_tokens.length >= MIN_BOUND_TOKENS, \"ERR_MIN_TOKENS\");\n\n        _finalized = true;\n        _publicSwap = true;\n\n        _mintPoolShare(INIT_POOL_SUPPLY);\n        _pushPoolShare(msg.sender, INIT_POOL_SUPPLY);\n    }\n\n    function bind(\n        address token,\n        uint256 balance,\n        uint256 denorm\n    )\n        external\n        _logs_ // _lock_  Bind does not lock because it jumps to `rebind`, which does\n    {\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        require(!_records[token].bound, \"ERR_IS_BOUND\");\n        require(!_finalized, \"ERR_IS_FINALIZED\");\n\n        require(_tokens.length < MAX_BOUND_TOKENS, \"ERR_MAX_TOKENS\");\n\n        _records[token] = Record({\n            bound: true,\n            index: _tokens.length,\n            denorm: 0, // balance and denorm will be validated\n            balance: 0 // and set by `rebind`\n        });\n        _tokens.push(token);\n        rebind(token, balance, denorm);\n    }\n\n    function rebind(\n        address token,\n        uint256 balance,\n        uint256 denorm\n    ) public _logs_ _lock_ {\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\n        require(!_finalized, \"ERR_IS_FINALIZED\");\n\n        require(denorm >= MIN_WEIGHT, \"ERR_MIN_WEIGHT\");\n        require(denorm <= MAX_WEIGHT, \"ERR_MAX_WEIGHT\");\n        require(balance >= MIN_BALANCE, \"ERR_MIN_BALANCE\");\n\n        // Adjust the denorm and totalWeight\n        uint256 oldWeight = _records[token].denorm;\n        if (denorm > oldWeight) {\n            _totalWeight = badd(_totalWeight, bsub(denorm, oldWeight));\n            require(_totalWeight <= MAX_TOTAL_WEIGHT, \"ERR_MAX_TOTAL_WEIGHT\");\n        } else if (denorm < oldWeight) {\n            _totalWeight = bsub(_totalWeight, bsub(oldWeight, denorm));\n        }\n        _records[token].denorm = denorm;\n\n        // Adjust the balance record and actual token balance\n        uint256 oldBalance = _records[token].balance;\n        _records[token].balance = balance;\n        if (balance > oldBalance) {\n            _pullUnderlying(token, msg.sender, bsub(balance, oldBalance));\n        } else if (balance < oldBalance) {\n            // In this case liquidity is being withdrawn, so charge EXIT_FEE\n            uint256 tokenBalanceWithdrawn = bsub(oldBalance, balance);\n            uint256 tokenExitFee = bmul(tokenBalanceWithdrawn, EXIT_FEE);\n            _pushUnderlying(token, msg.sender, bsub(tokenBalanceWithdrawn, tokenExitFee));\n            _pushUnderlying(token, _factory, tokenExitFee);\n        }\n    }\n\n    function unbind(address token) external _logs_ _lock_ {\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\n        require(!_finalized, \"ERR_IS_FINALIZED\");\n\n        uint256 tokenBalance = _records[token].balance;\n        uint256 tokenExitFee = bmul(tokenBalance, EXIT_FEE);\n\n        _totalWeight = bsub(_totalWeight, _records[token].denorm);\n\n        // Swap the token-to-unbind with the last token,\n        // then delete the last token\n        uint256 index = _records[token].index;\n        uint256 last = _tokens.length - 1;\n        _tokens[index] = _tokens[last];\n        _records[_tokens[index]].index = index;\n        _tokens.pop();\n        _records[token] = Record({bound: false, index: 0, denorm: 0, balance: 0});\n\n        _pushUnderlying(token, msg.sender, bsub(tokenBalance, tokenExitFee));\n        _pushUnderlying(token, _factory, tokenExitFee);\n    }\n\n    // Absorb any tokens that have been sent to this contract into the pool\n    function gulp(address token) external _logs_ _lock_ {\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\n        _records[token].balance = IERC20Balancer(token).balanceOf(address(this));\n    }\n\n    function getSpotPrice(address tokenIn, address tokenOut) external view _viewlock_ returns (uint256 spotPrice) {\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\n        Record storage inRecord = _records[tokenIn];\n        Record storage outRecord = _records[tokenOut];\n        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, _swapFee);\n    }\n\n    function getSpotPriceSansFee(address tokenIn, address tokenOut)\n        external\n        view\n        _viewlock_\n        returns (uint256 spotPrice)\n    {\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\n        Record storage inRecord = _records[tokenIn];\n        Record storage outRecord = _records[tokenOut];\n        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, 0);\n    }\n\n    function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external _logs_ _lock_ {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n\n        uint256 poolTotal = totalSupply();\n        uint256 ratio = bdiv(poolAmountOut, poolTotal);\n        require(ratio != 0, \"ERR_MATH_APPROX\");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address t = _tokens[i];\n            uint256 bal = _records[t].balance;\n            uint256 tokenAmountIn = bmul(ratio, bal);\n            require(tokenAmountIn != 0, \"ERR_MATH_APPROX\");\n            require(tokenAmountIn <= maxAmountsIn[i], \"ERR_LIMIT_IN\");\n            _records[t].balance = badd(_records[t].balance, tokenAmountIn);\n            emit LOG_JOIN(msg.sender, t, tokenAmountIn);\n            _pullUnderlying(t, msg.sender, tokenAmountIn);\n        }\n        _mintPoolShare(poolAmountOut);\n        _pushPoolShare(msg.sender, poolAmountOut);\n    }\n\n    function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external _logs_ _lock_ {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n\n        uint256 poolTotal = totalSupply();\n        uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\n        uint256 pAiAfterExitFee = bsub(poolAmountIn, exitFee);\n        uint256 ratio = bdiv(pAiAfterExitFee, poolTotal);\n        require(ratio != 0, \"ERR_MATH_APPROX\");\n\n        _pullPoolShare(msg.sender, poolAmountIn);\n        _pushPoolShare(_factory, exitFee);\n        _burnPoolShare(pAiAfterExitFee);\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address t = _tokens[i];\n            uint256 bal = _records[t].balance;\n            uint256 tokenAmountOut = bmul(ratio, bal);\n            require(tokenAmountOut != 0, \"ERR_MATH_APPROX\");\n            require(tokenAmountOut >= minAmountsOut[i], \"ERR_LIMIT_OUT\");\n            _records[t].balance = bsub(_records[t].balance, tokenAmountOut);\n            emit LOG_EXIT(msg.sender, t, tokenAmountOut);\n            _pushUnderlying(t, msg.sender, tokenAmountOut);\n        }\n    }\n\n    function calcExitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n\n        uint256 poolTotal = totalSupply();\n        uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\n        uint256 pAiAfterExitFee = bsub(poolAmountIn, exitFee);\n        uint256 ratio = bdiv(pAiAfterExitFee, poolTotal);\n\n        uint256[] memory _amounts = new uint256[](_tokens.length * 2);\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address t = _tokens[i];\n            uint256 bal = _records[t].balance;\n\n            _amounts[i] = bmul(ratio, bal);\n            _amounts[_tokens.length + i] = minAmountsOut[i];\n            require(_amounts[i] >= minAmountsOut[i], \"ERR_LIMIT_OUT\");\n        }\n\n        return _amounts;\n    }\n\n    function swapExactAmountIn(\n        address tokenIn,\n        uint256 tokenAmountIn,\n        address tokenOut,\n        uint256 minAmountOut,\n        uint256 maxPrice\n    ) external _logs_ _lock_ returns (uint256 tokenAmountOut, uint256 spotPriceAfter) {\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\n        require(_publicSwap, \"ERR_SWAP_NOT_PUBLIC\");\n\n        Record storage inRecord = _records[address(tokenIn)];\n        Record storage outRecord = _records[address(tokenOut)];\n\n        require(tokenAmountIn <= bmul(inRecord.balance, MAX_IN_RATIO), \"ERR_MAX_IN_RATIO\");\n\n        uint256 spotPriceBefore =\n            calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, _swapFee);\n        require(spotPriceBefore <= maxPrice, \"ERR_BAD_LIMIT_PRICE\");\n\n        tokenAmountOut = calcOutGivenIn(\n            inRecord.balance,\n            inRecord.denorm,\n            outRecord.balance,\n            outRecord.denorm,\n            tokenAmountIn,\n            _swapFee\n        );\n        require(tokenAmountOut >= minAmountOut, \"ERR_LIMIT_OUT\");\n\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n\n        spotPriceAfter = calcSpotPrice(\n            inRecord.balance,\n            inRecord.denorm,\n            outRecord.balance,\n            outRecord.denorm,\n            _swapFee\n        );\n        require(spotPriceAfter >= spotPriceBefore, \"ERR_MATH_APPROX\");\n        require(spotPriceAfter <= maxPrice, \"ERR_LIMIT_PRICE\");\n        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), \"ERR_MATH_APPROX\");\n\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\n\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n\n        return (tokenAmountOut, spotPriceAfter);\n    }\n\n    function swapExactAmountOut(\n        address tokenIn,\n        uint256 maxAmountIn,\n        address tokenOut,\n        uint256 tokenAmountOut,\n        uint256 maxPrice\n    ) external _logs_ _lock_ returns (uint256 tokenAmountIn, uint256 spotPriceAfter) {\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\n        require(_publicSwap, \"ERR_SWAP_NOT_PUBLIC\");\n\n        Record storage inRecord = _records[address(tokenIn)];\n        Record storage outRecord = _records[address(tokenOut)];\n\n        require(tokenAmountOut <= bmul(outRecord.balance, MAX_OUT_RATIO), \"ERR_MAX_OUT_RATIO\");\n\n        uint256 spotPriceBefore =\n            calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, _swapFee);\n        require(spotPriceBefore <= maxPrice, \"ERR_BAD_LIMIT_PRICE\");\n\n        tokenAmountIn = calcInGivenOut(\n            inRecord.balance,\n            inRecord.denorm,\n            outRecord.balance,\n            outRecord.denorm,\n            tokenAmountOut,\n            _swapFee\n        );\n        require(tokenAmountIn <= maxAmountIn, \"ERR_LIMIT_IN\");\n\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n\n        spotPriceAfter = calcSpotPrice(\n            inRecord.balance,\n            inRecord.denorm,\n            outRecord.balance,\n            outRecord.denorm,\n            _swapFee\n        );\n        require(spotPriceAfter >= spotPriceBefore, \"ERR_MATH_APPROX\");\n        require(spotPriceAfter <= maxPrice, \"ERR_LIMIT_PRICE\");\n        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), \"ERR_MATH_APPROX\");\n\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\n\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n\n        return (tokenAmountIn, spotPriceAfter);\n    }\n\n    function joinswapExternAmountIn(\n        address tokenIn,\n        uint256 tokenAmountIn,\n        uint256 minPoolAmountOut\n    ) external _logs_ _lock_ returns (uint256 poolAmountOut) {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n        require(tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \"ERR_MAX_IN_RATIO\");\n\n        Record storage inRecord = _records[tokenIn];\n\n        poolAmountOut = calcPoolOutGivenSingleIn(\n            inRecord.balance,\n            inRecord.denorm,\n            _totalSupply,\n            _totalWeight,\n            tokenAmountIn,\n            _swapFee\n        );\n\n        require(poolAmountOut >= minPoolAmountOut, \"ERR_LIMIT_OUT\");\n\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\n\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\n\n        _mintPoolShare(poolAmountOut);\n        _pushPoolShare(msg.sender, poolAmountOut);\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n\n        return poolAmountOut;\n    }\n\n    function joinswapPoolAmountOut(\n        address tokenIn,\n        uint256 poolAmountOut,\n        uint256 maxAmountIn\n    ) external _logs_ _lock_ returns (uint256 tokenAmountIn) {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n\n        Record storage inRecord = _records[tokenIn];\n\n        tokenAmountIn = calcSingleInGivenPoolOut(\n            inRecord.balance,\n            inRecord.denorm,\n            _totalSupply,\n            _totalWeight,\n            poolAmountOut,\n            _swapFee\n        );\n\n        require(tokenAmountIn != 0, \"ERR_MATH_APPROX\");\n        require(tokenAmountIn <= maxAmountIn, \"ERR_LIMIT_IN\");\n\n        require(tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \"ERR_MAX_IN_RATIO\");\n\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\n\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\n\n        _mintPoolShare(poolAmountOut);\n        _pushPoolShare(msg.sender, poolAmountOut);\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n\n        return tokenAmountIn;\n    }\n\n    function exitswapPoolAmountIn(\n        address tokenOut,\n        uint256 poolAmountIn,\n        uint256 minAmountOut\n    ) external _logs_ _lock_ returns (uint256 tokenAmountOut) {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\n\n        Record storage outRecord = _records[tokenOut];\n\n        tokenAmountOut = calcSingleOutGivenPoolIn(\n            outRecord.balance,\n            outRecord.denorm,\n            _totalSupply,\n            _totalWeight,\n            poolAmountIn,\n            _swapFee\n        );\n\n        require(tokenAmountOut >= minAmountOut, \"ERR_LIMIT_OUT\");\n\n        require(tokenAmountOut <= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \"ERR_MAX_OUT_RATIO\");\n\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n\n        uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\n\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\n\n        _pullPoolShare(msg.sender, poolAmountIn);\n        _burnPoolShare(bsub(poolAmountIn, exitFee));\n        _pushPoolShare(_factory, exitFee);\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n\n        return tokenAmountOut;\n    }\n\n    function exitswapExternAmountOut(\n        address tokenOut,\n        uint256 tokenAmountOut,\n        uint256 maxPoolAmountIn\n    ) external _logs_ _lock_ returns (uint256 poolAmountIn) {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\n        require(tokenAmountOut <= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \"ERR_MAX_OUT_RATIO\");\n\n        Record storage outRecord = _records[tokenOut];\n\n        poolAmountIn = calcPoolInGivenSingleOut(\n            outRecord.balance,\n            outRecord.denorm,\n            _totalSupply,\n            _totalWeight,\n            tokenAmountOut,\n            _swapFee\n        );\n\n        require(poolAmountIn != 0, \"ERR_MATH_APPROX\");\n        require(poolAmountIn <= maxPoolAmountIn, \"ERR_LIMIT_IN\");\n\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n\n        uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\n\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\n\n        _pullPoolShare(msg.sender, poolAmountIn);\n        _burnPoolShare(bsub(poolAmountIn, exitFee));\n        _pushPoolShare(_factory, exitFee);\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n\n        return poolAmountIn;\n    }\n\n    // ==\n    // 'Underlying' token-manipulation functions make external calls but are NOT locked\n    // You must `_lock_` or otherwise ensure reentry-safety\n\n    function _pullUnderlying(\n        address erc20,\n        address from,\n        uint256 amount\n    ) internal {\n        bool xfer = IERC20Balancer(erc20).transferFrom(from, address(this), amount);\n        require(xfer, \"ERR_ERC20_FALSE\");\n    }\n\n    function _pushUnderlying(\n        address erc20,\n        address to,\n        uint256 amount\n    ) internal {\n        bool xfer = IERC20Balancer(erc20).transfer(to, amount);\n        require(xfer, \"ERR_ERC20_FALSE\");\n    }\n\n    function _pullPoolShare(address from, uint256 amount) internal {\n        _pull(from, amount);\n    }\n\n    function _pushPoolShare(address to, uint256 amount) internal {\n        _push(to, amount);\n    }\n\n    function _mintPoolShare(uint256 amount) internal {\n        _mint(amount);\n    }\n\n    function _burnPoolShare(uint256 amount) internal {\n        _burn(amount);\n    }\n}\n"
    },
    "contracts/balancer/BToken.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"./BNum.sol\";\n\ninterface IERC20Balancer {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address whom) external view returns (uint256);\n\n    function allowance(address src, address dst) external view returns (uint256);\n\n    function approve(address dst, uint256 amt) external returns (bool);\n\n    function transfer(address dst, uint256 amt) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amt\n    ) external returns (bool);\n}\n\ncontract BTokenBase is BNum {\n    mapping(address => uint256) internal _balance;\n    mapping(address => mapping(address => uint256)) internal _allowance;\n    uint256 internal _totalSupply;\n\n    event Approval(address indexed src, address indexed dst, uint256 amt);\n    event Transfer(address indexed src, address indexed dst, uint256 amt);\n\n    function _mint(uint256 amt) internal {\n        _balance[address(this)] = badd(_balance[address(this)], amt);\n        _totalSupply = badd(_totalSupply, amt);\n        emit Transfer(address(0), address(this), amt);\n    }\n\n    function _burn(uint256 amt) internal {\n        require(_balance[address(this)] >= amt, \"ERR_INSUFFICIENT_BAL\");\n        _balance[address(this)] = bsub(_balance[address(this)], amt);\n        _totalSupply = bsub(_totalSupply, amt);\n        emit Transfer(address(this), address(0), amt);\n    }\n\n    function _move(\n        address src,\n        address dst,\n        uint256 amt\n    ) internal {\n        require(_balance[src] >= amt, \"ERR_INSUFFICIENT_BAL\");\n        _balance[src] = bsub(_balance[src], amt);\n        _balance[dst] = badd(_balance[dst], amt);\n        emit Transfer(src, dst, amt);\n    }\n\n    function _push(address to, uint256 amt) internal {\n        _move(address(this), to, amt);\n    }\n\n    function _pull(address from, uint256 amt) internal {\n        _move(from, address(this), amt);\n    }\n}\n\ncontract BToken is BTokenBase, IERC20Balancer {\n    string private _name = \"Balancer Pool Token\";\n    string private _symbol = \"BPT\";\n    uint8 private _decimals = 18;\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function allowance(address src, address dst) external view override returns (uint256) {\n        return _allowance[src][dst];\n    }\n\n    function balanceOf(address whom) external view override returns (uint256) {\n        return _balance[whom];\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function approve(address dst, uint256 amt) external override returns (bool) {\n        _allowance[msg.sender][dst] = amt;\n        emit Approval(msg.sender, dst, amt);\n        return true;\n    }\n\n    function increaseApproval(address dst, uint256 amt) external returns (bool) {\n        _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\n        return true;\n    }\n\n    function decreaseApproval(address dst, uint256 amt) external returns (bool) {\n        uint256 oldValue = _allowance[msg.sender][dst];\n        if (amt > oldValue) {\n            _allowance[msg.sender][dst] = 0;\n        } else {\n            _allowance[msg.sender][dst] = bsub(oldValue, amt);\n        }\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\n        return true;\n    }\n\n    function transfer(address dst, uint256 amt) external override returns (bool) {\n        _move(msg.sender, dst, amt);\n        return true;\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amt\n    ) external override returns (bool) {\n        require(msg.sender == src || amt <= _allowance[src][msg.sender], \"ERR_BTOKEN_BAD_CALLER\");\n        _move(src, dst, amt);\n        if (msg.sender != src && _allowance[src][msg.sender] != uint256(-1)) {\n            _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\n            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\n        }\n        return true;\n    }\n}\n"
    },
    "contracts/balancer/BMath.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"./BNum.sol\";\n\ncontract BMath is BBronze, BConst, BNum {\n    /**********************************************************************************************\n    // calcSpotPrice                                                                             //\n    // sP = spotPrice                                                                            //\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\n    // wO = tokenWeightOut                                                                       //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n    function calcSpotPrice(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 swapFee\n    ) public pure returns (uint256 spotPrice) {\n        uint256 numer = bdiv(tokenBalanceIn, tokenWeightIn);\n        uint256 denom = bdiv(tokenBalanceOut, tokenWeightOut);\n        uint256 ratio = bdiv(numer, denom);\n        uint256 scale = bdiv(BONE, bsub(BONE, swapFee));\n        return (spotPrice = bmul(ratio, scale));\n    }\n\n    /**********************************************************************************************\n    // calcOutGivenIn                                                                            //\n    // aO = tokenAmountOut                                                                       //\n    // bO = tokenBalanceOut                                                                      //\n    // bI = tokenBalanceIn              /      /            bI             \\    (wI / wO) \\      //\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\n    // wI = tokenWeightIn               \\      \\ ( bI + ( aI * ( 1 - sF )) /              /      //\n    // wO = tokenWeightOut                                                                       //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n    function calcOutGivenIn(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 tokenAmountIn,\n        uint256 swapFee\n    ) public pure returns (uint256 tokenAmountOut) {\n        uint256 weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\n        uint256 adjustedIn = bsub(BONE, swapFee);\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\n        uint256 y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\n        uint256 foo = bpow(y, weightRatio);\n        uint256 bar = bsub(BONE, foo);\n        tokenAmountOut = bmul(tokenBalanceOut, bar);\n        return tokenAmountOut;\n    }\n\n    /**********************************************************************************************\n    // calcInGivenOut                                                                            //\n    // aI = tokenAmountIn                                                                        //\n    // bO = tokenBalanceOut               /  /     bO      \\    (wO / wI)      \\                 //\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\n    // aO = tokenAmountOut    aI =        \\  \\ ( bO - aO ) /                   /                 //\n    // wI = tokenWeightIn           --------------------------------------------                 //\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n    function calcInGivenOut(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 tokenAmountOut,\n        uint256 swapFee\n    ) public pure returns (uint256 tokenAmountIn) {\n        uint256 weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\n        uint256 diff = bsub(tokenBalanceOut, tokenAmountOut);\n        uint256 y = bdiv(tokenBalanceOut, diff);\n        uint256 foo = bpow(y, weightRatio);\n        foo = bsub(foo, BONE);\n        tokenAmountIn = bsub(BONE, swapFee);\n        tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\n        return tokenAmountIn;\n    }\n\n    /**********************************************************************************************\n    // calcPoolOutGivenSingleIn                                                                  //\n    // pAo = poolAmountOut         /                                              \\              //\n    // tAi = tokenAmountIn        ///      /     //    wI \\      \\\\       \\     wI \\             //\n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\    --  \\            //\n    // tW = totalWeight     pAo=||  \\      \\     \\\\    tW /      //         | ^ tW   | * pS - pS //\n    // tBi = tokenBalanceIn      \\\\  ------------------------------------- /        /            //\n    // pS = poolSupply            \\\\                    tBi               /        /             //\n    // sF = swapFee                \\                                              /              //\n    **********************************************************************************************/\n\n    // Charge the trading fee for the proportion of tokenAi\n    ///  which is implicitly traded to the other pool tokens.\n    // That proportion is (1- weightTokenIn)\n    // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\n\n    function calcPoolOutGivenSingleIn(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 tokenAmountIn,\n        uint256 swapFee\n    ) public pure returns (uint256 poolAmountOut) {\n        uint256 normalizedWeight = bdiv(tokenWeightIn, totalWeight);\n        uint256 zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\n        uint256 tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BONE, zaz));\n\n        uint256 newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\n        uint256 tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\n\n        // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\n        uint256 poolRatio = bpow(tokenInRatio, normalizedWeight);\n        uint256 newPoolSupply = bmul(poolRatio, poolSupply);\n        poolAmountOut = bsub(newPoolSupply, poolSupply);\n        return poolAmountOut;\n    }\n\n    /**********************************************************************************************\n    // calcSingleInGivenPoolOut                                                                  //\n    // tAi = tokenAmountIn              //(pS + pAo)\\     /    1    \\\\                           //\n    // pS = poolSupply                 || ---------  | ^ | --------- || * bI - bI                //\n    // pAo = poolAmountOut              \\\\    pS    /     \\(wI / tW)//                           //\n    // bI = balanceIn          tAi =  --------------------------------------------               //\n    // wI = weightIn                              /      wI  \\                                   //\n    // tW = totalWeight                          |  1 - ----  |  * sF                            //\n    // sF = swapFee                               \\      tW  /                                   //\n    **********************************************************************************************/\n    function calcSingleInGivenPoolOut(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 poolAmountOut,\n        uint256 swapFee\n    ) public pure returns (uint256 tokenAmountIn) {\n        uint256 normalizedWeight = bdiv(tokenWeightIn, totalWeight);\n        uint256 newPoolSupply = badd(poolSupply, poolAmountOut);\n        uint256 poolRatio = bdiv(newPoolSupply, poolSupply);\n\n        //uint newBalTi = poolRatio^(1/weightTi) * balTi;\n        uint256 boo = bdiv(BONE, normalizedWeight);\n        uint256 tokenInRatio = bpow(poolRatio, boo);\n        uint256 newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\n        uint256 tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\n        // Do reverse order of fees charged in joinswap_ExternAmountIn, this way\n        //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\n        //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\n        uint256 zar = bmul(bsub(BONE, normalizedWeight), swapFee);\n        tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));\n        return tokenAmountIn;\n    }\n\n    /**********************************************************************************************\n    // calcSingleOutGivenPoolIn                                                                  //\n    // tAo = tokenAmountOut            /      /                                             \\\\   //\n    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\     /    1    \\      \\\\  //\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\n    // ps = poolSupply                \\      \\\\          pS           /     \\(wO / tW)/      //  //\n    // wI = tokenWeightIn      tAo =   \\      \\                                             //   //\n    // tW = totalWeight                    /     /      wO \\       \\                             //\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\n    // eF = exitFee                        \\     \\      tW /       /                             //\n    **********************************************************************************************/\n    function calcSingleOutGivenPoolIn(\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 poolAmountIn,\n        uint256 swapFee\n    ) public pure returns (uint256 tokenAmountOut) {\n        uint256 normalizedWeight = bdiv(tokenWeightOut, totalWeight);\n        // charge exit fee on the pool token side\n        // pAiAfterExitFee = pAi*(1-exitFee)\n        uint256 poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BONE, EXIT_FEE));\n        uint256 newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\n        uint256 poolRatio = bdiv(newPoolSupply, poolSupply);\n\n        // newBalTo = poolRatio^(1/weightTo) * balTo;\n        uint256 tokenOutRatio = bpow(poolRatio, bdiv(BONE, normalizedWeight));\n        uint256 newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\n\n        uint256 tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);\n\n        // charge swap fee on the output token side\n        //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\n        uint256 zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\n        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BONE, zaz));\n        return tokenAmountOut;\n    }\n\n    /**********************************************************************************************\n    // calcPoolInGivenSingleOut                                                                  //\n    // pAi = poolAmountIn               // /               tAo             \\\\     / wO \\     \\   //\n    // bO = tokenBalanceOut            // | bO - -------------------------- |\\   | ---- |     \\  //\n    // tAo = tokenAmountOut      pS - ||   \\     1 - ((1 - (tO / tW)) * sF)/  | ^ \\ tW /  * pS | //\n    // ps = poolSupply                 \\\\ -----------------------------------/                /  //\n    // wO = tokenWeightOut  pAi =       \\\\               bO                 /                /   //\n    // tW = totalWeight           -------------------------------------------------------------  //\n    // sF = swapFee                                        ( 1 - eF )                            //\n    // eF = exitFee                                                                              //\n    **********************************************************************************************/\n    function calcPoolInGivenSingleOut(\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 tokenAmountOut,\n        uint256 swapFee\n    ) public pure returns (uint256 poolAmountIn) {\n        // charge swap fee on the output token side\n        uint256 normalizedWeight = bdiv(tokenWeightOut, totalWeight);\n        //uint tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;\n        uint256 zoo = bsub(BONE, normalizedWeight);\n        uint256 zar = bmul(zoo, swapFee);\n        uint256 tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BONE, zar));\n\n        uint256 newTokenBalanceOut = bsub(tokenBalanceOut, tokenAmountOutBeforeSwapFee);\n        uint256 tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\n\n        //uint newPoolSupply = (ratioTo ^ weightTo) * poolSupply;\n        uint256 poolRatio = bpow(tokenOutRatio, normalizedWeight);\n        uint256 newPoolSupply = bmul(poolRatio, poolSupply);\n        uint256 poolAmountInAfterExitFee = bsub(poolSupply, newPoolSupply);\n\n        // charge exit fee on the pool token side\n        // pAi = pAiAfterExitFee/(1-exitFee)\n        poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BONE, EXIT_FEE));\n        return poolAmountIn;\n    }\n}\n"
    },
    "contracts/libraries/IERC20Full.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IERC20Full is IERC20 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/turbo/TurboShareTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./OwnedShareToken.sol\";\n\nabstract contract TurboShareTokenFactory {\n    function createShareTokens(string[] memory _names, address _owner) internal returns (OwnedERC20[] memory) {\n        uint256 _numOutcomes = _names.length;\n        OwnedERC20[] memory _tokens = new OwnedERC20[](_numOutcomes);\n\n        for (uint256 _i = 0; _i < _numOutcomes; _i++) {\n            _tokens[_i] = new OwnedERC20(_names[_i], _names[_i], _owner);\n        }\n        return _tokens;\n    }\n}\n\nabstract contract TurboShareTokenFactoryV1 {\n    function createShareTokens(\n        string[] memory _names,\n        string[] memory _symbols,\n        address _owner\n    ) internal returns (OwnedERC20[] memory) {\n        uint256 _numOutcomes = _names.length;\n        OwnedERC20[] memory _tokens = new OwnedERC20[](_numOutcomes);\n\n        for (uint256 _i = 0; _i < _numOutcomes; _i++) {\n            _tokens[_i] = new OwnedERC20(_names[_i], _symbols[_i], _owner);\n        }\n        return _tokens;\n    }\n}\n"
    },
    "contracts/turbo/FeePot.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../libraries/SafeMathUint256.sol\";\nimport \"../libraries/IERC20Full.sol\";\n\ncontract FeePot is ERC20 {\n    using SafeMathUint256 for uint256;\n\n    uint256 internal constant magnitude = 2**128;\n\n    IERC20Full public collateral;\n    IERC20Full public reputationToken;\n\n    uint256 public magnifiedFeesPerShare;\n\n    mapping(address => uint256) public magnifiedFeesCorrections;\n    mapping(address => uint256) public storedFees;\n\n    uint256 public feeReserve;\n\n    constructor(IERC20Full _collateral, IERC20Full _reputationToken)\n        ERC20(\n            string(abi.encodePacked(\"S_\", _reputationToken.symbol())),\n            string(abi.encodePacked(\"S_\", _reputationToken.symbol()))\n        )\n    {\n        collateral = _collateral;\n        reputationToken = _reputationToken;\n\n        require(_collateral != IERC20Full(0));\n    }\n\n    function depositFees(uint256 _amount) public returns (bool) {\n        collateral.transferFrom(msg.sender, address(this), _amount);\n        uint256 _totalSupply = totalSupply(); // after collateral.transferFrom to prevent reentrancy causing stale totalSupply\n        if (_totalSupply == 0) {\n            feeReserve = feeReserve.add(_amount);\n            return true;\n        }\n        if (feeReserve > 0) {\n            _amount = _amount.add(feeReserve);\n            feeReserve = 0;\n        }\n        magnifiedFeesPerShare = magnifiedFeesPerShare.add((_amount).mul(magnitude) / _totalSupply);\n        return true;\n    }\n\n    function withdrawableFeesOf(address _owner) public view returns (uint256) {\n        return earnedFeesOf(_owner).add(storedFees[_owner]);\n    }\n\n    function earnedFeesOf(address _owner) public view returns (uint256) {\n        uint256 _ownerBalance = balanceOf(_owner);\n        uint256 _magnifiedFees = magnifiedFeesPerShare.mul(_ownerBalance);\n        return _magnifiedFees.sub(magnifiedFeesCorrections[_owner]) / magnitude;\n    }\n\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal override {\n        storedFees[_from] = storedFees[_from].add(earnedFeesOf(_from));\n        super._transfer(_from, _to, _amount);\n\n        magnifiedFeesCorrections[_from] = magnifiedFeesPerShare.mul(balanceOf(_from));\n        magnifiedFeesCorrections[_to] = magnifiedFeesCorrections[_to].add(magnifiedFeesPerShare.mul(_amount));\n    }\n\n    function stake(uint256 _amount) external returns (bool) {\n        reputationToken.transferFrom(msg.sender, address(this), _amount);\n        _mint(msg.sender, _amount);\n        magnifiedFeesCorrections[msg.sender] = magnifiedFeesCorrections[msg.sender].add(\n            magnifiedFeesPerShare.mul(_amount)\n        );\n        return true;\n    }\n\n    function exit(uint256 _amount) external returns (bool) {\n        redeemInternal(msg.sender);\n        _burn(msg.sender, _amount);\n        reputationToken.transfer(msg.sender, _amount);\n        magnifiedFeesCorrections[msg.sender] = magnifiedFeesPerShare.mul(balanceOf(msg.sender));\n        return true;\n    }\n\n    function redeem() public returns (bool) {\n        redeemInternal(msg.sender);\n        magnifiedFeesCorrections[msg.sender] = magnifiedFeesPerShare.mul(balanceOf(msg.sender));\n        return true;\n    }\n\n    function redeemInternal(address _account) internal {\n        uint256 _withdrawableFees = withdrawableFeesOf(_account);\n        if (_withdrawableFees > 0) {\n            storedFees[_account] = 0;\n            collateral.transfer(_account, _withdrawableFees);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/turbo/OwnedShareToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../libraries/Ownable.sol\";\n\ncontract OwnedERC20 is ERC20, Ownable {\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        address _owner\n    ) ERC20(name_, symbol_) {\n        owner = _owner;\n    }\n\n    function trustedTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external onlyOwner {\n        _transfer(_from, _to, _amount);\n    }\n\n    function trustedMint(address _target, uint256 _amount) external onlyOwner {\n        _mint(_target, _amount);\n    }\n\n    function trustedBurn(address _target, uint256 _amount) external onlyOwner {\n        _burn(_target, _amount);\n    }\n\n    function trustedBurnAll(address _target) external onlyOwner returns (uint256) {\n        uint256 _balance = balanceOf(_target);\n        _burn(_target, _balance);\n        return _balance;\n    }\n\n    function onTransferOwnership(address, address) internal override {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/libraries/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"./IOwnable.sol\";\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\nabstract contract Ownable is IOwnable {\n    address internal owner;\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor() {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function getOwner() public view override returns (address) {\n        return owner;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param _newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address _newOwner) public override onlyOwner returns (bool) {\n        require(_newOwner != address(0));\n        onTransferOwnership(owner, _newOwner);\n        owner = _newOwner;\n        return true;\n    }\n\n    // Subclasses of this token may want to send additional logs through the centralized Augur log emitter contract\n    function onTransferOwnership(address, address) internal virtual;\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/libraries/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\ninterface IOwnable {\n    function getOwner() external view returns (address);\n\n    function transferOwnership(address _newOwner) external returns (bool);\n}\n"
    },
    "contracts/turbo/Fetcher.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"./FeePot.sol\";\nimport \"../libraries/SafeMathInt256.sol\";\nimport \"./MMAMarketFactory.sol\";\nimport \"./AMMFactory.sol\";\nimport \"./CryptoMarketFactory.sol\";\nimport \"./NBAMarketFactory.sol\";\n\n// Helper contract for grabbing huge amounts of data without overloading multicall.\nabstract contract Fetcher {\n    using SafeMathUint256 for uint256;\n    using SafeMathInt256 for int256;\n\n    struct CollateralBundle {\n        address addr;\n        string symbol;\n        uint256 decimals;\n    }\n\n    struct MarketFactoryBundle {\n        uint256 shareFactor;\n        uint256 stakerFee;\n        uint256 settlementFee;\n        uint256 protocolFee;\n        FeePot feePot;\n        CollateralBundle collateral;\n        uint256 marketCount;\n    }\n\n    struct PoolBundle {\n        address addr;\n        uint256[] tokenRatios;\n        uint256[] balances;\n        uint256[] weights;\n        uint256 swapFee;\n        uint256 totalSupply;\n    }\n\n    struct StaticMarketBundle {\n        AbstractMarketFactoryV3 factory;\n        uint256 marketId;\n        PoolBundle pool;\n        OwnedERC20[] shareTokens;\n        uint256 creationTimestamp;\n        OwnedERC20 winner;\n        uint256[] initialOdds;\n    }\n\n    struct DynamicMarketBundle {\n        AbstractMarketFactoryV3 factory;\n        uint256 marketId;\n        PoolBundle pool;\n        OwnedERC20 winner;\n    }\n\n    string public marketType;\n    string public version;\n\n    constructor(string memory _type, string memory _version) {\n        marketType = _type;\n        version = _version;\n    }\n\n    function buildCollateralBundle(IERC20Full _collateral) internal view returns (CollateralBundle memory _bundle) {\n        _bundle.addr = address(_collateral);\n        _bundle.symbol = _collateral.symbol();\n        _bundle.decimals = _collateral.decimals();\n    }\n\n    function buildMarketFactoryBundle(AbstractMarketFactoryV3 _marketFactory)\n        internal\n        view\n        returns (MarketFactoryBundle memory _bundle)\n    {\n        _bundle.shareFactor = _marketFactory.shareFactor();\n        _bundle.stakerFee = _marketFactory.stakerFee();\n        _bundle.settlementFee = _marketFactory.settlementFee();\n        _bundle.protocolFee = _marketFactory.protocolFee();\n        _bundle.feePot = _marketFactory.feePot();\n        _bundle.collateral = buildCollateralBundle(_marketFactory.collateral());\n        _bundle.marketCount = _marketFactory.marketCount();\n    }\n\n    function buildStaticMarketBundle(\n        AbstractMarketFactoryV3 _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _marketId\n    ) internal view returns (StaticMarketBundle memory _bundle) {\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n        _bundle.factory = _marketFactory;\n        _bundle.marketId = _marketId;\n        _bundle.shareTokens = _market.shareTokens;\n        _bundle.creationTimestamp = _market.creationTimestamp;\n        _bundle.winner = _market.winner;\n        _bundle.pool = buildPoolBundle(_marketFactory, _ammFactory, _marketId);\n        _bundle.initialOdds = _market.initialOdds;\n    }\n\n    function buildDynamicMarketBundle(\n        AbstractMarketFactoryV3 _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _marketId\n    ) internal view returns (DynamicMarketBundle memory _bundle) {\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n\n        _bundle.factory = _marketFactory;\n        _bundle.marketId = _marketId;\n        _bundle.winner = _market.winner;\n        _bundle.pool = buildPoolBundle(_marketFactory, _ammFactory, _marketId);\n    }\n\n    function buildPoolBundle(\n        AbstractMarketFactoryV3 _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _marketId\n    ) internal view returns (PoolBundle memory _bundle) {\n        BPool _pool = _ammFactory.getPool(_marketFactory, _marketId);\n        if (_pool == BPool(address(0))) return _bundle;\n\n        _bundle.addr = address(_pool);\n        _bundle.totalSupply = _pool.totalSupply();\n        _bundle.swapFee = _ammFactory.getSwapFee(_marketFactory, _marketId);\n        _bundle.balances = _ammFactory.getPoolBalances(_marketFactory, _marketId);\n        _bundle.tokenRatios = _ammFactory.tokenRatios(_marketFactory, _marketId);\n        _bundle.weights = _ammFactory.getPoolWeights(_marketFactory, _marketId);\n    }\n\n    function openOrHasWinningShares(AbstractMarketFactoryV3 _marketFactory, uint256 _marketId)\n        internal\n        view\n        returns (bool)\n    {\n        AbstractMarketFactoryV3.Market memory _market = _marketFactory.getMarket(_marketId);\n        if (_market.winner == OwnedERC20(address(0))) return true; // open\n        return _market.winner.totalSupply() > 0; // has winning shares\n    }\n}\n\nabstract contract SportsFetcher is Fetcher {\n    struct SpecificMarketFactoryBundle {\n        MarketFactoryBundle super;\n    }\n\n    struct StaticEventBundle {\n        uint256 id;\n        StaticMarketBundle[] markets;\n        int256[] lines;\n        uint256 estimatedStartTime;\n        uint256 homeTeamId;\n        uint256 awayTeamId;\n        string homeTeamName;\n        string awayTeamName;\n        // Dynamics\n        Sport.SportsEventStatus status;\n        uint256 homeScore;\n        uint256 awayScore;\n    }\n\n    struct DynamicEventBundle {\n        uint256 id;\n        Sport.SportsEventStatus status;\n        DynamicMarketBundle[] markets;\n        uint256 homeScore;\n        uint256 awayScore;\n    }\n\n    function buildSpecificMarketFactoryBundle(address _marketFactory)\n        internal\n        view\n        returns (SpecificMarketFactoryBundle memory _bundle)\n    {\n        _bundle.super = buildMarketFactoryBundle(AbstractMarketFactoryV3(_marketFactory));\n    }\n\n    function fetchInitial(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _offset,\n        uint256 _total\n    )\n        public\n        view\n        returns (\n            SpecificMarketFactoryBundle memory _marketFactoryBundle,\n            StaticEventBundle[] memory _eventBundles,\n            uint256 _lowestEventIndex\n        )\n    {\n        _marketFactoryBundle = buildSpecificMarketFactoryBundle(_marketFactory);\n        (_eventBundles, _lowestEventIndex) = buildStaticEventBundles(_marketFactory, _ammFactory, _offset, _total);\n    }\n\n    function fetchDynamic(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _offset,\n        uint256 _total\n    ) public view returns (DynamicEventBundle[] memory _bundles, uint256 _lowestEventIndex) {\n        (_bundles, _lowestEventIndex) = buildDynamicEventBundles(_marketFactory, _ammFactory, _offset, _total);\n    }\n\n    function buildStaticEventBundles(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _offset,\n        uint256 _total\n    ) internal view returns (StaticEventBundle[] memory _bundles, uint256 _lowestEventIndex) {\n        uint256[] memory _eventIds;\n        (_eventIds, _lowestEventIndex) = listOfInterestingEvents(_marketFactory, _offset, _total);\n\n        _total = _eventIds.length;\n        _bundles = new StaticEventBundle[](_total);\n        for (uint256 i; i < _total; i++) {\n            _bundles[i] = buildStaticEventBundle(_marketFactory, _ammFactory, _eventIds[i]);\n        }\n    }\n\n    function buildDynamicEventBundles(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _offset,\n        uint256 _total\n    ) internal view returns (DynamicEventBundle[] memory _bundles, uint256 _lowestEventIndex) {\n        uint256[] memory _eventIds;\n        (_eventIds, _lowestEventIndex) = listOfInterestingEvents(_marketFactory, _offset, _total);\n\n        _total = _eventIds.length;\n        _bundles = new DynamicEventBundle[](_total);\n        for (uint256 i; i < _total; i++) {\n            _bundles[i] = buildDynamicEventBundle(_marketFactory, _ammFactory, _eventIds[i]);\n        }\n    }\n\n    function buildStaticEventBundle(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _eventId\n    ) public view returns (StaticEventBundle memory _bundle) {\n        Sport.SportsEvent memory _event = Sport(_marketFactory).getSportsEvent(_eventId);\n\n        StaticMarketBundle[] memory _markets = new StaticMarketBundle[](_event.markets.length);\n        for (uint256 i = 0; i < _markets.length; i++) {\n            _markets[i] = buildStaticMarketBundle(\n                AbstractMarketFactoryV3(_marketFactory),\n                _ammFactory,\n                _event.markets[i]\n            );\n        }\n\n        _bundle.id = _eventId;\n        _bundle.status = _event.status;\n        _bundle.markets = _markets;\n        _bundle.lines = _event.lines;\n        _bundle.estimatedStartTime = _event.estimatedStartTime;\n        _bundle.homeTeamId = _event.homeTeamId;\n        _bundle.awayTeamId = _event.awayTeamId;\n        _bundle.homeTeamName = _event.homeTeamName;\n        _bundle.awayTeamName = _event.awayTeamName;\n        _bundle.homeScore = _event.homeScore;\n        _bundle.awayScore = _event.awayScore;\n    }\n\n    function buildDynamicEventBundle(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _eventId\n    ) public view returns (DynamicEventBundle memory _bundle) {\n        Sport.SportsEvent memory _event = Sport(_marketFactory).getSportsEvent(_eventId);\n\n        DynamicMarketBundle[] memory _markets = new DynamicMarketBundle[](_event.markets.length);\n        for (uint256 i = 0; i < _markets.length; i++) {\n            _markets[i] = buildDynamicMarketBundle(\n                AbstractMarketFactoryV3(_marketFactory),\n                _ammFactory,\n                _event.markets[i]\n            );\n        }\n\n        _bundle.id = _eventId;\n        _bundle.markets = _markets;\n        _bundle.status = _event.status;\n        _bundle.homeScore = _event.homeScore;\n        _bundle.awayScore = _event.awayScore;\n    }\n\n    // Starts from the end of the events list because newer events are more interesting.\n    // _offset is skipping all events, not just interesting events\n    function listOfInterestingEvents(\n        address _marketFactory,\n        uint256 _offset,\n        uint256 _total\n    ) internal view returns (uint256[] memory _interestingEventIds, uint256 _eventIndex) {\n        _interestingEventIds = new uint256[](_total);\n\n        uint256 _eventCount = Sport(_marketFactory).eventCount();\n\n        // No events so return nothing. (needed to avoid integer underflow below)\n        if (_eventCount == 0) {\n            return (new uint256[](0), 0);\n        }\n\n        uint256 _max = _eventCount;\n\n        // No remaining events so return nothing. (needed to avoid integer underflow below)\n        if (_offset > _max) {\n            return (new uint256[](0), 0);\n        }\n\n        uint256 _collectedEvents = 0;\n        _eventIndex = _max - _offset;\n        while (true) {\n            if (_collectedEvents >= _total) break;\n            if (_eventIndex == 0) break;\n\n            _eventIndex--; // starts out one too high, so this works\n\n            (Sport.SportsEvent memory _event, uint256 _eventId) =\n                Sport(_marketFactory).getSportsEventByIndex(_eventIndex);\n\n            if (isEventInteresting(_event, AbstractMarketFactoryV3(_marketFactory))) {\n                _interestingEventIds[_collectedEvents] = _eventId;\n                _collectedEvents++;\n            }\n        }\n\n        if (_total > _collectedEvents) {\n            assembly {\n                // shortens array\n                mstore(_interestingEventIds, _collectedEvents)\n            }\n        }\n    }\n\n    function isEventInteresting(Sport.SportsEvent memory _event, AbstractMarketFactoryV3 _marketFactory)\n        private\n        view\n        returns (bool)\n    {\n        for (uint256 i = 0; i < _event.markets.length; i++) {\n            uint256 _marketId = _event.markets[i];\n            if (openOrHasWinningShares(_marketFactory, _marketId)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\ncontract NBAFetcher is SportsFetcher {\n    constructor() Fetcher(\"NBA\", \"TBD\") {}\n}\n\ncontract MLBFetcher is SportsFetcher {\n    constructor() Fetcher(\"MLB\", \"TBD\") {}\n}\n\ncontract MMAFetcher is SportsFetcher {\n    constructor() Fetcher(\"MMA\", \"TBD\") {}\n}\n\ncontract NFLFetcher is SportsFetcher {\n    constructor() Fetcher(\"NFL\", \"TBD\") {}\n}\n\ncontract CryptoFetcher is Fetcher {\n    constructor() Fetcher(\"Crypto\", \"TBD\") {}\n\n    struct SpecificMarketFactoryBundle {\n        MarketFactoryBundle super;\n    }\n\n    struct SpecificStaticMarketBundle {\n        StaticMarketBundle super;\n        uint8 marketType;\n        uint256 coinIndex;\n        uint256 creationPrice;\n        uint256 resolutionTime;\n        // Dynamics\n        uint256 resolutionPrice;\n    }\n\n    struct SpecificDynamicMarketBundle {\n        DynamicMarketBundle super;\n        uint256 resolutionPrice;\n    }\n\n    function buildSpecificMarketFactoryBundle(address _marketFactory)\n        internal\n        view\n        returns (SpecificMarketFactoryBundle memory _bundle)\n    {\n        _bundle.super = buildMarketFactoryBundle(CryptoMarketFactory(_marketFactory));\n    }\n\n    function buildSpecificStaticMarketBundle(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _marketId\n    ) internal view returns (SpecificStaticMarketBundle memory _bundle) {\n        CryptoMarketFactory.MarketDetails memory _details =\n            CryptoMarketFactory(_marketFactory).getMarketDetails(_marketId);\n        _bundle.super = buildStaticMarketBundle(CryptoMarketFactory(_marketFactory), _ammFactory, _marketId);\n        _bundle.marketType = uint8(_details.marketType);\n        _bundle.creationPrice = _details.creationPrice;\n        _bundle.coinIndex = _details.coinIndex;\n        _bundle.resolutionPrice = _details.resolutionPrice;\n        _bundle.resolutionTime = _details.resolutionTime;\n    }\n\n    function buildSpecificDynamicMarketBundle(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _marketId\n    ) internal view returns (SpecificDynamicMarketBundle memory _bundle) {\n        CryptoMarketFactory.MarketDetails memory _details =\n            CryptoMarketFactory(_marketFactory).getMarketDetails(_marketId);\n        _bundle.super = buildDynamicMarketBundle(CryptoMarketFactory(_marketFactory), _ammFactory, _marketId);\n        _bundle.resolutionPrice = _details.resolutionPrice;\n    }\n\n    function fetchInitial(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _offset,\n        uint256 _total\n    )\n        public\n        view\n        returns (\n            SpecificMarketFactoryBundle memory _marketFactoryBundle,\n            SpecificStaticMarketBundle[] memory _marketBundles,\n            uint256 _lowestMarketIndex\n        )\n    {\n        _marketFactoryBundle = buildSpecificMarketFactoryBundle(_marketFactory);\n\n        uint256[] memory _marketIds;\n        (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\n\n        _total = _marketIds.length;\n        _marketBundles = new SpecificStaticMarketBundle[](_total);\n        for (uint256 i; i < _total; i++) {\n            _marketBundles[i] = buildSpecificStaticMarketBundle(_marketFactory, _ammFactory, _marketIds[i]);\n        }\n    }\n\n    function fetchDynamic(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _offset,\n        uint256 _total\n    ) public view returns (SpecificDynamicMarketBundle[] memory _bundles, uint256 _lowestMarketIndex) {\n        uint256[] memory _marketIds;\n        (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\n\n        _total = _marketIds.length;\n        _bundles = new SpecificDynamicMarketBundle[](_total);\n        for (uint256 i; i < _total; i++) {\n            _bundles[i] = buildSpecificDynamicMarketBundle(_marketFactory, _ammFactory, _marketIds[i]);\n        }\n    }\n\n    // Starts from the end of the markets list because newer markets are more interesting.\n    // _offset is skipping all markets, not just interesting markets\n    function listOfInterestingMarkets(\n        address _marketFactory,\n        uint256 _offset,\n        uint256 _total\n    ) internal view returns (uint256[] memory _interestingMarketIds, uint256 _marketId) {\n        _interestingMarketIds = new uint256[](_total);\n        uint256 _max = AbstractMarketFactoryV3(_marketFactory).marketCount() - 1;\n\n        // No markets so return nothing. (needed to prevent integer underflow below)\n        if (_max == 0 || _offset >= _max) {\n            return (new uint256[](0), 0);\n        }\n\n        // Starts at the end, less offset.\n        // Stops before the 0th market since that market is always fake.\n        uint256 _collectedMarkets = 0;\n        _marketId = _max - _offset;\n\n        while (true) {\n            if (openOrHasWinningShares(AbstractMarketFactoryV3(_marketFactory), _marketId)) {\n                _interestingMarketIds[_collectedMarkets] = _marketId;\n                _collectedMarkets++;\n            }\n\n            if (_collectedMarkets >= _total) break;\n            if (_marketId == 1) break; // skipping 0th market, which is fake\n            _marketId--; // starts out oone too high, so this works\n        }\n\n        if (_total > _collectedMarkets) {\n            assembly {\n                // shortens array\n                mstore(_interestingMarketIds, _collectedMarkets)\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/SafeMathInt256.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\n/**\n * @title SafeMathInt256\n * @dev Int256 math operations with safety checks that throw on error\n */\nlibrary SafeMathInt256 {\n    // Signed ints with n bits can range from -2**(n-1) to (2**(n-1) - 1)\n    int256 private constant INT256_MIN = -2**(255);\n    int256 private constant INT256_MAX = (2**(255) - 1);\n\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a * b;\n        require(a == 0 || c / a == b);\n        return c;\n    }\n\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        // No need to check for dividing by 0 -- Solidity automatically throws on division by 0\n        int256 c = a / b;\n        return c;\n    }\n\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        require(((a >= 0) && (b >= a - INT256_MAX)) || ((a < 0) && (b <= a - INT256_MIN)));\n        return a - b;\n    }\n\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        require(((a >= 0) && (b <= INT256_MAX - a)) || ((a < 0) && (b >= INT256_MIN - a)));\n        return a + b;\n    }\n\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        if (a <= b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        if (a >= b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    function abs(int256 a) internal pure returns (int256) {\n        if (a < 0) {\n            return -a;\n        }\n        return a;\n    }\n\n    function getInt256Min() internal pure returns (int256) {\n        return INT256_MIN;\n    }\n\n    function getInt256Max() internal pure returns (int256) {\n        return INT256_MAX;\n    }\n\n    // Float [fixed point] Operations\n    function fxpMul(\n        int256 a,\n        int256 b,\n        int256 base\n    ) internal pure returns (int256) {\n        return div(mul(a, b), base);\n    }\n\n    function fxpDiv(\n        int256 a,\n        int256 b,\n        int256 base\n    ) internal pure returns (int256) {\n        return div(mul(a, base), b);\n    }\n\n    function sqrt(int256 y) internal pure returns (int256 z) {\n        if (y > 3) {\n            int256 x = (y + 1) / 2;\n            z = y;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n"
    },
    "contracts/turbo/MMAMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"./FeePot.sol\";\nimport \"../libraries/SafeMathInt256.sol\";\nimport \"../libraries/Sport.sol\";\nimport \"../libraries/ResolveByFiat.sol\";\nimport \"../libraries/HasHeadToHeadMarket.sol\";\nimport \"../libraries/Versioned.sol\";\n\ncontract MMAMarketFactory is AbstractMarketFactoryV3, SportView, ResolvesByFiat, HasHeadToHeadMarket, Versioned {\n    using SafeMathUint256 for uint256;\n    using SafeMathInt256 for int256;\n\n    uint256 constant HeadToHead = 0;\n    string constant InvalidName = \"No Contest / Draw\";\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256[3] memory _fees,\n        address _protocol,\n        address _linkNode\n    )\n        AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol)\n        Versioned(\"v1.2.0\")\n        ManagedByLink(_linkNode)\n        HasHeadToHeadMarket(HeadToHead, InvalidName)\n    {}\n\n    function createEvent(\n        uint256 _eventId,\n        string memory _homeTeamName,\n        uint256 _homeTeamId,\n        string memory _awayTeamName,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256[2] memory _moneylines // [home,away]\n    ) public onlyLinkNode returns (uint256[] memory _marketIds) {\n        // Cannot create markets for an event twice.\n        require(sportsEvents[_eventId].status == SportsEventStatus.Unknown);\n\n        _marketIds = makeMarkets(_moneylines, _homeTeamName, _awayTeamName);\n        makeSportsEvent(\n            _eventId,\n            _marketIds,\n            build1Line(),\n            _startTimestamp,\n            _homeTeamId,\n            _awayTeamId,\n            _homeTeamName,\n            _awayTeamName\n        );\n    }\n\n    function makeMarkets(\n        int256[2] memory _moneylines,\n        string memory _homeTeamName,\n        string memory _awayTeamName\n    ) internal returns (uint256[] memory _marketIds) {\n        _marketIds = new uint256[](1);\n        _marketIds[HeadToHead] = makeHeadToHeadMarket(_moneylines, _homeTeamName, _awayTeamName);\n    }\n\n    function resolveValidEvent(SportsEvent memory _event, uint256 _whoWon) internal override {\n        resolveHeadToHeadMarket(_event.markets[HeadToHead], _whoWon);\n    }\n\n    function resolveHeadToHeadMarket(uint256 _marketId, uint256 _whoWon) internal {\n        uint256 _shareTokenIndex = calcHeadToHeadWinner(_whoWon);\n        endMarket(_marketId, _shareTokenIndex);\n    }\n\n    function calcHeadToHeadWinner(uint256 _whoWon) internal pure returns (uint256) {\n        if (WhoWonHome == _whoWon) {\n            return HeadToHeadHome;\n        } else if (WhoWonAway == _whoWon) {\n            return HeadToHeadAway;\n        } else {\n            return NoContest; // shouldn't happen here\n        }\n    }\n}\n"
    },
    "contracts/turbo/CryptoMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"./FeePot.sol\";\nimport \"../libraries/SafeMathInt256.sol\";\nimport \"@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol\";\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\nimport \"../libraries/Versioned.sol\";\nimport \"../libraries/ManagedByLink.sol\";\n\ncontract CryptoMarketFactory is AbstractMarketFactoryV3, CalculateLinesToBPoolOdds, Versioned, ManagedByLink {\n    using SafeMathUint256 for uint256;\n    using SafeMathInt256 for int256;\n\n    event CoinAdded(uint256 indexed id, string name);\n\n    event NewPrices(uint256 indexed nextResolutionTime, uint256[] markets, uint256[] prices);\n\n    struct Coin {\n        string name;\n        AggregatorV3Interface priceFeed;\n        uint256 price;\n        uint8 imprecision; // how many decimals to truncate\n        uint256[1] currentMarkets;\n    }\n    Coin[] public coins;\n\n    enum MarketType {\n        PriceUpDown // 0\n    }\n    enum PriceUpDownOutcome {\n        Above, // 0\n        NotAbove // 1\n    }\n    struct MarketDetails {\n        MarketType marketType;\n        uint256 coinIndex;\n        uint256 creationPrice;\n        uint256 resolutionPrice;\n        uint256 resolutionTime; // price at given time; this is that time\n    }\n    // MarketId => MarketDetails\n    mapping(uint256 => MarketDetails) internal marketDetails;\n\n    uint256 public nextResolutionTime;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256[3] memory _fees,\n        address _protocol,\n        address _linkNode\n    )\n        AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol)\n        Versioned(\"v1.2.0\")\n        ManagedByLink(_linkNode)\n    {\n        string memory _name = \"\";\n        coins.push(makeCoin(_name, AggregatorV3Interface(0), 0));\n    }\n\n    function getMarketDetails(uint256 _marketId) public view returns (MarketDetails memory) {\n        return marketDetails[_marketId];\n    }\n\n    // NOTE: Trusts the owner not to add a coin twice.\n    // Returns the coin index.\n    function addCoin(\n        string calldata _name,\n        AggregatorV3Interface _priceFeed,\n        uint8 _imprecision\n    ) external onlyOwner returns (uint256 _coinIndex) {\n        Coin memory _coin = makeCoin(_name, _priceFeed, _imprecision);\n        _coinIndex = coins.length;\n        coins.push(_coin);\n        emit CoinAdded(_coinIndex, _name);\n    }\n\n    function getCoin(uint256 _coinIndex) public view returns (Coin memory _coin) {\n        _coin = coins[_coinIndex];\n    }\n\n    function getCoins() public view returns (Coin[] memory _coins) {\n        _coins = new Coin[](coins.length);\n        // Skip first coin because it's always the zeroed-out fake coin.\n        for (uint256 i = 1; i < coins.length; i++) {\n            _coins[i] = coins[i];\n        }\n    }\n\n    // Iterates over all coins.\n    // If markets do not exist for coin, create them.\n    // Unless _nextResolutionTime is zero; then do not create new markets.\n    // If markets for coin exist and are ready to resolve, resolve them and create new markets.\n    // Else, error.\n    //\n    // Assume that _roundIds has a dummy value at index 0, and is 1 indexed like the\n    // coins array.\n    function createAndResolveMarkets(uint80[] calldata _roundIds, uint256 _nextResolutionTime) public onlyLinkNode {\n        // If market creation was stopped then it can be started again.\n        // If market creation wasn't stopped then you must wait for market end time to resolve.\n        require(block.timestamp >= nextResolutionTime, \"Must wait for market resolution\");\n        require(_roundIds.length == coins.length, \"Must specify one roundId for each coin\");\n\n        uint256 _resolutionTime = nextResolutionTime;\n        nextResolutionTime = _nextResolutionTime;\n\n        uint256[] memory _prices = new uint256[](coins.length - 1);\n        uint256[] memory _newMarketIds = new uint256[](coins.length - 1);\n        // Start at 1 to skip the fake Coin in the 0 index\n        for (uint256 i = 1; i < coins.length; i++) {\n            (_prices[i - 1], _newMarketIds[i - 1]) = createAndResolveMarketsForCoin(i, _resolutionTime, _roundIds[i]);\n        }\n\n        emit NewPrices(nextResolutionTime, _newMarketIds, _prices);\n    }\n\n    function createAndResolveMarketsForCoin(\n        uint256 _coinIndex,\n        uint256 _resolutionTime,\n        uint80 _roundId\n    ) internal returns (uint256 _price, uint256 _newMarketId) {\n        Coin memory _coin = coins[_coinIndex];\n        (uint256 _fullPrice, uint256 _newPrice) = getPrice(_coin, _roundId, _resolutionTime);\n\n        // resolve markets\n        if (_coin.currentMarkets[uint256(MarketType.PriceUpDown)] != 0) {\n            resolvePriceUpDownMarket(_coin, _newPrice, _fullPrice);\n        }\n\n        // update price only AFTER resolution\n        coins[_coinIndex].price = _newPrice;\n\n        // link node sets nextResolutionTime to zero to signify \"do not create markets after resolution\"\n        if (nextResolutionTime == 0) {\n            return (0, 0);\n        }\n\n        // create markets\n        _newMarketId = createPriceUpDownMarket(_coinIndex, linkNode, _newPrice);\n        coins[_coinIndex].currentMarkets[uint256(MarketType.PriceUpDown)] = _newMarketId;\n\n        return (_newPrice, _newMarketId);\n    }\n\n    function resolvePriceUpDownMarket(\n        Coin memory _coin,\n        uint256 _newPrice,\n        uint256 _fullPrice\n    ) internal {\n        uint256 _marketId = _coin.currentMarkets[uint256(MarketType.PriceUpDown)];\n\n        uint256 _winningOutcome;\n        if (_newPrice > _coin.price) {\n            _winningOutcome = uint256(PriceUpDownOutcome.Above);\n        } else {\n            _winningOutcome = uint256(PriceUpDownOutcome.NotAbove);\n        }\n\n        endMarket(_marketId, _winningOutcome);\n        marketDetails[_marketId].resolutionPrice = _fullPrice;\n    }\n\n    function createPriceUpDownMarket(\n        uint256 _coinIndex,\n        address _creator,\n        uint256 _newPrice\n    ) internal returns (uint256 _id) {\n        string[] memory _outcomes = new string[](2);\n        _outcomes[uint256(PriceUpDownOutcome.Above)] = \"Above\";\n        _outcomes[uint256(PriceUpDownOutcome.NotAbove)] = \"Not Above\";\n\n        _id = startMarket(_creator, _outcomes, evenOdds(false, 2), true);\n        marketDetails[_id] = MarketDetails(MarketType.PriceUpDown, _coinIndex, _newPrice, 0, nextResolutionTime);\n    }\n\n    // Returns the price based on a few factors.\n    // If _roundId is zero then it returns the latest price.\n    // Else, it returns the price for that round,\n    //       but errors if that isn't the first round after the resolution time.\n    // The price is then altered to match the desired precision.\n    function getPrice(\n        Coin memory _coin,\n        uint80 _roundId,\n        uint256 _resolutionTime\n    ) internal view returns (uint256 _fullPrice, uint256 _truncatedPrice) {\n        if (_roundId == 0) {\n            (, int256 _rawPrice, , , ) = _coin.priceFeed.latestRoundData();\n            require(_rawPrice >= 0, \"Price from feed is negative\");\n            _fullPrice = uint256(_rawPrice);\n        } else {\n            (, int256 _rawPrice, , uint256 updatedAt, ) = _coin.priceFeed.getRoundData(_roundId);\n            require(_rawPrice >= 0, \"Price from feed is negative\");\n            require(updatedAt >= _resolutionTime, \"Price hasn't been updated yet\");\n\n            // if resolution time is zero then market creation was stopped, so the previous round doesn't matter\n            if (_resolutionTime != 0) {\n                (, , , uint256 _previousRoundTime, ) = _coin.priceFeed.getRoundData(previousRound(_roundId));\n                require(_previousRoundTime < _resolutionTime, \"Must use first round after resolution time\");\n            }\n\n            _fullPrice = uint256(_rawPrice);\n        }\n\n        // The precision is how many decimals the price has. Zero is dollars, 2 includes cents, 3 is tenths of a cent, etc.\n        // Our resolution rules want a certain precision. Like BTC is to the dollar and MATIC is to the cent.\n        // If somehow the decimals are larger than the desired precision then add zeroes to the end to meet the precision.\n        // This does not change the resolution outcome but does guard against decimals() changing and therefore altering the basis.\n\n        uint8 _precision = _coin.priceFeed.decimals(); // probably constant but that isn't guaranteed, so query each time\n        if (_precision > _coin.imprecision) {\n            uint8 _truncate = _precision - _coin.imprecision;\n            _truncatedPrice = _fullPrice / (10**_truncate);\n        } else if (_precision < _coin.imprecision) {\n            uint8 _greaten = _coin.imprecision - _precision;\n            _truncatedPrice = _fullPrice * (10**_greaten);\n        } else {\n            _truncatedPrice = _fullPrice;\n        }\n\n        // Round up because that cleanly fits Above/Not-Above.\n        if (_truncatedPrice != _fullPrice) {\n            _truncatedPrice += 1;\n        }\n    }\n\n    function makeCoin(\n        string memory _name,\n        AggregatorV3Interface _priceFeed,\n        uint8 _imprecision\n    ) internal pure returns (Coin memory _coin) {\n        uint256[1] memory _currentMarkets = [uint256(0)];\n        _coin = Coin(_name, _priceFeed, 0, _imprecision, _currentMarkets);\n    }\n\n    // The roundId is the encoding of two parts: the phase and the phase-specific round id.\n    // To find the previous roundId:\n    // 1. extract the phase and phase-specific round (I call these _phaseId and _roundId)\n    // 2. decrement the phase-specific round\n    // 3. re-encode the phase and phase-specific round.\n    uint256 private constant PHASE_OFFSET = 64;\n\n    function previousRound(uint80 _fullRoundId) internal pure returns (uint80) {\n        uint256 _phaseId = uint256(uint16(_fullRoundId >> PHASE_OFFSET));\n        uint64 _roundId = uint64(_fullRoundId) - 1;\n        return uint80((_phaseId << PHASE_OFFSET) | _roundId);\n    }\n}\n"
    },
    "contracts/turbo/NBAMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"./FeePot.sol\";\nimport \"../libraries/SafeMathInt256.sol\";\nimport \"../libraries/Sport.sol\";\nimport \"../libraries/HasHeadToHeadMarket.sol\";\nimport \"../libraries/HasSpreadMarket.sol\";\nimport \"../libraries/HasOverUnderMarket.sol\";\nimport \"../libraries/ResolveByScore.sol\";\nimport \"../libraries/Versioned.sol\";\n\ncontract NBAMarketFactory is\n    AbstractMarketFactoryV3,\n    SportView,\n    HasHeadToHeadMarket,\n    HasSpreadMarket,\n    HasOverUnderMarket,\n    ResolvesByScore,\n    Versioned\n{\n    using SafeMathUint256 for uint256;\n    using SafeMathInt256 for int256;\n\n    uint256 constant HeadToHead = 0;\n    uint256 constant Spread = 1;\n    uint256 constant OverUnder = 2;\n    string constant InvalidName = \"No Contest\";\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256[3] memory _fees,\n        address _protocol,\n        address _linkNode\n    )\n        AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol)\n        Versioned(\"1.2.0\")\n        ManagedByLink(_linkNode)\n        HasHeadToHeadMarket(HeadToHead, InvalidName)\n        HasSpreadMarket(Spread, InvalidName)\n        HasOverUnderMarket(OverUnder, InvalidName)\n    {}\n\n    function createEvent(\n        uint256 _eventId,\n        string memory _homeTeamName,\n        uint256 _homeTeamId,\n        string memory _awayTeamName,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256 _homeSpread,\n        int256 _totalScore,\n        int256[2] memory _moneylines // [home,away]\n    ) public onlyLinkNode returns (uint256[] memory _marketIds) {\n        // Cannot create markets for an event twice.\n        require(sportsEvents[_eventId].status == SportsEventStatus.Unknown, \"event exists\");\n\n        _marketIds = makeMarkets(_moneylines, _homeTeamName, _awayTeamName);\n        makeSportsEvent(\n            _eventId,\n            _marketIds,\n            build3Lines(_homeSpread, _totalScore),\n            _startTimestamp,\n            _homeTeamId,\n            _awayTeamId,\n            _homeTeamName,\n            _awayTeamName\n        );\n    }\n\n    function makeMarkets(\n        int256[2] memory _moneylines,\n        string memory _homeTeamName,\n        string memory _awayTeamName\n    ) internal returns (uint256[] memory _marketIds) {\n        _marketIds = new uint256[](3);\n\n        _marketIds[HeadToHead] = makeHeadToHeadMarket(_moneylines, _homeTeamName, _awayTeamName);\n        _marketIds[Spread] = makeSpreadMarket(_homeTeamName, _awayTeamName);\n        _marketIds[OverUnder] = makeOverUnderMarket();\n    }\n\n    function resolveValidEvent(\n        SportsEvent memory _event,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal override {\n        resolveHeadToHeadMarket(_event.markets[HeadToHead], _homeScore, _awayScore);\n        resolveSpreadMarket(_event.markets[Spread], _event.lines[Spread], _homeScore, _awayScore);\n        resolveOverUnderMarket(_event.markets[OverUnder], _event.lines[Spread], _homeScore, _awayScore);\n    }\n}\n"
    },
    "contracts/libraries/Sport.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../turbo/AbstractMarketFactoryV3.sol\";\nimport \"./LineHelper.sol\";\n\nabstract contract Sport is AbstractMarketFactoryV3, LineHelper {\n    event SportsEventCreated(\n        uint256 id,\n        uint256[] markets,\n        int256[] lines,\n        uint256 homeTeamId,\n        uint256 awayTeamId,\n        string homeTeamName,\n        string awayTeamName,\n        uint256 estimatedStartTime\n    );\n\n    enum SportsEventStatus {Unknown, Scheduled, Final, Postponed, Canceled}\n    struct SportsEvent {\n        SportsEventStatus status;\n        uint256[] markets;\n        int256[] lines;\n        uint256 estimatedStartTime;\n        uint256 homeTeamId;\n        uint256 awayTeamId;\n        string homeTeamName;\n        string awayTeamName;\n        uint256 homeScore;\n        uint256 awayScore;\n    }\n    // EventId => EventDetails\n    mapping(uint256 => SportsEvent) public sportsEvents;\n    uint256[] public listOfSportsEvents;\n\n    uint256 constant NoContest = 0;\n\n    function eventCount() public view returns (uint256) {\n        return listOfSportsEvents.length;\n    }\n\n    function getSportsEvent(uint256 _eventId) public view returns (SportsEvent memory) {\n        return sportsEvents[_eventId];\n    }\n\n    function getSportsEventByIndex(uint256 _index) public view returns (SportsEvent memory _event, uint256 _eventId) {\n        _eventId = listOfSportsEvents[_index];\n        _event = getSportsEvent(_eventId);\n    }\n\n    function makeSportsEvent(\n        uint256 _eventId,\n        uint256[] memory _markets,\n        int256[] memory _lines,\n        uint256 _estimatedStartTime,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        string memory _homeTeamName,\n        string memory _awayTeamName\n    ) internal {\n        listOfSportsEvents.push(_eventId);\n        sportsEvents[_eventId].status = SportsEventStatus.Scheduled; // new events must be Scheduled\n        sportsEvents[_eventId].markets = _markets;\n        sportsEvents[_eventId].lines = _lines;\n        sportsEvents[_eventId].estimatedStartTime = _estimatedStartTime;\n        sportsEvents[_eventId].homeTeamId = _homeTeamId;\n        sportsEvents[_eventId].awayTeamId = _awayTeamId;\n        sportsEvents[_eventId].homeTeamName = _homeTeamName;\n        sportsEvents[_eventId].awayTeamName = _awayTeamName;\n        // homeScore and awayScore default to zero, which is correct for new events\n\n        emit SportsEventCreated(\n            _eventId,\n            _markets,\n            _lines,\n            _homeTeamId,\n            _awayTeamId,\n            _homeTeamName,\n            _awayTeamName,\n            _estimatedStartTime\n        );\n    }\n\n    uint256 constant WhoWonUnknown = 0;\n    uint256 constant WhoWonHome = 1;\n    uint256 constant WhoWonAway = 2;\n    uint256 constant WhoWonDraw = 3;\n\n    function eventIsNoContest(\n        SportsEvent memory _event,\n        SportsEventStatus _eventStatus,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _whoWon // pass in WhoWonUnknown if using a scoring sport\n    ) internal pure returns (bool) {\n        bool _draw = _whoWon == WhoWonDraw;\n        bool _notFinal = _eventStatus != SportsEventStatus.Final;\n        bool _unstableHomeTeamId = _event.homeTeamId != _homeTeamId;\n        bool _unstableAwayTeamId = _event.awayTeamId != _awayTeamId;\n        return _draw || _notFinal || _unstableHomeTeamId || _unstableAwayTeamId;\n    }\n\n    function resolveInvalidEvent(uint256 _eventId) internal {\n        uint256[] memory _marketIds = sportsEvents[_eventId].markets;\n        for (uint256 i = 0; i < _marketIds.length; i++) {\n            uint256 _marketId = _marketIds[i];\n            if (_marketId == 0) continue; // skip non-created markets\n            endMarket(_marketId, NoContest);\n        }\n    }\n\n    // TODO is this needed? getSportsEvent should do the same\n    function getEventMarkets(uint256 _eventId) public view returns (uint256[] memory _markets) {\n        uint256[] storage _original = sportsEvents[_eventId].markets;\n        uint256 _len = _original.length;\n        _markets = new uint256[](_len);\n        for (uint256 i = 0; i < _len; i++) {\n            _markets[i] = _original[i];\n        }\n    }\n}\n\n// TODO change this to work with the Fetcher contracts and use it there, since it's offchain-read-only.\nabstract contract SportView is Sport {\n    // Only usable off-chain. Gas cost can easily eclipse block limit.\n    // Lists all events that could be resolved with a call to resolveEvent.\n    // Not all will be resolvable because this does not ensure the game ended.\n    function listResolvableEvents() external view returns (uint256[] memory) {\n        uint256 _totalResolvable = countResolvableEvents();\n        uint256[] memory _resolvableEvents = new uint256[](_totalResolvable);\n\n        uint256 n = 0;\n        for (uint256 i = 0; i < listOfSportsEvents.length; i++) {\n            if (n > _totalResolvable) break;\n            uint256 _eventId = listOfSportsEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _resolvableEvents[n] = _eventId;\n                n++;\n            }\n        }\n\n        return _resolvableEvents;\n    }\n\n    function countResolvableEvents() internal view returns (uint256) {\n        uint256 _totalResolvable = 0;\n        for (uint256 i = 0; i < listOfSportsEvents.length; i++) {\n            uint256 _eventId = listOfSportsEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _totalResolvable++;\n            }\n        }\n        return _totalResolvable;\n    }\n\n    // Returns true if a call to resolveEvent is potentially useful.\n    function isEventResolvable(uint256 _eventId) internal view returns (bool) {\n        uint256[] memory _markets = getEventMarkets(_eventId);\n\n        bool _unresolved = false; // default because non-existing markets aren't resolvable\n        for (uint256 i = 0; i < _markets.length; i++) {\n            uint256 _marketId = _markets[i];\n            if (_marketId != 0 && !isMarketResolved(_marketId)) {\n                _unresolved = true;\n                break;\n            }\n        }\n\n        return _unresolved;\n    }\n}\n"
    },
    "contracts/libraries/ResolveByFiat.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./Sport.sol\";\nimport \"./ManagedByLink.sol\";\n\nabstract contract ResolvesByFiat is Sport, ManagedByLink {\n    function resolveEvent(\n        uint256 _eventId,\n        SportsEventStatus _eventStatus,\n        uint256 _homeTeamId, // for verifying team stability\n        uint256 _awayTeamId, // for verifying team stability\n        uint256 _whoWon\n    ) public onlyLinkNode {\n        SportsEvent storage _event = sportsEvents[_eventId];\n\n        require(_event.status == SportsEventStatus.Scheduled);\n        require(SportsEventStatus(_eventStatus) != SportsEventStatus.Scheduled);\n\n        if (eventIsNoContest(_event, _eventStatus, _homeTeamId, _awayTeamId, _whoWon)) {\n            resolveInvalidEvent(_eventId);\n        } else {\n            resolveValidEvent(_event, _whoWon);\n        }\n\n        sportsEvents[_eventId].status = _eventStatus;\n    }\n\n    function resolveValidEvent(SportsEvent memory _event, uint256 _whoWon) internal virtual;\n}\n"
    },
    "contracts/libraries/HasHeadToHeadMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../turbo/AbstractMarketFactoryV3.sol\";\nimport \"./Sport.sol\";\nimport \"./CalculateLinesToBPoolOdds.sol\";\nimport \"./TokenNamesFromTeams.sol\";\n\nabstract contract HasHeadToHeadMarket is\n    AbstractMarketFactoryV3,\n    Sport,\n    CalculateLinesToBPoolOdds,\n    TokenNamesFromTeams\n{\n    using SafeMathUint256 for uint256;\n    using SafeMathInt256 for int256;\n\n    uint256 private headToHeadMarketType;\n    string private noContestName;\n\n    uint256 constant HeadToHeadAway = 1;\n    uint256 constant HeadToHeadHome = 2;\n\n    constructor(uint256 _marketType, string memory _noContestName) {\n        headToHeadMarketType = _marketType;\n        noContestName = _noContestName;\n    }\n\n    function makeHeadToHeadMarket(\n        int256[2] memory _moneylines,\n        string memory _homeTeamName,\n        string memory _awayTeamName\n    ) internal returns (uint256) {\n        // moneylines is [home,away] but the outcomes are listed [NC,away,home] so they must be reversed\n        return\n            makeSportsMarket(\n                noContestName,\n                _homeTeamName,\n                _awayTeamName,\n                oddsFromLines(_moneylines[1], _moneylines[0])\n            );\n    }\n\n    function resolveHeadToHeadMarket(\n        uint256 _marketId,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        uint256 _shareTokenIndex = calcHeadToHeadWinner(_homeScore, _awayScore);\n        endMarket(_marketId, _shareTokenIndex);\n    }\n\n    function calcHeadToHeadWinner(uint256 _homeScore, uint256 _awayScore) private pure returns (uint256) {\n        if (_homeScore > _awayScore) {\n            return HeadToHeadHome;\n        } else if (_homeScore < _awayScore) {\n            return HeadToHeadAway;\n        } else {\n            return NoContest;\n        }\n    }\n}\n"
    },
    "contracts/libraries/Versioned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nabstract contract Versioned {\n    string internal version;\n\n    constructor(string memory _version) {\n        version = _version;\n    }\n\n    function getVersion() public view returns (string memory) {\n        return version;\n    }\n}\n"
    },
    "contracts/libraries/LineHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nabstract contract LineHelper {\n    function build1Line() internal pure returns (int256[] memory _lines) {\n        _lines = new int256[](1);\n    }\n\n    function build3Lines(int256 _homeSpread, int256 _totalScore) internal pure returns (int256[] memory _lines) {\n        _lines = new int256[](3);\n        // 0 is the Head-to-Head market, which has no lines\n        _lines[1] = addHalfPoint(_homeSpread);\n        _lines[2] = addHalfPoint(_totalScore);\n    }\n\n    function addHalfPoint(int256 _line) private pure returns (int256) {\n        // The line is a quantity of tenths. So 55 is 5.5 and -6 is -60.\n        // If the line is a whole number then make it a half point more extreme, to eliminate ties.\n        // So 50 becomes 55, -60 becomes -65, and 0 becomes 5.\n        if (_line >= 0 && _line % 10 == 0) {\n            return _line + 5;\n        } else if (_line < 0 && (-_line) % 10 == 0) {\n            return _line - 5;\n        } else {\n            return _line;\n        }\n    }\n}\n"
    },
    "contracts/libraries/ManagedByLink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"./Ownable.sol\";\n\nabstract contract ManagedByLink is Ownable {\n    event LinkNodeChanged(address newLinkNode);\n\n    address public linkNode;\n\n    constructor(address _linkNode) {\n        linkNode = _linkNode;\n    }\n\n    function setLinkNode(address _newLinkNode) external onlyOwner {\n        linkNode = _newLinkNode;\n        emit LinkNodeChanged(_newLinkNode);\n    }\n\n    modifier onlyLinkNode() {\n        require(msg.sender == linkNode);\n        _;\n    }\n}\n"
    },
    "contracts/libraries/CalculateLinesToBPoolOdds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"./SafeMathUint256.sol\";\nimport \"./SafeMathInt256.sol\";\n\nabstract contract CalculateLinesToBPoolOdds {\n    using SafeMathUint256 for uint256;\n    using SafeMathInt256 for int256;\n\n    uint256 constant MAX_BPOOL_WEIGHT = 50e18;\n\n    function ratioOdds(uint256[] memory _proportions) internal pure returns (uint256[] memory _odds) {\n        uint256 _total = sum(_proportions);\n\n        _odds = new uint256[](_proportions.length);\n        for (uint256 i = 0; i < _proportions.length; i++) {\n            _odds[i] = (MAX_BPOOL_WEIGHT).mul(_proportions[i]).div(_total);\n            require(_odds[i] >= 1e18, \"min outcome weight is 2%\");\n        }\n    }\n\n    function sum(uint256[] memory _numbers) private pure returns (uint256 _sum) {\n        for (uint256 i = 0; i < _numbers.length; i++) {\n            _sum += _numbers[i];\n        }\n    }\n\n    function evenOdds(bool _invalid, uint256 _outcomes) internal pure returns (uint256[] memory _odds) {\n        uint256 _size = _outcomes + (_invalid ? 1 : 0);\n        _odds = new uint256[](_size);\n\n        if (_invalid) _odds[0] = 1e18; // 2%\n\n        uint256 _each = (_invalid ? 49e18 : 50e18) / _outcomes;\n        for (uint256 i = _invalid ? 1 : 0; i < _size; i++) {\n            _odds[i] = _each;\n        }\n    }\n\n    function oddsFromLines(int256 _moneyline1, int256 _moneyline2) internal pure returns (uint256[] memory _odds) {\n        uint256 _odds1 = __calcLineToOdds(_moneyline1);\n        uint256 _odds2 = __calcLineToOdds(_moneyline2);\n\n        uint256 _total = _odds1 + _odds2;\n\n        _odds1 = uint256(49e18).mul(_odds1).div(_total);\n        _odds2 = uint256(49e18).mul(_odds2).div(_total);\n\n        // Moneyline odds are too skewed: would have under 2% odds.\n        require(_odds1 >= 1e18);\n        require(_odds2 >= 1e18);\n\n        _odds = new uint256[](3);\n        _odds[0] = 1e18; // Invalid, 2%\n        _odds[1] = _odds1;\n        _odds[2] = _odds2;\n    }\n\n    function __calcLineToOdds(int256 _line) internal pure returns (uint256) {\n        if (_line < 0) {\n            // favored\n            uint256 _posLine = uint256(-_line);\n            return _posLine.mul(49e18).div(_posLine.add(100)); // 49e18 * _line / (_line + 100)\n        } else {\n            // underdog\n            return uint256(4900e18).div(uint256(_line).add(100)); // 49e18 * 100 / (_line + 100)\n        }\n    }\n}\n"
    },
    "contracts/libraries/TokenNamesFromTeams.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./Sport.sol\";\n\nabstract contract TokenNamesFromTeams is Sport {\n    uint256 constant Away = 1;\n    uint256 constant Home = 2;\n\n    function makeSportsMarket(\n        string memory _noContestName,\n        string memory _homeTeamName,\n        string memory _awayTeamName,\n        uint256[] memory _odds\n    ) internal returns (uint256) {\n        string[] memory _outcomeNames = makeOutcomeNames(_noContestName, _homeTeamName, _awayTeamName);\n        return startMarket(msg.sender, _outcomeNames, _odds, true);\n    }\n\n    function makeOutcomeNames(\n        string memory _noContestName,\n        string memory _homeTeamName,\n        string memory _awayTeamName\n    ) private pure returns (string[] memory _names) {\n        _names = new string[](3);\n        _names[NoContest] = _noContestName;\n        _names[Away] = _awayTeamName;\n        _names[Home] = _homeTeamName;\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals()\n    external\n    view\n    returns (\n      uint8\n    );\n\n  function description()\n    external\n    view\n    returns (\n      string memory\n    );\n\n  function version()\n    external\n    view\n    returns (\n      uint256\n    );\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
    },
    "contracts/libraries/HasSpreadMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../turbo/AbstractMarketFactoryV3.sol\";\nimport \"./Sport.sol\";\nimport \"./CalculateLinesToBPoolOdds.sol\";\nimport \"./TokenNamesFromTeams.sol\";\n\nabstract contract HasSpreadMarket is AbstractMarketFactoryV3, Sport, CalculateLinesToBPoolOdds, TokenNamesFromTeams {\n    using SafeMathUint256 for uint256;\n    using SafeMathInt256 for int256;\n\n    uint256 private spreadMarketType;\n    string private noContestName;\n\n    uint256 constant SpreadAway = 1;\n    uint256 constant SpreadHome = 2;\n\n    constructor(uint256 _marketType, string memory _noContestName) {\n        spreadMarketType = _marketType;\n        noContestName = _noContestName;\n    }\n\n    function makeSpreadMarket(string memory _homeTeamName, string memory _awayTeamName) internal returns (uint256) {\n        return makeSportsMarket(noContestName, _homeTeamName, _awayTeamName, evenOdds(true, 2));\n    }\n\n    function resolveSpreadMarket(\n        uint256 _marketId,\n        int256 _line,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        uint256 _shareTokenIndex = calcSpreadWinner(_homeScore, _awayScore, _line);\n        endMarket(_marketId, _shareTokenIndex);\n    }\n\n    function calcSpreadWinner(\n        uint256 _homeScore,\n        uint256 _awayScore,\n        int256 _targetSpread\n    ) internal pure returns (uint256) {\n        int256 _actualSpread = int256(_homeScore).sub(int256(_awayScore));\n\n        if (_actualSpread > _targetSpread) {\n            return SpreadHome; // home spread greater\n        } else if (_actualSpread < _targetSpread) {\n            return SpreadAway; // away spread lesser\n        } else {\n            // draw / tie; some sports eliminate this with half-points\n            return NoContest;\n        }\n    }\n}\n"
    },
    "contracts/libraries/HasOverUnderMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../turbo/AbstractMarketFactoryV3.sol\";\nimport \"./Sport.sol\";\nimport \"./CalculateLinesToBPoolOdds.sol\";\n\nabstract contract HasOverUnderMarket is AbstractMarketFactoryV3, Sport, CalculateLinesToBPoolOdds {\n    using SafeMathUint256 for uint256;\n    using SafeMathInt256 for int256;\n\n    uint256 private overUnderMarketType;\n    string private noContestName;\n\n    uint256 constant Over = 1;\n    uint256 constant Under = 2;\n\n    constructor(uint256 _marketType, string memory _noContestName) {\n        overUnderMarketType = _marketType;\n        noContestName = _noContestName;\n    }\n\n    function makeOverUnderMarket() internal returns (uint256) {\n        string[] memory _outcomeNames = makeOutcomeNames(noContestName);\n        return startMarket(msg.sender, _outcomeNames, evenOdds(true, 2), true);\n    }\n\n    function resolveOverUnderMarket(\n        uint256 _marketId,\n        int256 _line,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        uint256 _shareTokenIndex = calcOverUnderWinner(_homeScore, _awayScore, _line);\n        endMarket(_marketId, _shareTokenIndex);\n    }\n\n    function calcOverUnderWinner(\n        uint256 _homeScore,\n        uint256 _awayScore,\n        int256 _targetTotal\n    ) internal pure returns (uint256) {\n        int256 _actualTotal = int256(_homeScore).add(int256(_awayScore));\n\n        if (_actualTotal > _targetTotal) {\n            return Over; // total score above than line\n        } else if (_actualTotal < _targetTotal) {\n            return Under; // total score below line\n        } else {\n            return NoContest; // draw / tie; some sports eliminate this with half-points\n        }\n    }\n\n    function makeOutcomeNames(string memory _noContestName) private pure returns (string[] memory _names) {\n        _names = new string[](3);\n        _names[NoContest] = _noContestName;\n        _names[Over] = \"Over\";\n        _names[Under] = \"Under\";\n    }\n}\n"
    },
    "contracts/libraries/ResolveByScore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./Sport.sol\";\nimport \"./ManagedByLink.sol\";\n\nabstract contract ResolvesByScore is Sport, ManagedByLink {\n    function resolveEvent(\n        uint256 _eventId,\n        SportsEventStatus _eventStatus,\n        uint256 _homeTeamId, // for verifying team stability\n        uint256 _awayTeamId, // for verifying team stability\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) public onlyLinkNode {\n        SportsEvent storage _event = sportsEvents[_eventId];\n\n        require(_event.status == SportsEventStatus.Scheduled);\n        require(SportsEventStatus(_eventStatus) != SportsEventStatus.Scheduled);\n\n        if (eventIsNoContest(_event, _eventStatus, _homeTeamId, _awayTeamId, WhoWonUnknown)) {\n            resolveInvalidEvent(_eventId);\n        } else {\n            resolveValidEvent(_event, _homeScore, _awayScore);\n        }\n\n        sportsEvents[_eventId].status = _eventStatus;\n    }\n\n    function resolveValidEvent(\n        SportsEvent memory _event,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal virtual;\n}\n"
    },
    "contracts/turbo/GroupFetcher.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./Fetcher.sol\";\nimport \"./Grouped.sol\";\n\nabstract contract GroupFetcher is Fetcher {\n    struct SpecificMarketFactoryBundle {\n        MarketFactoryBundle super;\n    }\n\n    struct StaticGroupBundle {\n        uint256 id;\n        string name;\n        StaticMarketBundle[] markets;\n        string[] marketNames;\n        StaticMarketBundle invalidMarket;\n        string invalidMarketName;\n        uint256 endTime;\n        string category;\n        // Dynamics\n        Grouped.GroupStatus status;\n    }\n\n    struct DynamicGroupBundle {\n        uint256 id;\n        Grouped.GroupStatus status;\n        DynamicMarketBundle[] markets;\n        DynamicMarketBundle invalidMarket;\n    }\n\n    function buildSpecificMarketFactoryBundle(address _marketFactory)\n        internal\n        view\n        returns (SpecificMarketFactoryBundle memory _bundle)\n    {\n        _bundle.super = buildMarketFactoryBundle(AbstractMarketFactoryV3(_marketFactory));\n    }\n\n    function fetchInitial(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _offset,\n        uint256 _total\n    )\n        public\n        view\n        returns (\n            SpecificMarketFactoryBundle memory _marketFactoryBundle,\n            StaticGroupBundle[] memory _groupBundles,\n            uint256 _lowestGroupIndex\n        )\n    {\n        _marketFactoryBundle = buildSpecificMarketFactoryBundle(_marketFactory);\n        (_groupBundles, _lowestGroupIndex) = buildStaticGroupBundles(_marketFactory, _ammFactory, _offset, _total);\n    }\n\n    function fetchDynamic(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _offset,\n        uint256 _total\n    ) public view returns (DynamicGroupBundle[] memory _bundles, uint256 _lowestGroupIndex) {\n        (_bundles, _lowestGroupIndex) = buildDynamicGroupBundles(_marketFactory, _ammFactory, _offset, _total);\n    }\n\n    function buildStaticGroupBundles(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _offset,\n        uint256 _total\n    ) internal view returns (StaticGroupBundle[] memory _bundles, uint256 _lowestGroupIndex) {\n        uint256[] memory _groupIds;\n        (_groupIds, _lowestGroupIndex) = listOfInterestingGroups(_marketFactory, _offset, _total);\n\n        _total = _groupIds.length;\n        _bundles = new StaticGroupBundle[](_total);\n        for (uint256 i; i < _total; i++) {\n            _bundles[i] = buildStaticGroupBundle(_marketFactory, _ammFactory, _groupIds[i]);\n        }\n    }\n\n    function buildDynamicGroupBundles(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _offset,\n        uint256 _total\n    ) internal view returns (DynamicGroupBundle[] memory _bundles, uint256 _lowestGroupIndex) {\n        uint256[] memory _groupIds;\n        (_groupIds, _lowestGroupIndex) = listOfInterestingGroups(_marketFactory, _offset, _total);\n\n        _total = _groupIds.length;\n        _bundles = new DynamicGroupBundle[](_total);\n        for (uint256 i; i < _total; i++) {\n            _bundles[i] = buildDynamicGroupBundle(_marketFactory, _ammFactory, _groupIds[i]);\n        }\n    }\n\n    function buildStaticGroupBundle(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _groupId\n    ) public view returns (StaticGroupBundle memory _bundle) {\n        Grouped.MarketGroup memory _group = Grouped(_marketFactory).getGroup(_groupId);\n\n        StaticMarketBundle[] memory _markets = new StaticMarketBundle[](_group.markets.length);\n        for (uint256 i = 0; i < _markets.length; i++) {\n            _markets[i] = buildStaticMarketBundle(\n                AbstractMarketFactoryV3(_marketFactory),\n                _ammFactory,\n                _group.markets[i]\n            );\n        }\n\n        _bundle.id = _groupId;\n        _bundle.name = _group.name;\n        _bundle.status = _group.status;\n        _bundle.markets = _markets;\n        _bundle.endTime = _group.endTime;\n        _bundle.invalidMarket = buildStaticMarketBundle(\n            AbstractMarketFactoryV3(_marketFactory),\n            _ammFactory,\n            _group.invalidMarket\n        );\n        _bundle.invalidMarketName = _group.invalidMarketName;\n        _bundle.marketNames = _group.marketNames;\n        _bundle.category = _group.category;\n    }\n\n    function buildDynamicGroupBundle(\n        address _marketFactory,\n        AMMFactory _ammFactory,\n        uint256 _groupId\n    ) public view returns (DynamicGroupBundle memory _bundle) {\n        Grouped.MarketGroup memory _group = Grouped(_marketFactory).getGroup(_groupId);\n\n        DynamicMarketBundle[] memory _markets = new DynamicMarketBundle[](_group.markets.length);\n        for (uint256 i = 0; i < _markets.length; i++) {\n            _markets[i] = buildDynamicMarketBundle(\n                AbstractMarketFactoryV3(_marketFactory),\n                _ammFactory,\n                _group.markets[i]\n            );\n        }\n\n        _bundle.id = _groupId;\n        _bundle.markets = _markets;\n        _bundle.invalidMarket = buildDynamicMarketBundle(\n            AbstractMarketFactoryV3(_marketFactory),\n            _ammFactory,\n            _group.invalidMarket\n        );\n        _bundle.status = _group.status;\n    }\n\n    // Starts from the end of the groups list because newer groups are more interesting.\n    // _offset is skipping all groups, not just interesting groups\n    function listOfInterestingGroups(\n        address _marketFactory,\n        uint256 _offset,\n        uint256 _total\n    ) internal view returns (uint256[] memory _interestingGroupIds, uint256 _groupIndex) {\n        _interestingGroupIds = new uint256[](_total);\n\n        uint256 _groupCount = Grouped(_marketFactory).groupCount();\n\n        // No groups so return nothing. (needed to avoid integer underflow below)\n        if (_groupCount == 0) {\n            return (new uint256[](0), 0);\n        }\n\n        uint256 _max = _groupCount;\n\n        // No remaining groups so return nothing. (needed to avoid integer underflow below)\n        if (_offset > _max) {\n            return (new uint256[](0), 0);\n        }\n\n        uint256 _collectedGroups = 0;\n        _groupIndex = _max - _offset;\n        while (true) {\n            if (_collectedGroups >= _total) break;\n            if (_groupIndex == 0) break;\n\n            _groupIndex--; // starts out one too high, so this works\n\n            (Grouped.MarketGroup memory _group, uint256 _groupId) =\n                Grouped(_marketFactory).getGroupByIndex(_groupIndex);\n\n            if (isGroupInteresting(_group, AbstractMarketFactoryV3(_marketFactory))) {\n                _interestingGroupIds[_collectedGroups] = _groupId;\n                _collectedGroups++;\n            }\n        }\n\n        if (_total > _collectedGroups) {\n            assembly {\n                // shortens array\n                mstore(_interestingGroupIds, _collectedGroups)\n            }\n        }\n    }\n\n    function isGroupInteresting(Grouped.MarketGroup memory _group, AbstractMarketFactoryV3 _marketFactory)\n        private\n        view\n        returns (bool)\n    {\n        for (uint256 i = 0; i < _group.markets.length; i++) {\n            uint256 _marketId = _group.markets[i];\n            if (openOrHasWinningShares(_marketFactory, _marketId)) {\n                return true;\n            }\n        }\n        if (openOrHasWinningShares(_marketFactory, _group.invalidMarket)) {\n            return true;\n        }\n\n        return false;\n    }\n}\n\ncontract FuturesFetcher is GroupFetcher {\n    constructor() Fetcher(\"Futures\", \"TBD\") {}\n}\n"
    },
    "contracts/turbo/Grouped.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\nimport \"./GroupFetcher.sol\";\n\nabstract contract Grouped is AbstractMarketFactoryV3, CalculateLinesToBPoolOdds {\n    event GroupCreated(uint256 indexed id, uint256 endTime, uint256 invalidMarketId, string invalidMarketName);\n    event GroupMarketAdded(uint256 indexed groupId, uint256 marketId, string marketName);\n    event GroupReady(uint256 indexed id);\n    event GroupResolved(uint256 indexed id, bool valid);\n\n    enum GroupStatus {Unknown, BeingCreated, Scheduled, Final, Invalid}\n\n    struct MarketGroup {\n        GroupStatus status;\n        string name;\n        uint256[] markets;\n        string[] marketNames;\n        uint256 invalidMarket;\n        string invalidMarketName;\n        uint256 endTime;\n        string category;\n    }\n    // GroupId => MarketGroup\n    mapping(uint256 => MarketGroup) public marketGroups;\n    uint256[] public listOfMarketGroups;\n\n    // For regular markets, YES means the team won and NO means the team did not win.\n    // For the invalid market, YES means none of the teams won and NO means a team won.\n    uint256 constant OUTCOME_NO = 0;\n    uint256 constant OUTCOME_YES = 1;\n\n    uint256 constant MAX_UINT = 2**256 - 1;\n\n    function groupCount() public view returns (uint256) {\n        return listOfMarketGroups.length;\n    }\n\n    function getGroup(uint256 _groupId) public view returns (MarketGroup memory) {\n        return marketGroups[_groupId];\n    }\n\n    function getGroupByIndex(uint256 _index) public view returns (MarketGroup memory _group, uint256 _groupId) {\n        _groupId = listOfMarketGroups[_index];\n        _group = getGroup(_groupId);\n    }\n\n    function startCreatingMarketGroup(\n        uint256 _groupId,\n        string memory _groupName,\n        uint256 _endTime,\n        string memory _invalidMarketName,\n        string memory _category\n    ) internal {\n        require(marketGroups[_groupId].status == GroupStatus.Unknown, \"group exists\");\n\n        listOfMarketGroups.push(_groupId);\n        marketGroups[_groupId].status = GroupStatus.BeingCreated; // new groups must be Scheduled\n        marketGroups[_groupId].name = _groupName;\n        marketGroups[_groupId].endTime = _endTime;\n        marketGroups[_groupId].category = _category;\n\n        uint256 _invalidMarket = startMarket(msg.sender, buildOutcomesNames(_invalidMarketName), invalidOdds(), false);\n        marketGroups[_groupId].invalidMarket = _invalidMarket;\n        marketGroups[_groupId].invalidMarketName = _invalidMarketName;\n\n        emit GroupCreated(_groupId, _endTime, _invalidMarket, _invalidMarketName);\n        emit GroupMarketAdded(_groupId, _invalidMarket, _invalidMarketName);\n    }\n\n    function addMarketToMarketGroup(\n        uint256 _groupId,\n        string memory _marketName,\n        uint256[] memory _odds\n    ) internal {\n        require(marketGroups[_groupId].status == GroupStatus.BeingCreated, \"group not being created\");\n\n        uint256 _marketId = startMarket(msg.sender, buildOutcomesNames(_marketName), _odds, false);\n        marketGroups[_groupId].markets.push(_marketId);\n        marketGroups[_groupId].marketNames.push(_marketName);\n        emit GroupMarketAdded(_groupId, _marketId, _marketName);\n    }\n\n    function finalizeMarketGroup(uint256 _groupId) internal {\n        MarketGroup storage _group = marketGroups[_groupId];\n        _group.status = GroupStatus.Scheduled;\n        markets[_group.invalidMarket].active = true;\n        activateMarket(_group.invalidMarket);\n        for (uint256 i = 0; i < _group.markets.length; i++) {\n            activateMarket(_group.markets[i]);\n        }\n        emit GroupReady(_groupId);\n    }\n\n    // Use MAX_UINT for _winningMarketIndex to indicate INVALID\n    function resolveMarketGroup(uint256 _groupId, uint256 _winningMarketIndex) internal {\n        bool _isInvalid = _winningMarketIndex == MAX_UINT;\n\n        MarketGroup memory _group = marketGroups[_groupId];\n        resolveInvalidMarket(_group, _isInvalid);\n        resolveRegularMarkets(_group, _winningMarketIndex);\n        marketGroups[_groupId].status = _isInvalid ? GroupStatus.Invalid : GroupStatus.Final;\n        emit GroupResolved(_groupId, !_isInvalid);\n    }\n\n    function resolveRegularMarkets(MarketGroup memory _group, uint256 _winningMarketIndex) private {\n        for (uint256 i = 0; i < _group.markets.length; i++) {\n            uint256 _marketId = _group.markets[i];\n            if (isMarketResolved(_marketId)) continue; // skip resolved markets\n            resolveGroupMarket(_marketId, _winningMarketIndex == i);\n        }\n    }\n\n    function resolveGroupMarket(uint256 _marketId, bool _wins) internal {\n        uint256 _winningOutcome;\n        if (_wins) {\n            _winningOutcome = OUTCOME_YES;\n        } else {\n            _winningOutcome = OUTCOME_NO;\n        }\n        endMarket(_marketId, _winningOutcome);\n    }\n\n    function resolveInvalidMarket(MarketGroup memory _group, bool _invalid) private {\n        uint256 _outcomeIndex = _invalid ? OUTCOME_YES : OUTCOME_NO;\n        endMarket(_group.invalidMarket, _outcomeIndex);\n    }\n\n    function buildOutcomesNames(string memory _marketName) internal pure returns (string[] memory _names) {\n        _names = new string[](2);\n        _names[OUTCOME_NO] = string(abi.encodePacked(\"NO - \", _marketName));\n        _names[OUTCOME_YES] = string(abi.encodePacked(\"YES - \", _marketName));\n    }\n\n    function invalidOdds() private pure returns (uint256[] memory _odds) {\n        _odds = new uint256[](2);\n        _odds[OUTCOME_YES] = 1e18;\n        _odds[OUTCOME_NO] = 49e18;\n    }\n}\n"
    },
    "contracts/turbo/TrustedMarketFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV2.sol\";\nimport \"./FeePot.sol\";\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\n\ncontract TrustedMarketFactoryV2 is AbstractMarketFactoryV2, CalculateLinesToBPoolOdds {\n    using SafeMathUint256 for uint256;\n\n    event MarketCreated(uint256 id, address creator, uint256 _endTime, string description, string[] outcomes);\n    event MarketResolved(uint256 id, address winner);\n\n    struct MarketDetails {\n        string description;\n    }\n    MarketDetails[] internal marketDetails;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256 _stakerFee,\n        uint256 _settlementFee,\n        address _protocol,\n        uint256 _protocolFee\n    )\n        AbstractMarketFactoryV2(\n            _owner,\n            _collateral,\n            _shareFactor,\n            _feePot,\n            _stakerFee,\n            _settlementFee,\n            _protocol,\n            _protocolFee\n        )\n    {}\n\n    function createMarket(\n        address _creator,\n        uint256 _endTime,\n        string calldata _description,\n        string[] calldata _names,\n        string[] calldata _symbols,\n        uint256[] calldata _odds\n    ) public onlyOwner returns (uint256) {\n        require(\n            _names.length == _symbols.length && _symbols.length == _odds.length,\n            \"names, symbols, and odds must be the same length\"\n        );\n\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _names, _symbols, _endTime, _odds));\n        marketDetails.push(MarketDetails(_description));\n\n        emit MarketCreated(_id, _creator, _endTime, _description, _symbols);\n        return _id;\n    }\n\n    function resolveMarket(uint256) public pure override {\n        require(false, \"Only the TrustedMarketFactory owner can resolve the market, using trustedResolveMarket\");\n    }\n\n    function trustedResolveMarket(uint256 _id, uint256 _winningOutcome) public onlyOwner {\n        OwnedERC20 _winner = markets[_id].shareTokens[_winningOutcome];\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function getMarketDetails(uint256 _id) public view returns (MarketDetails memory) {\n        return marketDetails[_id];\n    }\n}\n"
    },
    "contracts/turbo/AbstractMarketFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./TurboShareTokenFactory.sol\";\nimport \"./FeePot.sol\";\n\nabstract contract AbstractMarketFactoryV2 is TurboShareTokenFactoryV1, Ownable {\n    using SafeMathUint256 for uint256;\n\n    // Should always have ID. Others are optional.\n    // event MarketCreated(uint256 id, address settlementAddress, uint256 endTime, ...);\n\n    // Should always have ID. Others are optional.\n    // event MarketResolved(uint256 id, ...);\n\n    event SharesMinted(uint256 id, uint256 amount, address receiver);\n    event SharesBurned(uint256 id, uint256 amount, address receiver);\n    event WinningsClaimed(\n        uint256 id,\n        address winningOutcome,\n        uint256 amount,\n        uint256 settlementFee,\n        uint256 payout,\n        address indexed receiver\n    );\n\n    event SettlementFeeClaimed(address settlementAddress, uint256 amount, address indexed receiver);\n    event ProtocolFeeClaimed(address protocol, uint256 amount);\n\n    event ProtocolChanged(address protocol);\n    event ProtocolFeeChanged(uint256 fee);\n    event SettlementFeeChanged(uint256 fee);\n    event StakerFeeChanged(uint256 fee);\n\n    IERC20Full public collateral;\n    FeePot public feePot;\n\n    // fees are out of 1e18 and only apply to new markets\n    uint256 public stakerFee;\n    uint256 public settlementFee;\n    uint256 public protocolFee;\n\n    address public protocol; // collects protocol fees\n\n    uint256 public accumulatedProtocolFee = 0;\n    // settlement address => amount of collateral\n    mapping(address => uint256) public accumulatedSettlementFees;\n\n    // How many shares equals one collateral.\n    // Necessary to account for math errors from small numbers in balancer.\n    // shares = collateral / shareFactor\n    // collateral = shares * shareFactor\n    uint256 public shareFactor;\n\n    struct Market {\n        address settlementAddress;\n        OwnedERC20[] shareTokens;\n        uint256 endTime;\n        OwnedERC20 winner;\n        uint256 settlementFee;\n        uint256 protocolFee;\n        uint256 stakerFee;\n        uint256 creationTimestamp;\n        uint256[] initialOdds;\n    }\n    Market[] internal markets;\n\n    uint256 private constant MAX_UINT = 2**256 - 1;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256 _stakerFee,\n        uint256 _settlementFee,\n        address _protocol,\n        uint256 _protocolFee\n    ) {\n        owner = _owner; // controls fees for new markets\n        collateral = _collateral;\n        shareFactor = _shareFactor;\n        feePot = _feePot;\n        stakerFee = _stakerFee;\n        settlementFee = _settlementFee;\n        protocol = _protocol;\n        protocolFee = _protocolFee;\n\n        _collateral.approve(address(_feePot), MAX_UINT);\n\n        // First market is always empty so that marketid zero means \"no market\"\n        makeEmptyMarket();\n    }\n\n    function makeEmptyMarket() internal {\n        string[] memory _noStrings = new string[](0);\n        uint256[] memory _noUint256s = new uint256[](0);\n        markets.push(makeMarket(address(0), _noStrings, _noStrings, 0, _noUint256s));\n    }\n\n    // function createMarket(address _settlementAddress, uint256 _endTime, ...) public returns (uint256);\n\n    function resolveMarket(uint256 _id) public virtual;\n\n    // Returns an empty struct if the market doesn't exist.\n    // Can check market existence before calling this by comparing _id against markets.length.\n    // Can check market existence of the return struct by checking that shareTokens[0] isn't the null address\n    function getMarket(uint256 _id) public view returns (Market memory) {\n        if (_id >= markets.length) {\n            return Market(address(0), new OwnedERC20[](0), 0, OwnedERC20(0), 0, 0, 0, 0, new uint256[](0));\n        } else {\n            return markets[_id];\n        }\n    }\n\n    function marketCount() public view returns (uint256) {\n        return markets.length;\n    }\n\n    // Returns factory-specific details about a market.\n    // function getMarketDetails(uint256 _id) public view returns (MarketDetails memory);\n\n    function mintShares(\n        uint256 _id,\n        uint256 _shareToMint,\n        address _receiver\n    ) public {\n        require(markets.length > _id, \"No such market\");\n        require(!isMarketResolved(_id), \"Cannot mint shares for resolved market\");\n\n        uint256 _cost = calcCost(_shareToMint);\n        collateral.transferFrom(msg.sender, address(this), _cost);\n\n        Market memory _market = markets[_id];\n        for (uint256 _i = 0; _i < _market.shareTokens.length; _i++) {\n            _market.shareTokens[_i].trustedMint(_receiver, _shareToMint);\n        }\n\n        emit SharesMinted(_id, _shareToMint, _receiver);\n    }\n\n    function burnShares(\n        uint256 _id,\n        uint256 _sharesToBurn,\n        address _receiver\n    ) public returns (uint256) {\n        require(markets.length > _id, \"No such market\");\n        require(!isMarketResolved(_id), \"Cannot burn shares for resolved market\");\n\n        Market memory _market = markets[_id];\n        for (uint256 _i = 0; _i < _market.shareTokens.length; _i++) {\n            // errors if sender doesn't have enough shares\n            _market.shareTokens[_i].trustedBurn(msg.sender, _sharesToBurn);\n        }\n\n        uint256 _payout = calcCost(_sharesToBurn);\n        uint256 _protocolFee = _payout.mul(_market.protocolFee).div(10**18);\n        uint256 _stakerFee = _payout.mul(_market.stakerFee).div(10**18);\n        _payout = _payout.sub(_protocolFee).sub(_stakerFee);\n\n        accumulatedProtocolFee += _protocolFee;\n        collateral.transfer(_receiver, _payout);\n        feePot.depositFees(_stakerFee);\n\n        emit SharesBurned(_id, _sharesToBurn, msg.sender);\n        return _payout;\n    }\n\n    function claimWinnings(uint256 _id, address _receiver) public returns (uint256) {\n        if (!isMarketResolved(_id)) {\n            // errors if market does not exist or is not resolved or resolvable\n            resolveMarket(_id);\n        }\n\n        Market memory _market = markets[_id];\n        uint256 _winningShares = _market.winner.trustedBurnAll(msg.sender);\n        _winningShares = (_winningShares / shareFactor) * shareFactor; // remove unusable dust\n\n        uint256 _payout = calcCost(_winningShares); // will fail if there are no winnings to claim\n        uint256 _settlementFee = _payout.mul(_market.settlementFee).div(10**18);\n        _payout = _payout.sub(_settlementFee);\n\n        accumulatedSettlementFees[_market.settlementAddress] += _settlementFee;\n        collateral.transfer(_receiver, _payout);\n\n        emit WinningsClaimed(_id, address(_market.winner), _winningShares, _settlementFee, _payout, _receiver);\n        return _payout;\n    }\n\n    function claimManyWinnings(uint256[] memory _ids, address _receiver) public returns (uint256) {\n        uint256 _totalWinnings = 0;\n        for (uint256 i = 0; i < _ids.length; i++) {\n            _totalWinnings = _totalWinnings.add(claimWinnings(_ids[i], _receiver));\n        }\n        return _totalWinnings;\n    }\n\n    function claimSettlementFees(address _receiver) public returns (uint256) {\n        uint256 _fees = accumulatedSettlementFees[msg.sender];\n        if (_fees > 0) {\n            accumulatedSettlementFees[msg.sender] = 0;\n            collateral.transfer(_receiver, _fees);\n            emit SettlementFeeClaimed(msg.sender, _fees, _receiver);\n        }\n        return _fees;\n    }\n\n    function claimProtocolFees() public returns (uint256) {\n        require(msg.sender == protocol || msg.sender == address(this), \"Only protocol can claim protocol fee\");\n        uint256 _fees = accumulatedProtocolFee;\n        if (_fees > 0) {\n            accumulatedProtocolFee = 0;\n            collateral.transfer(protocol, _fees);\n            emit ProtocolFeeClaimed(protocol, _fees);\n        }\n        return _fees;\n    }\n\n    function setSettlementFee(uint256 _newFee) external onlyOwner {\n        settlementFee = _newFee;\n        emit SettlementFeeChanged(_newFee);\n    }\n\n    function setStakerFee(uint256 _newFee) external onlyOwner {\n        stakerFee = _newFee;\n        emit StakerFeeChanged(_newFee);\n    }\n\n    function setProtocolFee(uint256 _newFee) external onlyOwner {\n        protocolFee = _newFee;\n        emit ProtocolFeeChanged(_newFee);\n    }\n\n    function setProtocol(address _newProtocol, bool _claimFirst) external onlyOwner {\n        if (_claimFirst) {\n            claimProtocolFees();\n        }\n        protocol = _newProtocol;\n        emit ProtocolChanged(_newProtocol);\n    }\n\n    function makeMarket(\n        address _settlementAddress,\n        string[] memory _names,\n        string[] memory _symbols,\n        uint256 _endTime,\n        uint256[] memory _initialOdds\n    ) internal returns (Market memory _market) {\n        _market = Market(\n            _settlementAddress,\n            createShareTokens(_names, _symbols, address(this)),\n            _endTime,\n            OwnedERC20(0),\n            settlementFee,\n            protocolFee,\n            stakerFee,\n            block.timestamp,\n            _initialOdds\n        );\n    }\n\n    function isMarketResolved(uint256 _id) public view returns (bool) {\n        Market memory _market = markets[_id];\n        return _market.winner != OwnedERC20(0);\n    }\n\n    // Only usable off-chain. Gas cost can easily eclipse block limit.\n    function listUnresolvedMarkets() public view returns (uint256[] memory) {\n        uint256 _totalUnresolved = 0;\n        for (uint256 i = 0; i < markets.length; i++) {\n            if (!isMarketResolved(i)) {\n                _totalUnresolved++;\n            }\n        }\n\n        uint256[] memory _marketIds = new uint256[](_totalUnresolved);\n\n        uint256 n = 0;\n        for (uint256 i = 0; i < markets.length; i++) {\n            if (n >= _totalUnresolved) break;\n\n            if (!isMarketResolved(i)) {\n                _marketIds[n] = i;\n                n++;\n            }\n        }\n\n        return _marketIds;\n    }\n\n    // shares => collateral\n    function calcCost(uint256 _shares) public view returns (uint256) {\n        require(\n            _shares >= shareFactor && _shares % shareFactor == 0,\n            \"Shares must be both greater than (or equal to) and divisible by shareFactor\"\n        );\n        return _shares / shareFactor;\n    }\n\n    // collateral => shares\n    function calcShares(uint256 _collateralIn) public view returns (uint256) {\n        return _collateralIn * shareFactor;\n    }\n\n    function onTransferOwnership(address, address) internal override {}\n}\n"
    },
    "contracts/turbo/SportsLinkMarketFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV2.sol\";\nimport \"./FeePot.sol\";\nimport \"../libraries/SafeMathInt256.sol\";\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\n\ncontract SportsLinkMarketFactoryV2 is AbstractMarketFactoryV2, CalculateLinesToBPoolOdds {\n    using SafeMathUint256 for uint256;\n    using SafeMathInt256 for int256;\n\n    event MarketCreated(\n        uint256 id,\n        address creator,\n        uint256 endTime,\n        MarketType marketType,\n        uint256 indexed eventId,\n        uint256 homeTeamId,\n        uint256 awayTeamId,\n        uint256 estimatedStartTime,\n        int256 score\n    );\n    event MarketResolved(uint256 id, address winner);\n    event LinkNodeChanged(address newLinkNode);\n\n    enum MarketType {HeadToHead, Spread, OverUnder}\n    enum HeadToHeadOutcome {\n        NoContest, // 0\n        Away, // 1\n        Home // 2\n    }\n    enum SpreadOutcome {\n        NoContest, // 0\n        Away, // 1\n        Home // 2\n    }\n    enum OverUnderOutcome {\n        NoContest, // 0\n        Over, // 1\n        Under // 2\n    }\n    struct MarketDetails {\n        uint256 eventId;\n        uint256 homeTeamId;\n        uint256 awayTeamId;\n        uint256 estimatedStartTime;\n        MarketType marketType;\n        EventStatus eventStatus;\n        // This value depends on the marketType.\n        // HeadToHead: ignored\n        // Spread: the home team spread\n        // OverUnder: total score in game\n        int256 value0;\n    }\n    // MarketId => MarketDetails\n    mapping(uint256 => MarketDetails) internal marketDetails;\n\n    enum EventStatus {Unknown, Scheduled, Final, Postponed, Canceled}\n    struct EventDetails {\n        uint256[3] markets;\n        uint256 startTime;\n        uint256 homeScore;\n        uint256 awayScore;\n        EventStatus status;\n        // If there is a resolution time then the market is resolved but not necessarily finalized.\n        // A market is finalized when its last two score updates were identical.\n        // Score updates must occur after a period of time spedcified by resolutionBuffer.\n        // This mechanism exists to reduce the risk of bad scores being sent by the API then later corrected.\n        // The downside is slower resolution.\n        uint256 resolutionTime; // time since last score update\n        bool finalized; // true after event resolves and has stable scores\n    }\n    // EventId => EventDetails\n    mapping(uint256 => EventDetails) public events;\n    uint256[] public listOfEvents;\n\n    address public linkNode;\n    uint256 public sportId;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256 _stakerFee,\n        uint256 _settlementFee,\n        address _protocol,\n        uint256 _protocolFee,\n        address _linkNode,\n        uint256 _sportId\n    )\n        AbstractMarketFactoryV2(\n            _owner,\n            _collateral,\n            _shareFactor,\n            _feePot,\n            _stakerFee,\n            _settlementFee,\n            _protocol,\n            _protocolFee\n        )\n    {\n        linkNode = _linkNode;\n        sportId = _sportId;\n    }\n\n    function createMarket(\n        uint256 _eventId,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256 _homeSpread,\n        uint256 _totalScore,\n        bool _makeSpread,\n        bool _makeTotalScore,\n        int256[2] memory _moneylines // [home,away]\n    ) public returns (uint256[3] memory _ids) {\n        require(msg.sender == linkNode, \"Only link node can create markets\");\n\n        address _creator = msg.sender;\n        uint256 _endTime = _startTimestamp.add(60 * 8); // 8 hours\n\n        _ids = events[_eventId].markets;\n\n        if (_ids[0] == 0 && _moneylines[0] != 0 && _moneylines[1] != 0) {\n            _ids[0] = createHeadToHeadMarket(\n                _creator,\n                _endTime,\n                _eventId,\n                _homeTeamId,\n                _awayTeamId,\n                _startTimestamp,\n                _moneylines\n            );\n        }\n\n        if (_ids[1] == 0 && _makeSpread) {\n            // spread market hasn't been created and is ready to be created\n            _ids[1] = createSpreadMarket(\n                _creator,\n                _endTime,\n                _eventId,\n                _homeTeamId,\n                _awayTeamId,\n                _startTimestamp,\n                _homeSpread\n            );\n        }\n\n        if (_ids[2] == 0 && _makeTotalScore) {\n            // over-under market hasn't been created and is ready to be created\n            _ids[2] = createOverUnderMarket(\n                _creator,\n                _endTime,\n                _eventId,\n                _homeTeamId,\n                _awayTeamId,\n                _startTimestamp,\n                _totalScore\n            );\n        }\n\n        events[_eventId].status = EventStatus.Scheduled;\n        events[_eventId].startTime = _startTimestamp;\n        events[_eventId].markets = _ids;\n        listOfEvents.push(_eventId);\n    }\n\n    function createHeadToHeadMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256[2] memory _moneylines // [home,away]\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(HeadToHeadOutcome.NoContest)] = \"No Contest\";\n        _outcomes[uint256(HeadToHeadOutcome.Away)] = \"Away\";\n        _outcomes[uint256(HeadToHeadOutcome.Home)] = \"Home\";\n\n        uint256 _id = markets.length;\n        // moneylines is [home,away] but the outcomes are listed [NC,away,home] so they must be reversed\n        markets.push(\n            makeMarket(_creator, _outcomes, _outcomes, _endTime, oddsFromLines(_moneylines[1], _moneylines[0]))\n        );\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.HeadToHead,\n            EventStatus.Scheduled,\n            0\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.HeadToHead,\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            0\n        );\n        return _id;\n    }\n\n    function createSpreadMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256 _homeSpread\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(SpreadOutcome.NoContest)] = \"No Contest\";\n        _outcomes[uint256(SpreadOutcome.Away)] = \"Away\";\n        _outcomes[uint256(SpreadOutcome.Home)] = \"Home\";\n\n        // The spread is a quantity of tenths. So 55 is 5.5 and -6 is -60.\n        // If the spread is a whole number then make it a half point more extreme, to eliminate ties.\n        // So 50 becomes 55, -60 becomes -65, and 0 becomes 5.\n        if (_homeSpread >= 0 && _homeSpread % 10 == 0) {\n            _homeSpread += 5;\n        } else if (_homeSpread < 0 && (-_homeSpread) % 10 == 0) {\n            _homeSpread -= 5;\n        }\n\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime, evenOdds(true, 2)));\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.Spread,\n            EventStatus.Scheduled,\n            _homeSpread\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.Spread,\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            _homeSpread\n        );\n        return _id;\n    }\n\n    function createOverUnderMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        uint256 _overUnderTotal\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(OverUnderOutcome.NoContest)] = \"No Contest\";\n        _outcomes[uint256(OverUnderOutcome.Over)] = \"Over\";\n        _outcomes[uint256(OverUnderOutcome.Under)] = \"Under\";\n\n        // The total is a quantity of tenths. So 55 is 5.5 and -6 is -60.\n        // If the total is a whole number then make it a half point higher, to eliminate ties.\n        // So 50 becomes 55 and 0 becomes 5.\n        if (_overUnderTotal >= 0 && _overUnderTotal % 10 == 0) {\n            _overUnderTotal += 5;\n        }\n\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime, evenOdds(true, 2)));\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.OverUnder,\n            EventStatus.Scheduled,\n            int256(_overUnderTotal)\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.OverUnder,\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            int256(_overUnderTotal)\n        );\n        return _id;\n    }\n\n    function resolveMarket(uint256) public pure override {\n        require(false, \"Only the link node can resolve the market, using trustedResolveMarkets\");\n    }\n\n    function trustedResolveMarkets(\n        uint256 _eventId,\n        uint256 _eventStatus,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) public {\n        require(msg.sender == linkNode, \"Only link node can resolve markets\");\n\n        EventDetails storage _event = events[_eventId];\n        uint256[3] memory _ids = _event.markets;\n\n        require(_ids[0] != 0 || _ids[1] != 0 || _ids[2] != 0, \"Cannot resolve markets that weren't created\");\n\n        require(EventStatus(_eventStatus) != EventStatus.Scheduled, \"cannot resolve SCHEDULED markets\");\n\n        // resolve markets as No Contest\n        if (EventStatus(_eventStatus) != EventStatus.Final) {\n            for (uint256 i = 0; i < _ids.length; i++) {\n                uint256 _id = _ids[i];\n                if (_id == 0) continue; // skip non-created markets\n                OwnedERC20 _winner = markets[_id].shareTokens[0]; // 0th outcome is No Contest for all market types\n                markets[_id].winner = _winner;\n                emit MarketResolved(_id, address(_winner));\n            }\n            return;\n        }\n\n        // only resolve markets that were created\n        if (_ids[0] != 0) {\n            resolveHeadToHeadMarket(_ids[0], _homeScore, _awayScore);\n        }\n        if (_ids[1] != 0) {\n            resolveSpreadMarket(_ids[1], _homeScore, _awayScore);\n        }\n        if (_ids[2] != 0) {\n            resolveOverUnderMarket(_ids[2], _homeScore, _awayScore);\n        }\n    }\n\n    function resolveHeadToHeadMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        OwnedERC20 _winner;\n        if (_homeScore > _awayScore) {\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.Home)]; // home team won\n        } else if (_homeScore < _awayScore) {\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.Away)]; // away team won\n        } else {\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.NoContest)]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function resolveSpreadMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        MarketDetails memory _details = marketDetails[_id];\n        int256 _targetSpread = _details.value0;\n\n        int256 _actualSpread = int256(_homeScore).sub(int256(_awayScore));\n\n        OwnedERC20 _winner;\n        if (_actualSpread > _targetSpread) {\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.Home)]; // home spread greater\n        } else if (_actualSpread < _targetSpread) {\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.Away)]; // home spread lesser\n        } else {\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.NoContest)]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function resolveOverUnderMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        MarketDetails memory _details = marketDetails[_id];\n        int256 _targetTotal = _details.value0;\n\n        int256 _actualTotal = int256(_homeScore).add(int256(_awayScore));\n\n        OwnedERC20 _winner;\n        if (_actualTotal > _targetTotal) {\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.Over)]; // over\n        } else if (_actualTotal < _targetTotal) {\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.Under)]; // under\n        } else {\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.NoContest)]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function getMarketDetails(uint256 _marketId) public view returns (MarketDetails memory) {\n        return marketDetails[_marketId];\n    }\n\n    function setLinkNode(address _newLinkNode) external onlyOwner {\n        linkNode = _newLinkNode;\n        emit LinkNodeChanged(_newLinkNode);\n    }\n\n    function getEventMarkets(uint256 _eventId) external view returns (uint256[3] memory) {\n        uint256[3] memory _event = events[_eventId].markets;\n        return _event;\n    }\n\n    // Events can be partially registered, by only creating some markets.\n    // This returns true only if an event is fully registered.\n    function isEventRegistered(uint256 _eventId) public view returns (bool) {\n        uint256[3] memory _event = events[_eventId].markets;\n        return _event[0] != 0 && _event[1] != 0 && _event[2] != 0;\n    }\n\n    function isEventResolved(uint256 _eventId) public view returns (bool) {\n        // check the event's head-to-head market since it will always exist if the event's markets exist\n        uint256 _marketId = events[_eventId].markets[0];\n        return isMarketResolved(_marketId);\n    }\n\n    // Only usable off-chain. Gas cost can easily eclipse block limit.\n    // Lists all events that could be resolved with a call to resolveEvent.\n    // Not all will be resolvable because this does not ensure the game ended.\n    function listResolvableEvents() external view returns (uint256[] memory) {\n        uint256 _totalResolvable = countResolvableEvents();\n        uint256[] memory _resolvableEvents = new uint256[](_totalResolvable);\n\n        uint256 n = 0;\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\n            if (n > _totalResolvable) break;\n            uint256 _eventId = listOfEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _resolvableEvents[n] = _eventId;\n                n++;\n            }\n        }\n\n        return _resolvableEvents;\n    }\n\n    function countResolvableEvents() internal view returns (uint256) {\n        uint256 _totalResolvable = 0;\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\n            uint256 _eventId = listOfEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _totalResolvable++;\n            }\n        }\n        return _totalResolvable;\n    }\n\n    // Returns true if a call to resolveEvent is potentially useful.\n    function isEventResolvable(uint256 _eventId) internal view returns (bool) {\n        EventDetails memory _event = events[_eventId];\n\n        bool _unresolved = false; // default because non-existing markets aren't resolvable\n        for (uint256 i = 0; i < _event.markets.length; i++) {\n            uint256 _marketId = _event.markets[i];\n            if (_marketId != 0 && !isMarketResolved(_marketId)) {\n                _unresolved = true;\n                break;\n            }\n        }\n\n        return _unresolved;\n    }\n}\n"
    },
    "contracts/turbo/SportsLinkMarketFactoryV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV1.sol\";\nimport \"./FeePot.sol\";\nimport \"../libraries/SafeMathInt256.sol\";\n\ncontract SportsLinkMarketFactoryV1 is AbstractMarketFactoryV1 {\n    using SafeMathUint256 for uint256;\n    using SafeMathInt256 for int256;\n\n    event MarketCreated(\n        uint256 id,\n        address creator,\n        uint256 endTime,\n        MarketType marketType,\n        uint256 indexed eventId,\n        uint256 homeTeamId,\n        uint256 awayTeamId,\n        uint256 estimatedStartTime,\n        int256 score\n    );\n    event MarketResolved(uint256 id, address winner);\n    event LinkNodeChanged(address newLinkNode);\n\n    enum MarketType {HeadToHead, Spread, OverUnder}\n    enum HeadToHeadOutcome {\n        NoContest, // 0\n        Away, // 1\n        Home // 2\n    }\n    enum SpreadOutcome {\n        NoContest, // 0\n        Away, // 1\n        Home // 2\n    }\n    enum OverUnderOutcome {\n        NoContest, // 0\n        Over, // 1\n        Under // 2\n    }\n    struct MarketDetails {\n        uint256 eventId;\n        uint256 homeTeamId;\n        uint256 awayTeamId;\n        uint256 estimatedStartTime;\n        MarketType marketType;\n        EventStatus eventStatus;\n        // This value depends on the marketType.\n        // HeadToHead: ignored\n        // Spread: the home team spread\n        // OverUnder: total score in game\n        int256 value0;\n    }\n    // MarketId => MarketDetails\n    mapping(uint256 => MarketDetails) internal marketDetails;\n\n    enum EventStatus {Unknown, Scheduled, Final, Postponed, Canceled}\n    struct EventDetails {\n        uint256[3] markets;\n        uint256 startTime;\n        uint256 homeScore;\n        uint256 awayScore;\n        EventStatus status;\n        // If there is a resolution time then the market is resolved but not necessarily finalized.\n        // A market is finalized when its last two score updates were identical.\n        // Score updates must occur after a period of time spedcified by resolutionBuffer.\n        // This mechanism exists to reduce the risk of bad scores being sent by the API then later corrected.\n        // The downside is slower resolution.\n        uint256 resolutionTime; // time since last score update\n        bool finalized; // true after event resolves and has stable scores\n    }\n    // EventId => EventDetails\n    mapping(uint256 => EventDetails) public events;\n    uint256[] public listOfEvents;\n\n    address public linkNode;\n    uint256 public sportId;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256 _stakerFee,\n        uint256 _settlementFee,\n        address _protocol,\n        uint256 _protocolFee,\n        address _linkNode,\n        uint256 _sportId\n    )\n        AbstractMarketFactoryV1(\n            _owner,\n            _collateral,\n            _shareFactor,\n            _feePot,\n            _stakerFee,\n            _settlementFee,\n            _protocol,\n            _protocolFee\n        )\n    {\n        linkNode = _linkNode;\n        sportId = _sportId;\n    }\n\n    function createMarket(\n        uint256 _eventId,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256 _homeSpread,\n        uint256 _totalScore,\n        bool _makeSpread,\n        bool _makeTotalScore\n    ) public returns (uint256[3] memory _ids) {\n        require(msg.sender == linkNode, \"Only link node can create markets\");\n\n        address _creator = msg.sender;\n        uint256 _endTime = _startTimestamp.add(60 * 8); // 8 hours\n\n        _ids = events[_eventId].markets;\n\n        if (_ids[0] == 0) {\n            _ids[0] = createHeadToHeadMarket(_creator, _endTime, _eventId, _homeTeamId, _awayTeamId, _startTimestamp);\n        }\n\n        if (_ids[1] == 0 && _makeSpread) {\n            // spread market hasn't been created and is ready to be created\n            _ids[1] = createSpreadMarket(\n                _creator,\n                _endTime,\n                _eventId,\n                _homeTeamId,\n                _awayTeamId,\n                _startTimestamp,\n                _homeSpread\n            );\n        }\n\n        if (_ids[2] == 0 && _makeTotalScore) {\n            // over-under market hasn't been created and is ready to be created\n            _ids[2] = createOverUnderMarket(\n                _creator,\n                _endTime,\n                _eventId,\n                _homeTeamId,\n                _awayTeamId,\n                _startTimestamp,\n                _totalScore\n            );\n        }\n\n        events[_eventId].status = EventStatus.Scheduled;\n        events[_eventId].startTime = _startTimestamp;\n        events[_eventId].markets = _ids;\n        listOfEvents.push(_eventId);\n    }\n\n    function createHeadToHeadMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(HeadToHeadOutcome.NoContest)] = \"No Contest\";\n        _outcomes[uint256(HeadToHeadOutcome.Away)] = \"Away\";\n        _outcomes[uint256(HeadToHeadOutcome.Home)] = \"Home\";\n\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime));\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.HeadToHead,\n            EventStatus.Scheduled,\n            0\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.HeadToHead,\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            0\n        );\n        return _id;\n    }\n\n    function createSpreadMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256 _homeSpread\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(SpreadOutcome.NoContest)] = \"No Contest\";\n        _outcomes[uint256(SpreadOutcome.Away)] = \"Away\";\n        _outcomes[uint256(SpreadOutcome.Home)] = \"Home\";\n\n        // The spread is a quantity of tenths. So 55 is 5.5 and -6 is -60.\n        // If the spread is a whole number then make it a half point more extreme, to eliminate ties.\n        // So 50 becomes 55, -60 becomes -65, and 0 becomes 5.\n        if (_homeSpread >= 0 && _homeSpread % 10 == 0) {\n            _homeSpread += 5;\n        } else if (_homeSpread < 0 && (-_homeSpread) % 10 == 0) {\n            _homeSpread -= 5;\n        }\n\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime));\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.Spread,\n            EventStatus.Scheduled,\n            _homeSpread\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.Spread,\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            _homeSpread\n        );\n        return _id;\n    }\n\n    function createOverUnderMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        uint256 _overUnderTotal\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(OverUnderOutcome.NoContest)] = \"No Contest\";\n        _outcomes[uint256(OverUnderOutcome.Over)] = \"Over\";\n        _outcomes[uint256(OverUnderOutcome.Under)] = \"Under\";\n\n        // The total is a quantity of tenths. So 55 is 5.5 and -6 is -60.\n        // If the total is a whole number then make it a half point higher, to eliminate ties.\n        // So 50 becomes 55 and 0 becomes 5.\n        if (_overUnderTotal >= 0 && _overUnderTotal % 10 == 0) {\n            _overUnderTotal += 5;\n        }\n\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime));\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.OverUnder,\n            EventStatus.Scheduled,\n            int256(_overUnderTotal)\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.OverUnder,\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            int256(_overUnderTotal)\n        );\n        return _id;\n    }\n\n    function resolveMarket(uint256) public pure override {\n        require(false, \"Only the link node can resolve the market, using trustedResolveMarkets\");\n    }\n\n    function trustedResolveMarkets(\n        uint256 _eventId,\n        uint256 _eventStatus,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) public {\n        require(msg.sender == linkNode, \"Only link node can resolve markets\");\n\n        EventDetails storage _event = events[_eventId];\n        uint256[3] memory _ids = _event.markets;\n\n        require(_ids[0] != 0 || _ids[1] != 0 || _ids[2] != 0, \"Cannot resolve markets that weren't created\");\n\n        require(EventStatus(_eventStatus) != EventStatus.Scheduled, \"cannot resolve SCHEDULED markets\");\n\n        // resolve markets as No Contest\n        if (EventStatus(_eventStatus) != EventStatus.Final) {\n            for (uint256 i = 0; i < _ids.length; i++) {\n                uint256 _id = _ids[i];\n                if (_id == 0) continue; // skip non-created markets\n                OwnedERC20 _winner = markets[_id].shareTokens[0]; // 0th outcome is No Contest for all market types\n                markets[_id].winner = _winner;\n                emit MarketResolved(_id, address(_winner));\n            }\n            return;\n        }\n\n        // only resolve markets that were created\n        if (_ids[0] != 0) {\n            resolveHeadToHeadMarket(_ids[0], _homeScore, _awayScore);\n        }\n        if (_ids[1] != 0) {\n            resolveSpreadMarket(_ids[1], _homeScore, _awayScore);\n        }\n        if (_ids[2] != 0) {\n            resolveOverUnderMarket(_ids[2], _homeScore, _awayScore);\n        }\n    }\n\n    function resolveHeadToHeadMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        OwnedERC20 _winner;\n        if (_homeScore > _awayScore) {\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.Home)]; // home team won\n        } else if (_homeScore < _awayScore) {\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.Away)]; // away team won\n        } else {\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.NoContest)]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function resolveSpreadMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        MarketDetails memory _details = marketDetails[_id];\n        int256 _targetSpread = _details.value0;\n\n        int256 _actualSpread = int256(_homeScore).sub(int256(_awayScore));\n\n        OwnedERC20 _winner;\n        if (_actualSpread > _targetSpread) {\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.Home)]; // home spread greater\n        } else if (_actualSpread < _targetSpread) {\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.Away)]; // home spread lesser\n        } else {\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.NoContest)]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function resolveOverUnderMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        MarketDetails memory _details = marketDetails[_id];\n        int256 _targetTotal = _details.value0;\n\n        int256 _actualTotal = int256(_homeScore).add(int256(_awayScore));\n\n        OwnedERC20 _winner;\n        if (_actualTotal > _targetTotal) {\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.Over)]; // over\n        } else if (_actualTotal < _targetTotal) {\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.Under)]; // under\n        } else {\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.NoContest)]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function getMarketDetails(uint256 _marketId) public view returns (MarketDetails memory) {\n        return marketDetails[_marketId];\n    }\n\n    function setLinkNode(address _newLinkNode) external onlyOwner {\n        linkNode = _newLinkNode;\n        emit LinkNodeChanged(_newLinkNode);\n    }\n\n    function getEventMarkets(uint256 _eventId) external view returns (uint256[3] memory) {\n        uint256[3] memory _event = events[_eventId].markets;\n        return _event;\n    }\n\n    // Events can be partially registered, by only creating some markets.\n    // This returns true only if an event is fully registered.\n    function isEventRegistered(uint256 _eventId) public view returns (bool) {\n        uint256[3] memory _event = events[_eventId].markets;\n        return _event[0] != 0 && _event[1] != 0 && _event[2] != 0;\n    }\n\n    function isEventResolved(uint256 _eventId) public view returns (bool) {\n        // check the event's head-to-head market since it will always exist if the event's markets exist\n        uint256 _marketId = events[_eventId].markets[0];\n        return isMarketResolved(_marketId);\n    }\n\n    // Only usable off-chain. Gas cost can easily eclipse block limit.\n    // Lists all events that could be resolved with a call to resolveEvent.\n    // Not all will be resolvable because this does not ensure the game ended.\n    function listResolvableEvents() external view returns (uint256[] memory) {\n        uint256 _totalResolvable = countResolvableEvents();\n        uint256[] memory _resolvableEvents = new uint256[](_totalResolvable);\n\n        uint256 n = 0;\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\n            if (n > _totalResolvable) break;\n            uint256 _eventId = listOfEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _resolvableEvents[n] = _eventId;\n                n++;\n            }\n        }\n\n        return _resolvableEvents;\n    }\n\n    function countResolvableEvents() internal view returns (uint256) {\n        uint256 _totalResolvable = 0;\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\n            uint256 _eventId = listOfEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _totalResolvable++;\n            }\n        }\n        return _totalResolvable;\n    }\n\n    // Returns true if a call to resolveEvent is potentially useful.\n    function isEventResolvable(uint256 _eventId) internal view returns (bool) {\n        EventDetails memory _event = events[_eventId];\n\n        bool _unresolved = false; // default because non-existing markets aren't resolvable\n        for (uint256 i = 0; i < _event.markets.length; i++) {\n            uint256 _marketId = _event.markets[i];\n            if (_marketId != 0 && !isMarketResolved(_marketId)) {\n                _unresolved = true;\n                break;\n            }\n        }\n\n        return _unresolved;\n    }\n}\n"
    },
    "contracts/turbo/AbstractMarketFactoryV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./TurboShareTokenFactory.sol\";\nimport \"./FeePot.sol\";\n\nabstract contract AbstractMarketFactoryV1 is TurboShareTokenFactoryV1, Ownable {\n    using SafeMathUint256 for uint256;\n\n    // Should always have ID. Others are optional.\n    // event MarketCreated(uint256 id, address settlementAddress, uint256 endTime, ...);\n\n    // Should always have ID. Others are optional.\n    // event MarketResolved(uint256 id, ...);\n\n    event SharesMinted(uint256 id, uint256 amount, address receiver);\n    event SharesBurned(uint256 id, uint256 amount, address receiver);\n    event WinningsClaimed(\n        uint256 id,\n        address winningOutcome,\n        uint256 amount,\n        uint256 settlementFee,\n        uint256 payout,\n        address indexed receiver\n    );\n\n    event SettlementFeeClaimed(address settlementAddress, uint256 amount, address indexed receiver);\n    event ProtocolFeeClaimed(address protocol, uint256 amount);\n\n    event ProtocolChanged(address protocol);\n    event ProtocolFeeChanged(uint256 fee);\n    event SettlementFeeChanged(uint256 fee);\n    event StakerFeeChanged(uint256 fee);\n\n    IERC20Full public collateral;\n    FeePot public feePot;\n\n    // fees are out of 1e18 and only apply to new markets\n    uint256 public stakerFee;\n    uint256 public settlementFee;\n    uint256 public protocolFee;\n\n    address public protocol; // collects protocol fees\n\n    uint256 public accumulatedProtocolFee = 0;\n    // settlement address => amount of collateral\n    mapping(address => uint256) public accumulatedSettlementFees;\n\n    // How many shares equals one collateral.\n    // Necessary to account for math errors from small numbers in balancer.\n    // shares = collateral / shareFactor\n    // collateral = shares * shareFactor\n    uint256 public shareFactor;\n\n    struct Market {\n        address settlementAddress;\n        OwnedERC20[] shareTokens;\n        uint256 endTime;\n        OwnedERC20 winner;\n        uint256 settlementFee;\n        uint256 protocolFee;\n        uint256 stakerFee;\n        uint256 creationTimestamp;\n    }\n    Market[] internal markets;\n\n    uint256 private constant MAX_UINT = 2**256 - 1;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256 _stakerFee,\n        uint256 _settlementFee,\n        address _protocol,\n        uint256 _protocolFee\n    ) {\n        owner = _owner; // controls fees for new markets\n        collateral = _collateral;\n        shareFactor = _shareFactor;\n        feePot = _feePot;\n        stakerFee = _stakerFee;\n        settlementFee = _settlementFee;\n        protocol = _protocol;\n        protocolFee = _protocolFee;\n\n        _collateral.approve(address(_feePot), MAX_UINT);\n\n        // First market is always empty so that marketid zero means \"no market\"\n        string[] memory _nothing = new string[](0);\n        markets.push(makeMarket(address(0), _nothing, _nothing, 0));\n    }\n\n    // function createMarket(address _settlementAddress, uint256 _endTime, ...) public returns (uint256);\n\n    function resolveMarket(uint256 _id) public virtual;\n\n    // Returns an empty struct if the market doesn't exist.\n    // Can check market existence before calling this by comparing _id against markets.length.\n    // Can check market existence of the return struct by checking that shareTokens[0] isn't the null address\n    function getMarket(uint256 _id) public view returns (Market memory) {\n        if (_id >= markets.length) {\n            return Market(address(0), new OwnedERC20[](0), 0, OwnedERC20(0), 0, 0, 0, 0);\n        } else {\n            return markets[_id];\n        }\n    }\n\n    function marketCount() public view returns (uint256) {\n        return markets.length;\n    }\n\n    // Returns factory-specific details about a market.\n    // function getMarketDetails(uint256 _id) public view returns (MarketDetails memory);\n\n    function mintShares(\n        uint256 _id,\n        uint256 _shareToMint,\n        address _receiver\n    ) public {\n        require(markets.length > _id, \"No such market\");\n        require(!isMarketResolved(_id), \"Cannot mint shares for resolved market\");\n\n        uint256 _cost = calcCost(_shareToMint);\n        collateral.transferFrom(msg.sender, address(this), _cost);\n\n        Market memory _market = markets[_id];\n        for (uint256 _i = 0; _i < _market.shareTokens.length; _i++) {\n            _market.shareTokens[_i].trustedMint(_receiver, _shareToMint);\n        }\n\n        emit SharesMinted(_id, _shareToMint, _receiver);\n    }\n\n    function burnShares(\n        uint256 _id,\n        uint256 _sharesToBurn,\n        address _receiver\n    ) public returns (uint256) {\n        require(markets.length > _id, \"No such market\");\n        require(!isMarketResolved(_id), \"Cannot burn shares for resolved market\");\n\n        Market memory _market = markets[_id];\n        for (uint256 _i = 0; _i < _market.shareTokens.length; _i++) {\n            // errors if sender doesn't have enough shares\n            _market.shareTokens[_i].trustedBurn(msg.sender, _sharesToBurn);\n        }\n\n        uint256 _payout = calcCost(_sharesToBurn);\n        uint256 _protocolFee = _payout.mul(_market.protocolFee).div(10**18);\n        uint256 _stakerFee = _payout.mul(_market.stakerFee).div(10**18);\n        _payout = _payout.sub(_protocolFee).sub(_stakerFee);\n\n        accumulatedProtocolFee += _protocolFee;\n        collateral.transfer(_receiver, _payout);\n        feePot.depositFees(_stakerFee);\n\n        emit SharesBurned(_id, _sharesToBurn, msg.sender);\n        return _payout;\n    }\n\n    function claimWinnings(uint256 _id, address _receiver) public returns (uint256) {\n        if (!isMarketResolved(_id)) {\n            // errors if market does not exist or is not resolved or resolvable\n            resolveMarket(_id);\n        }\n\n        Market memory _market = markets[_id];\n        uint256 _winningShares = _market.winner.trustedBurnAll(msg.sender);\n        _winningShares = (_winningShares / shareFactor) * shareFactor; // remove unusable dust\n\n        uint256 _payout = calcCost(_winningShares); // will fail if there are no winnings to claim\n        uint256 _settlementFee = _payout.mul(_market.settlementFee).div(10**18);\n        _payout = _payout.sub(_settlementFee);\n\n        accumulatedSettlementFees[_market.settlementAddress] += _settlementFee;\n        collateral.transfer(_receiver, _payout);\n\n        emit WinningsClaimed(_id, address(_market.winner), _winningShares, _settlementFee, _payout, _receiver);\n        return _payout;\n    }\n\n    function claimManyWinnings(uint256[] memory _ids, address _receiver) public returns (uint256) {\n        uint256 _totalWinnings = 0;\n        for (uint256 i = 0; i < _ids.length; i++) {\n            _totalWinnings = _totalWinnings.add(claimWinnings(_ids[i], _receiver));\n        }\n        return _totalWinnings;\n    }\n\n    function claimSettlementFees(address _receiver) public returns (uint256) {\n        uint256 _fees = accumulatedSettlementFees[msg.sender];\n        if (_fees > 0) {\n            accumulatedSettlementFees[msg.sender] = 0;\n            collateral.transfer(_receiver, _fees);\n            emit SettlementFeeClaimed(msg.sender, _fees, _receiver);\n        }\n        return _fees;\n    }\n\n    function claimProtocolFees() public returns (uint256) {\n        require(msg.sender == protocol || msg.sender == address(this), \"Only protocol can claim protocol fee\");\n        uint256 _fees = accumulatedProtocolFee;\n        if (_fees > 0) {\n            accumulatedProtocolFee = 0;\n            collateral.transfer(protocol, _fees);\n            emit ProtocolFeeClaimed(protocol, _fees);\n        }\n        return _fees;\n    }\n\n    function setSettlementFee(uint256 _newFee) external onlyOwner {\n        settlementFee = _newFee;\n        emit SettlementFeeChanged(_newFee);\n    }\n\n    function setStakerFee(uint256 _newFee) external onlyOwner {\n        stakerFee = _newFee;\n        emit StakerFeeChanged(_newFee);\n    }\n\n    function setProtocolFee(uint256 _newFee) external onlyOwner {\n        protocolFee = _newFee;\n        emit ProtocolFeeChanged(_newFee);\n    }\n\n    function setProtocol(address _newProtocol, bool _claimFirst) external onlyOwner {\n        if (_claimFirst) {\n            claimProtocolFees();\n        }\n        protocol = _newProtocol;\n        emit ProtocolChanged(_newProtocol);\n    }\n\n    function makeMarket(\n        address _settlementAddress,\n        string[] memory _names,\n        string[] memory _symbols,\n        uint256 _endTime\n    ) internal returns (Market memory _market) {\n        _market = Market(\n            _settlementAddress,\n            createShareTokens(_names, _symbols, address(this)),\n            _endTime,\n            OwnedERC20(0),\n            settlementFee,\n            protocolFee,\n            stakerFee,\n            block.timestamp\n        );\n    }\n\n    function isMarketResolved(uint256 _id) public view returns (bool) {\n        Market memory _market = markets[_id];\n        return _market.winner != OwnedERC20(0);\n    }\n\n    // Only usable off-chain. Gas cost can easily eclipse block limit.\n    function listUnresolvedMarkets() public view returns (uint256[] memory) {\n        uint256 _totalUnresolved = 0;\n        for (uint256 i = 0; i < markets.length; i++) {\n            if (!isMarketResolved(i)) {\n                _totalUnresolved++;\n            }\n        }\n\n        uint256[] memory _marketIds = new uint256[](_totalUnresolved);\n\n        uint256 n = 0;\n        for (uint256 i = 0; i < markets.length; i++) {\n            if (n >= _totalUnresolved) break;\n\n            if (!isMarketResolved(i)) {\n                _marketIds[n] = i;\n                n++;\n            }\n        }\n\n        return _marketIds;\n    }\n\n    // shares => collateral\n    function calcCost(uint256 _shares) public view returns (uint256) {\n        require(\n            _shares >= shareFactor && _shares % shareFactor == 0,\n            \"Shares must be both greater than (or equal to) and divisible by shareFactor\"\n        );\n        return _shares / shareFactor;\n    }\n\n    // collateral => shares\n    function calcShares(uint256 _collateralIn) public view returns (uint256) {\n        return _collateralIn * shareFactor;\n    }\n\n    function onTransferOwnership(address, address) internal override {}\n}\n"
    },
    "contracts/turbo/NFLMarketFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV2.sol\";\nimport \"./FeePot.sol\";\nimport \"../libraries/SafeMathInt256.sol\";\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\n\ncontract NFLMarketFactoryV2 is AbstractMarketFactoryV2, CalculateLinesToBPoolOdds {\n    using SafeMathUint256 for uint256;\n    using SafeMathInt256 for int256;\n\n    event MarketCreated(\n        uint256 id,\n        address creator,\n        uint256 endTime,\n        MarketType marketType,\n        uint256 indexed eventId,\n        string homeTeamName,\n        uint256 homeTeamId,\n        string awayTeamName,\n        uint256 awayTeamId,\n        uint256 estimatedStartTime,\n        int256 score\n    );\n    event MarketResolved(uint256 id, address winner);\n    event LinkNodeChanged(address newLinkNode);\n\n    enum MarketType {HeadToHead, Spread, OverUnder}\n    enum HeadToHeadOutcome {\n        NoContest, // 0\n        Away, // 1\n        Home // 2\n    }\n    enum SpreadOutcome {\n        NoContest, // 0\n        Away, // 1\n        Home // 2\n    }\n    enum OverUnderOutcome {\n        NoContest, // 0\n        Over, // 1\n        Under // 2\n    }\n    struct MarketDetails {\n        uint256 eventId;\n        string homeTeamName;\n        uint256 homeTeamId;\n        string awayTeamName;\n        uint256 awayTeamId;\n        uint256 estimatedStartTime;\n        MarketType marketType;\n        EventStatus eventStatus;\n        // This value depends on the marketType.\n        // HeadToHead: ignored\n        // Spread: the home team spread\n        // OverUnder: total score in game\n        int256 value0;\n    }\n    // MarketId => MarketDetails\n    mapping(uint256 => MarketDetails) internal marketDetails;\n\n    enum EventStatus {Unknown, Scheduled, Final, Postponed, Canceled}\n    struct EventDetails {\n        uint256[3] markets;\n        uint256 startTime;\n        uint256 homeScore;\n        uint256 awayScore;\n        EventStatus status;\n        // If there is a resolution time then the market is resolved but not necessarily finalized.\n        // A market is finalized when its last two score updates were identical.\n        // Score updates must occur after a period of time specified by resolutionBuffer.\n        // This mechanism exists to reduce the risk of bad scores being sent by the API then later corrected.\n        // The downside is slower resolution.\n        uint256 resolutionTime; // time since last score update\n        bool finalized; // true after event resolves and has stable scores\n    }\n    // EventId => EventDetails\n    mapping(uint256 => EventDetails) public events;\n    uint256[] public listOfEvents;\n\n    address public linkNode;\n    uint256 public sportId;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256 _stakerFee,\n        uint256 _settlementFee,\n        address _protocol,\n        uint256 _protocolFee,\n        address _linkNode,\n        uint256 _sportId\n    )\n        AbstractMarketFactoryV2(\n            _owner,\n            _collateral,\n            _shareFactor,\n            _feePot,\n            _stakerFee,\n            _settlementFee,\n            _protocol,\n            _protocolFee\n        )\n    {\n        linkNode = _linkNode;\n        sportId = _sportId;\n    }\n\n    function createMarket(\n        uint256 _eventId,\n        string memory _homeTeamName,\n        uint256 _homeTeamId,\n        string memory _awayTeamName,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256 _homeSpread,\n        uint256 _totalScore,\n        bool _makeSpread,\n        bool _makeTotalScore,\n        int256[2] memory _moneylines // [home,away]\n    ) public returns (uint256[3] memory _ids) {\n        require(msg.sender == linkNode, \"Only link node can create markets\");\n\n        uint256 _endTime = _startTimestamp.add(60 * 8); // 8 hours\n\n        _ids = events[_eventId].markets;\n\n        if (_ids[0] == 0 && _moneylines[0] != 0 && _moneylines[1] != 0) {\n            _ids[0] = createHeadToHeadMarket(\n                msg.sender,\n                _endTime,\n                _eventId,\n                _homeTeamName,\n                _homeTeamId,\n                _awayTeamName,\n                _awayTeamId,\n                _startTimestamp,\n                _moneylines\n            );\n        }\n\n        if (_ids[1] == 0 && _makeSpread) {\n            // spread market hasn't been created and is ready to be created\n            _ids[1] = createSpreadMarket(\n                msg.sender,\n                _endTime,\n                _eventId,\n                _homeTeamName,\n                _homeTeamId,\n                _awayTeamName,\n                _awayTeamId,\n                _startTimestamp,\n                _homeSpread\n            );\n        }\n\n        if (_ids[2] == 0 && _makeTotalScore) {\n            // over-under market hasn't been created and is ready to be created\n            _ids[2] = createOverUnderMarket(\n                msg.sender,\n                _endTime,\n                _eventId,\n                _homeTeamName,\n                _homeTeamId,\n                _awayTeamName,\n                _awayTeamId,\n                _startTimestamp,\n                _totalScore\n            );\n        }\n\n        events[_eventId].status = EventStatus.Scheduled;\n        events[_eventId].startTime = _startTimestamp;\n        events[_eventId].markets = _ids;\n        listOfEvents.push(_eventId);\n    }\n\n    function createHeadToHeadMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        string memory _homeTeamName,\n        uint256 _homeTeamId,\n        string memory _awayTeamName,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256[2] memory _moneylines // [home,away]\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(HeadToHeadOutcome.NoContest)] = \"No Contest / Draw\";\n        _outcomes[uint256(HeadToHeadOutcome.Away)] = _awayTeamName;\n        _outcomes[uint256(HeadToHeadOutcome.Home)] = _homeTeamName;\n\n        uint256 _id = markets.length;\n        // moneylines is [home,away] but the outcomes are listed [NC,away,home] so they must be reversed\n        markets.push(\n            makeMarket(_creator, _outcomes, _outcomes, _endTime, oddsFromLines(_moneylines[1], _moneylines[0]))\n        );\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamName,\n            _homeTeamId,\n            _awayTeamName,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.HeadToHead,\n            EventStatus.Scheduled,\n            0\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.HeadToHead,\n            _eventId,\n            _homeTeamName,\n            _homeTeamId,\n            _awayTeamName,\n            _awayTeamId,\n            _startTimestamp,\n            0\n        );\n        return _id;\n    }\n\n    function createSpreadMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        string memory _homeTeamName,\n        uint256 _homeTeamId,\n        string memory _awayTeamName,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256 _homeSpread\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(SpreadOutcome.NoContest)] = \"No Contest\";\n        _outcomes[uint256(SpreadOutcome.Away)] = _awayTeamName;\n        _outcomes[uint256(SpreadOutcome.Home)] = _homeTeamName;\n\n        // The spread is a quantity of tenths. So 55 is 5.5 and -6 is -60.\n        // If the spread is a whole number then make it a half point more extreme, to eliminate ties.\n        // So 50 becomes 55, -60 becomes -65, and 0 becomes 5.\n        if (_homeSpread >= 0 && _homeSpread % 10 == 0) {\n            _homeSpread += 5;\n        } else if (_homeSpread < 0 && (-_homeSpread) % 10 == 0) {\n            _homeSpread -= 5;\n        }\n\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime, evenOdds(true, 2)));\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamName,\n            _homeTeamId,\n            _awayTeamName,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.Spread,\n            EventStatus.Scheduled,\n            _homeSpread\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.Spread,\n            _eventId,\n            _homeTeamName,\n            _homeTeamId,\n            _awayTeamName,\n            _awayTeamId,\n            _startTimestamp,\n            _homeSpread\n        );\n        return _id;\n    }\n\n    function createOverUnderMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        string memory _homeTeamName,\n        uint256 _homeTeamId,\n        string memory _awayTeamName,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        uint256 _overUnderTotal\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(OverUnderOutcome.NoContest)] = \"No Contest\";\n        _outcomes[uint256(OverUnderOutcome.Over)] = \"Over\";\n        _outcomes[uint256(OverUnderOutcome.Under)] = \"Under\";\n\n        // The total is a quantity of tenths. So 55 is 5.5 and -6 is -60.\n        // If the total is a whole number then make it a half point higher, to eliminate ties.\n        // So 50 becomes 55 and 0 becomes 5.\n        if (_overUnderTotal >= 0 && _overUnderTotal % 10 == 0) {\n            _overUnderTotal += 5;\n        }\n\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime, evenOdds(true, 2)));\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamName,\n            _homeTeamId,\n            _awayTeamName,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.OverUnder,\n            EventStatus.Scheduled,\n            int256(_overUnderTotal)\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.OverUnder,\n            _eventId,\n            _homeTeamName,\n            _homeTeamId,\n            _awayTeamName,\n            _awayTeamId,\n            _startTimestamp,\n            int256(_overUnderTotal)\n        );\n        return _id;\n    }\n\n    function resolveMarket(uint256) public pure override {\n        require(false, \"Only the link node can resolve the market, using trustedResolveMarkets\");\n    }\n\n    function trustedResolveMarkets(\n        uint256 _eventId,\n        uint256 _eventStatus,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) public {\n        require(msg.sender == linkNode, \"Only link node can resolve markets\");\n\n        EventDetails storage _event = events[_eventId];\n        uint256[3] memory _ids = _event.markets;\n\n        require(_ids[0] != 0 || _ids[1] != 0 || _ids[2] != 0, \"Cannot resolve markets that weren't created\");\n\n        require(EventStatus(_eventStatus) != EventStatus.Scheduled, \"cannot resolve SCHEDULED markets\");\n\n        // resolve markets as No Contest\n        if (EventStatus(_eventStatus) != EventStatus.Final) {\n            for (uint256 i = 0; i < _ids.length; i++) {\n                uint256 _id = _ids[i];\n                if (_id == 0) continue; // skip non-created markets\n                OwnedERC20 _winner = markets[_id].shareTokens[0]; // 0th outcome is No Contest for all market types\n                markets[_id].winner = _winner;\n                emit MarketResolved(_id, address(_winner));\n            }\n            return;\n        }\n\n        // only resolve markets that were created\n        if (_ids[0] != 0) {\n            resolveHeadToHeadMarket(_ids[0], _homeScore, _awayScore);\n        }\n        if (_ids[1] != 0) {\n            resolveSpreadMarket(_ids[1], _homeScore, _awayScore);\n        }\n        if (_ids[2] != 0) {\n            resolveOverUnderMarket(_ids[2], _homeScore, _awayScore);\n        }\n    }\n\n    function resolveHeadToHeadMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        OwnedERC20 _winner;\n        if (_homeScore > _awayScore) {\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.Home)]; // home team won\n        } else if (_homeScore < _awayScore) {\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.Away)]; // away team won\n        } else {\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.NoContest)]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function resolveSpreadMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        MarketDetails memory _details = marketDetails[_id];\n        int256 _targetSpread = _details.value0;\n\n        int256 _actualSpread = int256(_homeScore).sub(int256(_awayScore));\n\n        OwnedERC20 _winner;\n        if (_actualSpread > _targetSpread) {\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.Home)]; // home spread greater\n        } else if (_actualSpread < _targetSpread) {\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.Away)]; // home spread lesser\n        } else {\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.NoContest)]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function resolveOverUnderMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        MarketDetails memory _details = marketDetails[_id];\n        int256 _targetTotal = _details.value0;\n\n        int256 _actualTotal = int256(_homeScore).add(int256(_awayScore));\n\n        OwnedERC20 _winner;\n        if (_actualTotal > _targetTotal) {\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.Over)]; // over\n        } else if (_actualTotal < _targetTotal) {\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.Under)]; // under\n        } else {\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.NoContest)]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function getMarketDetails(uint256 _marketId) public view returns (MarketDetails memory) {\n        return marketDetails[_marketId];\n    }\n\n    function setLinkNode(address _newLinkNode) external onlyOwner {\n        linkNode = _newLinkNode;\n        emit LinkNodeChanged(_newLinkNode);\n    }\n\n    function getEventMarkets(uint256 _eventId) external view returns (uint256[3] memory) {\n        uint256[3] memory _event = events[_eventId].markets;\n        return _event;\n    }\n\n    // Events can be partially registered, by only creating some markets.\n    // This returns true only if an event is fully registered.\n    function isEventRegistered(uint256 _eventId) public view returns (bool) {\n        uint256[3] memory _event = events[_eventId].markets;\n        return _event[0] != 0 && _event[1] != 0 && _event[2] != 0;\n    }\n\n    function isEventResolved(uint256 _eventId) public view returns (bool) {\n        // check the event's head-to-head market since it will always exist if the event's markets exist\n        uint256 _marketId = events[_eventId].markets[0];\n        return isMarketResolved(_marketId);\n    }\n\n    // Only usable off-chain. Gas cost can easily eclipse block limit.\n    // Lists all events that could be resolved with a call to resolveEvent.\n    // Not all will be resolvable because this does not ensure the game ended.\n    function listResolvableEvents() external view returns (uint256[] memory) {\n        uint256 _totalResolvable = countResolvableEvents();\n        uint256[] memory _resolvableEvents = new uint256[](_totalResolvable);\n\n        uint256 n = 0;\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\n            if (n > _totalResolvable) break;\n            uint256 _eventId = listOfEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _resolvableEvents[n] = _eventId;\n                n++;\n            }\n        }\n\n        return _resolvableEvents;\n    }\n\n    function countResolvableEvents() internal view returns (uint256) {\n        uint256 _totalResolvable = 0;\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\n            uint256 _eventId = listOfEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _totalResolvable++;\n            }\n        }\n        return _totalResolvable;\n    }\n\n    // Returns true if a call to resolveEvent is potentially useful.\n    function isEventResolvable(uint256 _eventId) internal view returns (bool) {\n        EventDetails memory _event = events[_eventId];\n\n        bool _unresolved = false; // default because non-existing markets aren't resolvable\n        for (uint256 i = 0; i < _event.markets.length; i++) {\n            uint256 _marketId = _event.markets[i];\n            if (_marketId != 0 && !isMarketResolved(_marketId)) {\n                _unresolved = true;\n                break;\n            }\n        }\n\n        return _unresolved;\n    }\n}\n"
    },
    "contracts/turbo/NFLMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"./FeePot.sol\";\nimport \"../libraries/SafeMathInt256.sol\";\nimport \"../libraries/Sport.sol\";\nimport \"../libraries/HasHeadToHeadMarket.sol\";\nimport \"../libraries/HasSpreadMarket.sol\";\nimport \"../libraries/HasOverUnderMarket.sol\";\nimport \"../libraries/ResolveByScore.sol\";\nimport \"../libraries/Versioned.sol\";\n\n// NFL is standard except ties are fine: they become NoContestOrDraw.\n// As a consequence, half points are not added to the lines.\ncontract NFLMarketFactory is\n    AbstractMarketFactoryV3,\n    SportView,\n    HasHeadToHeadMarket,\n    HasSpreadMarket,\n    HasOverUnderMarket,\n    ResolvesByScore,\n    Versioned\n{\n    using SafeMathUint256 for uint256;\n    using SafeMathInt256 for int256;\n\n    uint256 constant HeadToHead = 0;\n    uint256 constant Spread = 1;\n    uint256 constant OverUnder = 2;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256[3] memory _fees,\n        address _protocol,\n        address _linkNode\n    )\n        AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol)\n        Versioned(\"v1.2.0\")\n        ManagedByLink(_linkNode)\n        HasHeadToHeadMarket(HeadToHead, \"No Contest / Draw\")\n        HasSpreadMarket(Spread, \"No Contest\")\n        HasOverUnderMarket(OverUnder, \"No Contest\")\n    {}\n\n    function createEvent(\n        uint256 _eventId,\n        string memory _homeTeamName,\n        uint256 _homeTeamId,\n        string memory _awayTeamName,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256 _homeSpread,\n        int256 _totalScore,\n        int256[2] memory _moneylines // [home,away]\n    ) public onlyLinkNode returns (uint256[] memory _marketIds) {\n        // Cannot create markets for an event twice.\n        require(sportsEvents[_eventId].status == SportsEventStatus.Unknown);\n\n        _marketIds = makeMarkets(_moneylines, _homeTeamName, _awayTeamName);\n        makeSportsEvent(\n            _eventId,\n            _marketIds,\n            build3Lines(_homeSpread, _totalScore),\n            _startTimestamp,\n            _homeTeamId,\n            _awayTeamId,\n            _homeTeamName,\n            _awayTeamName\n        );\n    }\n\n    function makeMarkets(\n        int256[2] memory _moneylines,\n        string memory _homeTeamName,\n        string memory _awayTeamName\n    ) internal returns (uint256[] memory _marketIds) {\n        _marketIds = new uint256[](3);\n\n        _marketIds[HeadToHead] = makeHeadToHeadMarket(_moneylines, _homeTeamName, _awayTeamName);\n        _marketIds[Spread] = makeSpreadMarket(_homeTeamName, _awayTeamName);\n        _marketIds[OverUnder] = makeOverUnderMarket();\n    }\n\n    function resolveValidEvent(\n        SportsEvent memory _event,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal override {\n        resolveHeadToHeadMarket(_event.markets[HeadToHead], _homeScore, _awayScore);\n        resolveSpreadMarket(_event.markets[Spread], _event.lines[Spread], _homeScore, _awayScore);\n        resolveOverUnderMarket(_event.markets[OverUnder], _event.lines[Spread], _homeScore, _awayScore);\n    }\n}\n"
    },
    "contracts/turbo/TrustedMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\nimport \"../libraries/Versioned.sol\";\n\ncontract TrustedMarketFactory is AbstractMarketFactoryV3, CalculateLinesToBPoolOdds, Versioned {\n    using SafeMathUint256 for uint256;\n\n    struct MarketDetails {\n        string description;\n    }\n    MarketDetails[] internal marketDetails;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256[3] memory _fees,\n        address _protocol\n    ) AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol) Versioned(\"v1.1.0\") {}\n\n    function createMarket(\n        address _creator,\n        string calldata _description,\n        string[] calldata _names,\n        uint256[] calldata _odds\n    ) public onlyOwner returns (uint256) {\n        marketDetails.push(MarketDetails(_description));\n        return startMarket(_creator, _names, _odds, true);\n    }\n\n    function trustedResolveMarket(uint256 _id, uint256 _winningOutcome) public onlyOwner {\n        endMarket(_id, _winningOutcome);\n    }\n\n    function getMarketDetails(uint256 _id) public view returns (MarketDetails memory) {\n        return marketDetails[_id];\n    }\n}\n"
    },
    "contracts/turbo/NCAAFBMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"./FeePot.sol\";\nimport \"../libraries/SafeMathInt256.sol\";\nimport \"../libraries/Sport.sol\";\nimport \"../libraries/HasHeadToHeadMarket.sol\";\nimport \"../libraries/HasSpreadMarket.sol\";\nimport \"../libraries/HasOverUnderMarket.sol\";\nimport \"../libraries/ResolveByScore.sol\";\nimport \"../libraries/Versioned.sol\";\n\n// NCAA-FB is identical to NFL except there are no ties.\n// As a consequence, spread and over-under lines add a half-point,\n// and the invalid outcome is just No Contest.\ncontract NCAAFBMarketFactory is\n    AbstractMarketFactoryV3,\n    SportView,\n    HasHeadToHeadMarket,\n    HasSpreadMarket,\n    HasOverUnderMarket,\n    ResolvesByScore,\n    Versioned\n{\n    using SafeMathUint256 for uint256;\n    using SafeMathInt256 for int256;\n\n    uint256 constant HeadToHead = 0;\n    uint256 constant Spread = 1;\n    uint256 constant OverUnder = 2;\n    string constant InvalidName = \"No Contest\";\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256[3] memory _fees,\n        address _protocol,\n        address _linkNode\n    )\n        AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol)\n        Versioned(\"v1.2.0\")\n        ManagedByLink(_linkNode)\n        HasHeadToHeadMarket(HeadToHead, InvalidName)\n        HasSpreadMarket(Spread, InvalidName)\n        HasOverUnderMarket(OverUnder, InvalidName)\n    {}\n\n    function createEvent(\n        uint256 _eventId,\n        string memory _homeTeamName,\n        uint256 _homeTeamId,\n        string memory _awayTeamName,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256 _homeSpread,\n        int256 _totalScore,\n        int256[2] memory _moneylines // [home,away]\n    ) public onlyLinkNode returns (uint256[] memory _marketIds) {\n        // Cannot create markets for an event twice.\n        require(sportsEvents[_eventId].status == SportsEventStatus.Unknown);\n\n        _marketIds = makeMarkets(_moneylines, _homeTeamName, _awayTeamName);\n        makeSportsEvent(\n            _eventId,\n            _marketIds,\n            build3Lines(_homeSpread, _totalScore),\n            _startTimestamp,\n            _homeTeamId,\n            _awayTeamId,\n            _homeTeamName,\n            _awayTeamName\n        );\n    }\n\n    function makeMarkets(\n        int256[2] memory _moneylines,\n        string memory _homeTeamName,\n        string memory _awayTeamName\n    ) internal returns (uint256[] memory _marketIds) {\n        _marketIds = new uint256[](3);\n\n        _marketIds[HeadToHead] = makeHeadToHeadMarket(_moneylines, _homeTeamName, _awayTeamName);\n        _marketIds[Spread] = makeSpreadMarket(_homeTeamName, _awayTeamName);\n        _marketIds[OverUnder] = makeOverUnderMarket();\n    }\n\n    function resolveValidEvent(\n        SportsEvent memory _event,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal override {\n        resolveHeadToHeadMarket(_event.markets[HeadToHead], _homeScore, _awayScore);\n        resolveSpreadMarket(_event.markets[Spread], _event.lines[Spread], _homeScore, _awayScore);\n        resolveOverUnderMarket(_event.markets[OverUnder], _event.lines[OverUnder], _homeScore, _awayScore);\n    }\n}\n"
    },
    "contracts/turbo/MLBMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"./FeePot.sol\";\nimport \"../libraries/SafeMathInt256.sol\";\nimport \"../libraries/Sport.sol\";\nimport \"../libraries/HasHeadToHeadMarket.sol\";\nimport \"../libraries/ResolveByScore.sol\";\nimport \"../libraries/Versioned.sol\";\n\ncontract MLBMarketFactory is AbstractMarketFactoryV3, SportView, HasHeadToHeadMarket, ResolvesByScore, Versioned {\n    using SafeMathUint256 for uint256;\n    using SafeMathInt256 for int256;\n\n    uint256 constant HeadToHead = 0;\n    string constant InvalidName = \"No Contest\";\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256[3] memory _fees,\n        address _protocol,\n        address _linkNode\n    )\n        AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol)\n        Versioned(\"v1.2.0\")\n        ManagedByLink(_linkNode)\n        HasHeadToHeadMarket(HeadToHead, InvalidName)\n    {}\n\n    function createEvent(\n        uint256 _eventId,\n        string memory _homeTeamName,\n        uint256 _homeTeamId,\n        string memory _awayTeamName,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256[2] memory _moneylines // [home,away]\n    ) public onlyLinkNode returns (uint256[] memory _marketIds) {\n        // Cannot create markets for an event twice.\n        require(sportsEvents[_eventId].status == SportsEventStatus.Unknown);\n\n        _marketIds = makeMarkets(_moneylines, _homeTeamName, _awayTeamName);\n        makeSportsEvent(\n            _eventId,\n            _marketIds,\n            build1Line(),\n            _startTimestamp,\n            _homeTeamId,\n            _awayTeamId,\n            _homeTeamName,\n            _awayTeamName\n        );\n    }\n\n    function makeMarkets(\n        int256[2] memory _moneylines,\n        string memory _homeTeamName,\n        string memory _awayTeamName\n    ) internal returns (uint256[] memory _marketIds) {\n        _marketIds = new uint256[](1);\n        _marketIds[HeadToHead] = makeHeadToHeadMarket(_moneylines, _homeTeamName, _awayTeamName);\n    }\n\n    function resolveValidEvent(\n        SportsEvent memory _event,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal override {\n        resolveHeadToHeadMarket(_event.markets[HeadToHead], _homeScore, _awayScore);\n    }\n}\n"
    },
    "contracts/turbo/FuturesMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./AbstractMarketFactoryV3.sol\";\nimport \"./FeePot.sol\";\nimport \"../libraries/SafeMathInt256.sol\";\nimport \"./Grouped.sol\";\nimport \"../libraries/ManagedByLink.sol\";\nimport \"../libraries/Versioned.sol\";\n\ncontract FuturesMarketFactory is AbstractMarketFactoryV3, Grouped, ManagedByLink, Versioned {\n    using SafeMathUint256 for uint256;\n    using SafeMathInt256 for int256;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256[3] memory _fees,\n        address _protocol,\n        address _linkNode\n    )\n        AbstractMarketFactoryV3(_owner, _collateral, _shareFactor, _feePot, _fees, _protocol)\n        Versioned(\"v1.2.0\")\n        ManagedByLink(_linkNode)\n    {}\n\n    function initializeGroup(\n        uint256 _groupId,\n        string memory _groupName,\n        string memory _invalidMarketName,\n        uint256 _endTime,\n        string memory _category\n    ) public onlyLinkNode {\n        require(marketGroups[_groupId].status == GroupStatus.Unknown);\n        startCreatingMarketGroup(_groupId, _groupName, _endTime, _invalidMarketName, _category);\n    }\n\n    function addOutcomesToGroup(\n        uint256 _groupId,\n        string[] memory _marketNames,\n        uint256[][] memory _odds\n    ) public onlyLinkNode {\n        require(marketGroups[_groupId].status == GroupStatus.BeingCreated);\n        require(_marketNames.length == _odds.length);\n\n        for (uint256 i = 0; i < _marketNames.length; i++) {\n            addMarketToMarketGroup(_groupId, _marketNames[i], _odds[i]);\n        }\n    }\n\n    function finalizeGroup(uint256 _groupId) public onlyLinkNode {\n        finalizeMarketGroup(_groupId);\n    }\n\n    // Set _winner to MAX_UINT (2*256 - 1) to indicate invalid\n    function resolveGroup(uint256 _groupId, uint256 _winningMarketIndex) public onlyLinkNode {\n        MarketGroup memory _group = marketGroups[_groupId];\n\n        // Group must be exist and be scheduled.\n        require(_group.status == GroupStatus.Scheduled);\n\n        resolveMarketGroup(_groupId, _winningMarketIndex);\n    }\n\n    // Used when some markets in a group can resolve early as NO.\n    // ex: Teams eliminated early from a tournament cannot win the overall tournament.\n    function resolveMarketAsNo(uint256 _marketId) public onlyLinkNode {\n        require(markets[_marketId].active, \"market inactive\");\n        resolveGroupMarket(_marketId, false);\n    }\n}\n"
    },
    "contracts/turbo/CryptoMarketFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV2.sol\";\nimport \"./FeePot.sol\";\nimport \"../libraries/SafeMathInt256.sol\";\n\nimport \"@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol\";\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\n\ncontract CryptoMarketFactoryV2 is AbstractMarketFactoryV2, CalculateLinesToBPoolOdds {\n    using SafeMathUint256 for uint256;\n    using SafeMathInt256 for int256;\n\n    event MarketCreated(\n        uint256 id,\n        address creator,\n        uint256 indexed endTime,\n        MarketType marketType,\n        uint256 indexed coinIndex,\n        uint256 price\n    );\n    event MarketResolved(uint256 id, address winner);\n\n    struct Coin {\n        string name;\n        AggregatorV3Interface priceFeed;\n        uint256 price;\n        uint8 imprecision; // how many decimals to truncate\n        uint256[1] currentMarkets;\n    }\n    Coin[] public coins;\n\n    enum MarketType {\n        PriceUpDown // 0\n    }\n    enum PriceUpDownOutcome {\n        Above, // 0\n        NotAbove // 1\n    }\n    struct MarketDetails {\n        MarketType marketType;\n        uint256 coinIndex;\n        uint256 creationPrice;\n        uint256 resolutionPrice;\n    }\n    // MarketId => MarketDetails\n    mapping(uint256 => MarketDetails) internal marketDetails;\n\n    address public linkNode; // market creator and resolver\n\n    uint256 public nextResolutionTime;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256 _stakerFee,\n        uint256 _settlementFee,\n        address _protocol,\n        uint256 _protocolFee,\n        address _linkNode\n    )\n        AbstractMarketFactoryV2(\n            _owner,\n            _collateral,\n            _shareFactor,\n            _feePot,\n            _stakerFee,\n            _settlementFee,\n            _protocol,\n            _protocolFee\n        )\n    {\n        linkNode = _linkNode;\n\n        string memory _name = \"\";\n        coins.push(makeCoin(_name, AggregatorV3Interface(0), 0));\n    }\n\n    function getMarketDetails(uint256 _marketId) public view returns (MarketDetails memory) {\n        return marketDetails[_marketId];\n    }\n\n    // NOTE: Trusts the owner not to add a coin twice.\n    // Returns the coin index.\n    function addCoin(\n        string calldata _name,\n        AggregatorV3Interface _priceFeed,\n        uint8 _imprecision\n    ) external onlyOwner returns (uint256 _coinIndex) {\n        Coin memory _coin = makeCoin(_name, _priceFeed, _imprecision);\n        _coinIndex = coins.length;\n        coins.push(_coin);\n    }\n\n    function getCoin(uint256 _coinIndex) public view returns (Coin memory _coin) {\n        _coin = coins[_coinIndex];\n    }\n\n    function getCoins() public view returns (Coin[] memory _coins) {\n        _coins = new Coin[](coins.length);\n        // Skip first coin because it's always the zeroed-out fake coin.\n        for (uint256 i = 1; i < coins.length; i++) {\n            _coins[i] = coins[i];\n        }\n    }\n\n    // Iterates over all coins.\n    // If markets do not exist for coin, create them.\n    // Unless _nextResolutionTime is zero; then do not create new markets.\n    // If markets for coin exist and are ready to resolve, resolve them and create new markets.\n    // Else, error.\n    //\n    // Assume that _roundIds has a dummy value at index 0, and is 1 indexed like the\n    // coins array.\n    function createAndResolveMarkets(uint80[] calldata _roundIds, uint256 _nextResolutionTime) public {\n        require(msg.sender == linkNode, \"Only link node can create markets\");\n        // If market creation was stopped then it can be started again.\n        // If market creation wasn't stopped then you must wait for market end time to resolve.\n        require(block.timestamp >= nextResolutionTime, \"Must wait for market resolution\");\n        require(_roundIds.length == coins.length, \"Must specify one roundId for each coin\");\n\n        uint256 _resolutionTime = nextResolutionTime;\n        nextResolutionTime = _nextResolutionTime;\n\n        // Start at 1 to skip the fake Coin in the 0 index\n        for (uint256 i = 1; i < coins.length; i++) {\n            createAndResolveMarketsForCoin(i, _resolutionTime, _roundIds[i]);\n        }\n    }\n\n    function createAndResolveMarketsForCoin(\n        uint256 _coinIndex,\n        uint256 _resolutionTime,\n        uint80 _roundId\n    ) internal {\n        Coin memory _coin = coins[_coinIndex];\n        (uint256 _fullPrice, uint256 _newPrice) = getPrice(_coin, _roundId, _resolutionTime);\n\n        // resolve markets\n        if (_coin.currentMarkets[uint256(MarketType.PriceUpDown)] != 0) {\n            resolvePriceUpDownMarket(_coin, _newPrice, _fullPrice);\n        }\n\n        // update price only AFTER resolution\n        coins[_coinIndex].price = _newPrice;\n\n        // link node sets nextResolutionTime to zero to signify \"do not create markets after resolution\"\n        if (nextResolutionTime == 0) {\n            return;\n        }\n\n        // create markets\n        coins[_coinIndex].currentMarkets[uint256(MarketType.PriceUpDown)] = createPriceUpDownMarket(\n            _coinIndex,\n            linkNode,\n            _newPrice\n        );\n    }\n\n    function resolvePriceUpDownMarket(\n        Coin memory _coin,\n        uint256 _newPrice,\n        uint256 _fullPrice\n    ) internal {\n        uint256 _marketId = _coin.currentMarkets[uint256(MarketType.PriceUpDown)];\n\n        OwnedERC20 _winner;\n        if (_newPrice > _coin.price) {\n            _winner = markets[_marketId].shareTokens[uint256(PriceUpDownOutcome.Above)];\n        } else {\n            _winner = markets[_marketId].shareTokens[uint256(PriceUpDownOutcome.NotAbove)];\n        }\n\n        markets[_marketId].winner = _winner;\n        marketDetails[_marketId].resolutionPrice = _fullPrice;\n        emit MarketResolved(_marketId, address(_winner));\n    }\n\n    function createPriceUpDownMarket(\n        uint256 _coinIndex,\n        address _creator,\n        uint256 _newPrice\n    ) internal returns (uint256 _id) {\n        string[] memory _outcomes = new string[](2);\n        _outcomes[uint256(PriceUpDownOutcome.Above)] = \"Above\";\n        _outcomes[uint256(PriceUpDownOutcome.NotAbove)] = \"Not Above\";\n\n        uint256 _nextResolutionTime = nextResolutionTime;\n        _id = markets.length;\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _nextResolutionTime, evenOdds(false, 2)));\n        marketDetails[_id] = MarketDetails(MarketType.PriceUpDown, _coinIndex, _newPrice, 0);\n        emit MarketCreated(_id, _creator, _nextResolutionTime, MarketType.PriceUpDown, _coinIndex, _newPrice);\n    }\n\n    // Returns the price based on a few factors.\n    // If _roundId is zero then it returns the latest price.\n    // Else, it returns the price for that round,\n    //       but errors if that isn't the first round after the resolution time.\n    // The price is then altered to match the desired precision.\n    function getPrice(\n        Coin memory _coin,\n        uint80 _roundId,\n        uint256 _resolutionTime\n    ) internal view returns (uint256 _fullPrice, uint256 _truncatedPrice) {\n        if (_roundId == 0) {\n            (, int256 _rawPrice, , , ) = _coin.priceFeed.latestRoundData();\n            require(_rawPrice >= 0, \"Price from feed is negative\");\n            _fullPrice = uint256(_rawPrice);\n        } else {\n            (, int256 _rawPrice, , uint256 updatedAt, ) = _coin.priceFeed.getRoundData(_roundId);\n            require(_rawPrice >= 0, \"Price from feed is negative\");\n            require(updatedAt >= _resolutionTime, \"Price hasn't been updated yet\");\n\n            // if resolution time is zero then market creation was stopped, so the previous round doesn't matter\n            if (_resolutionTime != 0) {\n                (, , , uint256 _previousRoundTime, ) = _coin.priceFeed.getRoundData(previousRound(_roundId));\n                require(_previousRoundTime < _resolutionTime, \"Must use first round after resolution time\");\n            }\n\n            _fullPrice = uint256(_rawPrice);\n        }\n\n        // The precision is how many decimals the price has. Zero is dollars, 2 includes cents, 3 is tenths of a cent, etc.\n        // Our resolution rules want a certain precision. Like BTC is to the dollar and MATIC is to the cent.\n        // If somehow the decimals are larger than the desired precision then add zeroes to the end to meet the precision.\n        // This does not change the resolution outcome but does guard against decimals() changing and therefore altering the basis.\n\n        uint8 _precision = _coin.priceFeed.decimals(); // probably constant but that isn't guaranteed, so query each time\n        if (_precision > _coin.imprecision) {\n            uint8 _truncate = _precision - _coin.imprecision;\n            _truncatedPrice = _fullPrice / (10**_truncate);\n        } else if (_precision < _coin.imprecision) {\n            uint8 _greaten = _coin.imprecision - _precision;\n            _truncatedPrice = _fullPrice * (10**_greaten);\n        } else {\n            _truncatedPrice = _fullPrice;\n        }\n\n        // Round up because that cleanly fits Above/Not-Above.\n        if (_truncatedPrice != _fullPrice) {\n            _truncatedPrice += 1;\n        }\n    }\n\n    function makeCoin(\n        string memory _name,\n        AggregatorV3Interface _priceFeed,\n        uint8 _imprecision\n    ) internal pure returns (Coin memory _coin) {\n        uint256[1] memory _currentMarkets = [uint256(0)];\n        _coin = Coin(_name, _priceFeed, 0, _imprecision, _currentMarkets);\n    }\n\n    function resolveMarket(uint256) public pure override {\n        require(false, \"Use createAndResolveMarkets\");\n    }\n\n    // The roundId is the encoding of two parts: the phase and the phase-specific round id.\n    // To find the previous roundId:\n    // 1. extract the phase and phase-specific round (I call these _phaseId and _roundId)\n    // 2. decrement the phase-specific round\n    // 3. re-encode the phase and phase-specific round.\n    uint256 private constant PHASE_OFFSET = 64;\n\n    function previousRound(uint80 _fullRoundId) internal pure returns (uint80) {\n        uint256 _phaseId = uint256(uint16(_fullRoundId >> PHASE_OFFSET));\n        uint64 _roundId = uint64(_fullRoundId) - 1;\n        return uint80((_phaseId << PHASE_OFFSET) | _roundId);\n    }\n}\n"
    },
    "contracts/turbo/MMALinkMarketFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactoryV2.sol\";\nimport \"./FeePot.sol\";\nimport \"../libraries/SafeMathInt256.sol\";\nimport \"../libraries/CalculateLinesToBPoolOdds.sol\";\n\ncontract MMALinkMarketFactoryV2 is AbstractMarketFactoryV2, CalculateLinesToBPoolOdds {\n    using SafeMathUint256 for uint256;\n    using SafeMathInt256 for int256;\n\n    event MarketCreated(\n        uint256 id,\n        address creator,\n        uint256 endTime,\n        MarketType marketType,\n        uint256 indexed eventId,\n        string homeFighterName,\n        uint256 homeFighterId,\n        string awayFighterName,\n        uint256 awayFighterId,\n        uint256 estimatedStartTime\n    );\n    event MarketResolved(uint256 id, address winner);\n    event LinkNodeChanged(address newLinkNode);\n\n    enum MarketType {HeadToHead}\n    enum HeadToHeadOutcome {\n        NoContest, // 0\n        Away, // 1\n        Home // 2\n    }\n\n    struct MarketDetails {\n        uint256 eventId;\n        string homeFighterName;\n        uint256 homeFighterId;\n        string awayFighterName;\n        uint256 awayFighterId;\n        uint256 estimatedStartTime;\n        MarketType marketType;\n        EventStatus eventStatus;\n    }\n    // MarketId => MarketDetails\n    mapping(uint256 => MarketDetails) internal marketDetails;\n\n    enum EventStatus {Unknown, Scheduled, Final, Postponed, Canceled}\n    struct EventDetails {\n        uint256[1] markets;\n        uint256 homeFighterId;\n        uint256 awayFighterId;\n        uint256 startTime;\n        EventStatus eventStatus;\n    }\n\n    // EventId => EventDetails\n    mapping(uint256 => EventDetails) public events;\n    uint256[] public listOfEvents;\n\n    address public linkNode;\n    uint256 public sportId;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256 _stakerFee,\n        uint256 _settlementFee,\n        address _protocol,\n        uint256 _protocolFee,\n        address _linkNode,\n        uint256 _sportId\n    )\n        AbstractMarketFactoryV2(\n            _owner,\n            _collateral,\n            _shareFactor,\n            _feePot,\n            _stakerFee,\n            _settlementFee,\n            _protocol,\n            _protocolFee\n        )\n    {\n        linkNode = _linkNode;\n        sportId = _sportId;\n    }\n\n    function createMarket(\n        uint256 _eventId,\n        string memory _homeFighterName,\n        uint256 _homeFighterId,\n        string memory _awayFighterName,\n        uint256 _awayFighterId,\n        uint256 _startTimestamp,\n        int256[2] memory _moneylines // [home,away]\n    ) public {\n        require(msg.sender == linkNode, \"Only link node can create markets\");\n\n        address _creator = msg.sender;\n        uint256 _endTime = _startTimestamp.add(60 * 8); // 8 hours\n\n        uint256[1] memory _ids = events[_eventId].markets;\n        // require(_ids[0] == 0, \"This event was already used to create markets\");\n\n        _ids[0] = createHeadToHeadMarket(\n            _creator,\n            _endTime,\n            _eventId,\n            _homeFighterName,\n            _homeFighterId,\n            _awayFighterName,\n            _awayFighterId,\n            _startTimestamp,\n            _moneylines\n        );\n\n        events[_eventId].markets = _ids;\n        events[_eventId].homeFighterId = _homeFighterId;\n        events[_eventId].awayFighterId = _awayFighterId;\n        events[_eventId].startTime = _startTimestamp;\n        events[_eventId].eventStatus = EventStatus.Scheduled;\n        listOfEvents.push(_eventId);\n    }\n\n    function createHeadToHeadMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        string memory _homeTeamName,\n        uint256 _homeFighterId,\n        string memory _awayTeamName,\n        uint256 _awayFighterId,\n        uint256 _startTimestamp,\n        int256[2] memory _moneylines // [home,away]\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(HeadToHeadOutcome.NoContest)] = \"No Contest\";\n        _outcomes[uint256(HeadToHeadOutcome.Away)] = _awayTeamName;\n        _outcomes[uint256(HeadToHeadOutcome.Home)] = _homeTeamName;\n\n        uint256 _id = markets.length;\n        // moneylines is [home,away] but the outcomes are listed [NC,away,home] so they must be reversed\n        markets.push(\n            makeMarket(_creator, _outcomes, _outcomes, _endTime, oddsFromLines(_moneylines[1], _moneylines[0]))\n        );\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamName,\n            _homeFighterId,\n            _awayTeamName,\n            _awayFighterId,\n            _startTimestamp,\n            MarketType.HeadToHead,\n            EventStatus.Scheduled\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.HeadToHead,\n            _eventId,\n            _homeTeamName,\n            _homeFighterId,\n            _awayTeamName,\n            _awayFighterId,\n            _startTimestamp\n        );\n        return _id;\n    }\n\n    enum WhoWon {Unknown, Home, Away, Draw}\n\n    function trustedResolveMarkets(\n        uint256 _eventId,\n        EventStatus _eventStatus,\n        uint256 _homeFighterId,\n        uint256 _awayFighterId,\n        WhoWon _whoWon\n    ) public {\n        require(msg.sender == linkNode, \"Only link node can resolve markets\");\n\n        EventDetails memory _event = events[_eventId];\n        require(_event.markets[0] != 0, \"Cannot resolve markets that weren't created\");\n        require(EventStatus(_eventStatus) != EventStatus.Scheduled, \"Cannot resolve SCHEDULED markets\");\n\n        if (eventIsNoContest(_event, _eventStatus, _homeFighterId, _awayFighterId, _whoWon)) {\n            resolveMarketsAsNoContest(_eventId);\n        } else {\n            resolveHeadToHeadMarket(_event.markets[0], _whoWon);\n        }\n\n        events[_eventId].eventStatus = _eventStatus;\n    }\n\n    function eventIsNoContest(\n        EventDetails memory _event,\n        EventStatus _eventStatus,\n        uint256 _homeFighterId,\n        uint256 _awayFighterId,\n        WhoWon _whoWon\n    ) internal pure returns (bool) {\n        bool _draw = _whoWon == WhoWon.Draw;\n        bool _notFinal = _eventStatus != EventStatus.Final;\n        bool _unstableHomeFighterId = _event.homeFighterId != _homeFighterId;\n        bool _unstableAwayFighterId = _event.awayFighterId != _awayFighterId;\n        return _draw || _notFinal || _unstableHomeFighterId || _unstableAwayFighterId;\n    }\n\n    function resolveMarketsAsNoContest(uint256 _eventId) internal {\n        uint256[1] memory _marketIds = events[_eventId].markets;\n        for (uint256 i = 0; i < _marketIds.length; i++) {\n            uint256 _marketId = _marketIds[i];\n            if (_marketId == 0) continue; // skip non-created markets\n            OwnedERC20 _winner = markets[_marketId].shareTokens[0]; // 0th outcome is No Contest for all market types\n            markets[_marketId].winner = _winner;\n            emit MarketResolved(_marketId, address(_winner));\n        }\n    }\n\n    function resolveHeadToHeadMarket(uint256 _marketId, WhoWon _whoWon) internal {\n        OwnedERC20 _winner;\n        if (WhoWon.Home == _whoWon) {\n            _winner = markets[_marketId].shareTokens[uint256(HeadToHeadOutcome.Home)];\n        } else if (WhoWon.Away == _whoWon) {\n            _winner = markets[_marketId].shareTokens[uint256(HeadToHeadOutcome.Away)];\n        } else {\n            require(false, \"Bad market resolution choice\");\n        }\n\n        markets[_marketId].winner = _winner;\n        emit MarketResolved(_marketId, address(_winner));\n    }\n\n    function getMarketDetails(uint256 _marketId) public view returns (MarketDetails memory) {\n        return marketDetails[_marketId];\n    }\n\n    // Only usable off-chain. Gas cost can easily eclipse block limit.\n    // Lists all events that could be resolved with a call to resolveEvent.\n    // Not all will be resolvable because this does not ensure the game ended.\n    function listResolvableEvents() external view returns (uint256[] memory) {\n        uint256 _totalResolvable = countResolvableEvents();\n        uint256[] memory _resolvableEvents = new uint256[](_totalResolvable);\n\n        uint256 n = 0;\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\n            if (n > _totalResolvable) break;\n            uint256 _eventId = listOfEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _resolvableEvents[n] = _eventId;\n                n++;\n            }\n        }\n\n        return _resolvableEvents;\n    }\n\n    function countResolvableEvents() internal view returns (uint256) {\n        uint256 _totalResolvable = 0;\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\n            uint256 _eventId = listOfEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _totalResolvable++;\n            }\n        }\n        return _totalResolvable;\n    }\n\n    // Returns true if a call to resolveEvent is potentially useful.\n    function isEventResolvable(uint256 _eventId) internal view returns (bool) {\n        EventDetails memory _event = events[_eventId];\n\n        bool _unresolved = false; // default because non-existing markets aren't resolvable\n        for (uint256 i = 0; i < _event.markets.length; i++) {\n            uint256 _marketId = _event.markets[i];\n            if (_marketId != 0 && !isMarketResolved(_marketId)) {\n                _unresolved = true;\n                break;\n            }\n        }\n\n        return _unresolved;\n    }\n\n    function getEvent(uint256 _eventId) external view returns (EventDetails memory _event) {\n        _event = events[_eventId];\n    }\n\n    function setLinkNode(address _newLinkNode) external onlyOwner {\n        linkNode = _newLinkNode;\n        emit LinkNodeChanged(_newLinkNode);\n    }\n\n    function resolveMarket(uint256) public pure override {\n        require(false, \"Only the link node can resolve the market, using trustedResolveMarkets\");\n    }\n}\n"
    },
    "contracts/libraries/PlaceholderReputationToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title Cash\n * @dev Test contract for collateral\n */\ncontract PlaceholderReputationToken is ERC20 {\n    uint8 private _decimals;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) ERC20(name_, symbol_) {\n        _decimals = decimals_;\n    }\n\n    function decimals() public view virtual override(ERC20) returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "contracts/libraries/Cash.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title Cash\n * @dev Test contract for collateral\n */\ncontract Cash is ERC20 {\n    uint8 private _decimals;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) ERC20(name_, symbol_) {\n        _decimals = decimals_;\n    }\n\n    function decimals() public view virtual override(ERC20) returns (uint8) {\n        return _decimals;\n    }\n\n    function faucet(uint256 _amount) public returns (bool) {\n        _mint(msg.sender, _amount);\n        return true;\n    }\n}\n"
    },
    "contracts/balancer/BPoolForTesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"./BFactory.sol\";\nimport \"../libraries/IERC20Full.sol\";\nimport \"../libraries/Cash.sol\";\n\ncontract BPoolForTesting {\n    BFactory private bFactory;\n    BPool private bPool;\n    uint256 private constant MAX_UINT = 2**256 - 1;\n\n    constructor(BFactory _bFactory) {\n        bFactory = _bFactory;\n    }\n\n    function createBPoolForTesting(\n        Cash[] calldata _tokens,\n        uint256[] calldata _initialLiquidity,\n        uint256[] calldata _weights\n    ) external returns (BPool) {\n        require(\n            _tokens.length == _weights.length && _tokens.length == _initialLiquidity.length,\n            \"Tokens, weights and initial liquidity should all have the same length.\"\n        );\n\n        bPool = bFactory.newBPool();\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            _tokens[i].approve(address(bPool), MAX_UINT);\n            bPool.bind(address(_tokens[i]), _initialLiquidity[i], _weights[i]);\n        }\n\n        bPool.finalize();\n\n        return bPool;\n    }\n\n    function getBPool() external view returns (BPool) {\n        return bPool;\n    }\n}\n"
    },
    "contracts/libraries/FakePriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol\";\n\ncontract FakePriceFeed is AggregatorV3Interface {\n    uint8 decimals_;\n    string description_;\n    uint256 version_;\n\n    struct Round {\n        uint80 roundId;\n        int256 answer;\n        uint256 startedAt;\n        uint256 updatedAt;\n        uint80 answeredInRound;\n    }\n    mapping(uint80 => Round) rounds;\n    uint80 latestRoundId;\n\n    constructor(\n        uint8 _decimals,\n        string memory _description,\n        uint256 _version\n    ) {\n        decimals_ = _decimals;\n        description_ = _description;\n        version_ = _version;\n    }\n\n    function decimals() external view override returns (uint8) {\n        return decimals_;\n    }\n\n    function description() external view override returns (string memory) {\n        return description_;\n    }\n\n    function version() external view override returns (uint256) {\n        return version_;\n    }\n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(uint80 roundId_)\n        public\n        view\n        override\n        returns (\n            uint80 _roundId,\n            int256 _answer,\n            uint256 _startedAt,\n            uint256 _updatedAt,\n            uint80 _answeredInRound\n        )\n    {\n        Round memory _round = rounds[roundId_];\n        _roundId = _round.roundId;\n        _answer = _round.answer;\n        _startedAt = _round.startedAt;\n        _updatedAt = _round.updatedAt;\n        _answeredInRound = _round.answeredInRound;\n    }\n\n    function latestRoundData()\n        public\n        view\n        override\n        returns (\n            uint80 _roundId,\n            int256 _answer,\n            uint256 _startedAt,\n            uint256 _updatedAt,\n            uint80 _answeredInRound\n        )\n    {\n        return getRoundData(latestRoundId);\n    }\n\n    function addRound(\n        uint80 _roundId,\n        int256 _answer,\n        uint256 _startedAt,\n        uint256 _updatedAt,\n        uint80 _answeredInRound\n    ) external {\n        rounds[_roundId] = Round(_roundId, _answer, _startedAt, _updatedAt, _answeredInRound);\n        latestRoundId = _roundId;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}