{
  "language": "Solidity",
  "sources": {
    "contracts/balancer/BColor.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\ninterface BColor {\n    function getColor() external view returns (bytes32);\n}\n\ncontract BBronze is BColor {\n    function getColor() external pure override returns (bytes32) {\n        return bytes32(\"BRONZE\");\n    }\n}\n"
    },
    "contracts/balancer/BConst.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"./BColor.sol\";\n\ncontract BConst is BBronze {\n    uint256 public constant BONE = 10**18;\n\n    uint256 public constant MIN_BOUND_TOKENS = 2;\n    uint256 public constant MAX_BOUND_TOKENS = 8;\n\n    uint256 public constant MIN_FEE = BONE / 10**6;\n    uint256 public constant MAX_FEE = BONE / 10;\n    uint256 public constant EXIT_FEE = 0;\n\n    uint256 public constant MIN_WEIGHT = BONE;\n    uint256 public constant MAX_WEIGHT = BONE * 50;\n    uint256 public constant MAX_TOTAL_WEIGHT = BONE * 50;\n    uint256 public constant MIN_BALANCE = BONE / 10**12;\n\n    uint256 public constant INIT_POOL_SUPPLY = BONE * 100;\n\n    uint256 public constant MIN_BPOW_BASE = 1 wei;\n    uint256 public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\n    uint256 public constant BPOW_PRECISION = BONE / 10**10;\n\n    uint256 public constant MAX_IN_RATIO = BONE / 2;\n    uint256 public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\n}\n"
    },
    "contracts/balancer/BNum.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"./BConst.sol\";\n\ncontract BNum is BConst {\n    function btoi(uint256 a) internal pure returns (uint256) {\n        return a / BONE;\n    }\n\n    function bfloor(uint256 a) internal pure returns (uint256) {\n        return btoi(a) * BONE;\n    }\n\n    function badd(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\n        return c;\n    }\n\n    function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (uint256 c, bool flag) = bsubSign(a, b);\n        require(!flag, \"ERR_SUB_UNDERFLOW\");\n        return c;\n    }\n\n    function bsubSign(uint256 a, uint256 b) internal pure returns (uint256, bool) {\n        if (a >= b) {\n            return (a - b, false);\n        } else {\n            return (b - a, true);\n        }\n    }\n\n    function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c0 = a * b;\n        require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\n        uint256 c1 = c0 + (BONE / 2);\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\n        uint256 c2 = c1 / BONE;\n        return c2;\n    }\n\n    function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"ERR_DIV_ZERO\");\n        uint256 c0 = a * BONE;\n        require(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\n        uint256 c1 = c0 + (b / 2);\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\n        uint256 c2 = c1 / b;\n        return c2;\n    }\n\n    // DSMath.wpow\n    function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\n        uint256 z = n % 2 != 0 ? a : BONE;\n\n        for (n /= 2; n != 0; n /= 2) {\n            a = bmul(a, a);\n\n            if (n % 2 != 0) {\n                z = bmul(z, a);\n            }\n        }\n        return z;\n    }\n\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\n    // of approximation of b^0.w\n    function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\n        require(base >= MIN_BPOW_BASE, \"ERR_BPOW_BASE_TOO_LOW\");\n        require(base <= MAX_BPOW_BASE, \"ERR_BPOW_BASE_TOO_HIGH\");\n\n        uint256 whole = bfloor(exp);\n        uint256 remain = bsub(exp, whole);\n\n        uint256 wholePow = bpowi(base, btoi(whole));\n\n        if (remain == 0) {\n            return wholePow;\n        }\n\n        uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\n        return bmul(wholePow, partialResult);\n    }\n\n    function bpowApprox(\n        uint256 base,\n        uint256 exp,\n        uint256 precision\n    ) internal pure returns (uint256) {\n        // term 0:\n        uint256 a = exp;\n        (uint256 x, bool xneg) = bsubSign(base, BONE);\n        uint256 term = BONE;\n        uint256 sum = term;\n        bool negative = false;\n\n        // term(k) = numer / denom\n        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\n        // continue until term is less than precision\n        for (uint256 i = 1; term >= precision; i++) {\n            uint256 bigK = i * BONE;\n            (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\n            term = bmul(term, bmul(c, x));\n            term = bdiv(term, bigK);\n            if (term == 0) break;\n\n            if (xneg) negative = !negative;\n            if (cneg) negative = !negative;\n            if (negative) {\n                sum = bsub(sum, term);\n            } else {\n                sum = badd(sum, term);\n            }\n        }\n\n        return sum;\n    }\n}\n"
    },
    "contracts/turbo/AMMFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"../balancer/BFactory.sol\";\nimport \"../libraries/SafeMathUint256.sol\";\nimport \"./AbstractMarketFactory.sol\";\nimport \"../balancer/BNum.sol\";\n\ncontract AMMFactory is BNum {\n    using SafeMathUint256 for uint256;\n\n    uint256 private constant MAX_UINT = 2**256 - 1;\n\n    BFactory public bFactory;\n    // MarketFactory => Market => BPool\n    mapping(address => mapping(uint256 => BPool)) public pools;\n    uint256 fee;\n\n    event PoolCreated(\n        address pool,\n        address indexed marketFactory,\n        uint256 indexed marketId,\n        address indexed creator,\n        address lpTokenRecipient\n    );\n    event LiquidityChanged(\n        address indexed marketFactory,\n        uint256 indexed marketId,\n        address indexed user,\n        address recipient,\n        // from the perspective of the user. e.g. collateral is negative when adding liquidity\n        int256 collateral,\n        int256 lpTokens,\n        uint256[] sharesReturned\n    );\n    event SharesSwapped(\n        address indexed marketFactory,\n        uint256 indexed marketId,\n        address indexed user,\n        uint256 outcome,\n        // from the perspective of the user. e.g. collateral is negative when buying\n        int256 collateral,\n        int256 shares,\n        uint256 price\n    );\n\n    constructor(BFactory _bFactory, uint256 _fee) {\n        bFactory = _bFactory;\n        fee = _fee;\n    }\n\n    function createPool(\n        AbstractMarketFactory _marketFactory,\n        uint256 _marketId,\n        uint256 _initialLiquidity,\n        uint256[] memory _weights,\n        address _lpTokenRecipient\n    ) public returns (uint256) {\n        require(pools[address(_marketFactory)][_marketId] == BPool(0), \"Pool already created\");\n\n        AbstractMarketFactory.Market memory _market = _marketFactory.getMarket(_marketId);\n\n        require(_weights.length == _market.shareTokens.length, \"Must have one weight for each share token\");\n\n        //  Turn collateral into shares\n        IERC20Full _collateral = _marketFactory.collateral();\n        require(\n            _collateral.allowance(msg.sender, address(this)) >= _initialLiquidity,\n            \"insufficient collateral allowance for initial liquidity\"\n        );\n\n        uint256 _sets = _marketFactory.calcShares(_initialLiquidity);\n\n        _collateral.transferFrom(msg.sender, address(this), _initialLiquidity);\n        _collateral.approve(address(_marketFactory), MAX_UINT);\n\n        _marketFactory.mintShares(_marketId, _sets, address(this));\n\n        // Create pool\n        BPool _pool = bFactory.newBPool();\n\n        // Add each outcome to the pool. Collateral is NOT added.\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            OwnedERC20 _token = _market.shareTokens[i];\n            _token.approve(address(_pool), MAX_UINT);\n            _pool.bind(address(_token), _sets, _weights[i]);\n        }\n\n        // Set the swap fee.\n        _pool.setSwapFee(fee);\n\n        // Finalize pool setup\n        _pool.finalize();\n\n        pools[address(_marketFactory)][_marketId] = _pool;\n\n        // Pass along LP tokens for initial liquidity\n        uint256 _lpTokenBalance = _pool.balanceOf(address(this)) - (BONE / 1000);\n\n        // Burn (BONE / 1000) lp tokens to prevent the bpool from locking up. When all liquidity is removed.\n        _pool.transfer(address(0x0), (BONE / 1000));\n        _pool.transfer(_lpTokenRecipient, _lpTokenBalance);\n\n        uint256[] memory _balances = new uint256[](_market.shareTokens.length);\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            _balances[i] = 0;\n        }\n\n        emit PoolCreated(address(_pool), address(_marketFactory), _marketId, msg.sender, _lpTokenRecipient);\n        emit LiquidityChanged(\n            address(_marketFactory),\n            _marketId,\n            msg.sender,\n            _lpTokenRecipient,\n            -int256(_initialLiquidity),\n            int256(_lpTokenBalance),\n            _balances\n        );\n\n        return _lpTokenBalance;\n    }\n\n    function addLiquidity(\n        AbstractMarketFactory _marketFactory,\n        uint256 _marketId,\n        uint256 _collateralIn,\n        uint256 _minLPTokensOut,\n        address _lpTokenRecipient\n    ) public returns (uint256 _poolAmountOut, uint256[] memory _balances) {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        require(_pool != BPool(0), \"Pool needs to be created\");\n\n        AbstractMarketFactory.Market memory _market = _marketFactory.getMarket(_marketId);\n\n        //  Turn collateral into shares\n        IERC20Full _collateral = _marketFactory.collateral();\n        _collateral.transferFrom(msg.sender, address(this), _collateralIn);\n        _collateral.approve(address(_marketFactory), MAX_UINT);\n        uint256 _sets = _marketFactory.calcShares(_collateralIn);\n        _marketFactory.mintShares(_marketId, _sets, address(this));\n\n        // Find poolAmountOut\n        _poolAmountOut = MAX_UINT;\n\n        {\n            uint256 _totalSupply = _pool.totalSupply();\n            uint256[] memory _maxAmountsIn = new uint256[](_market.shareTokens.length);\n            for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n                _maxAmountsIn[i] = _sets;\n\n                OwnedERC20 _token = _market.shareTokens[i];\n                uint256 _bPoolTokenBalance = _pool.getBalance(address(_token));\n\n                // This is the result the following when solving for poolAmountOut:\n                // uint256 ratio = bdiv(poolAmountOut, poolTotal);\n                // uint256 tokenAmountIn = bmul(ratio, bal);\n                uint256 _tokenPoolAmountOut =\n                    (((((_sets * BONE) - (BONE / 2)) * _totalSupply) / _bPoolTokenBalance) - (_totalSupply / 2)) / BONE;\n\n                if (_tokenPoolAmountOut < _poolAmountOut) {\n                    _poolAmountOut = _tokenPoolAmountOut;\n                }\n            }\n            _pool.joinPool(_poolAmountOut, _maxAmountsIn);\n        }\n\n        require(_poolAmountOut >= _minLPTokensOut, \"Would not have received enough LP tokens\");\n\n        _pool.transfer(_lpTokenRecipient, _poolAmountOut);\n\n        // Transfer the remaining shares back to _lpTokenRecipient.\n        _balances = new uint256[](_market.shareTokens.length);\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            OwnedERC20 _token = _market.shareTokens[i];\n            _balances[i] = _token.balanceOf(address(this));\n            if (_balances[i] > 0) {\n                _token.transfer(_lpTokenRecipient, _balances[i]);\n            }\n        }\n\n        emit LiquidityChanged(\n            address(_marketFactory),\n            _marketId,\n            msg.sender,\n            _lpTokenRecipient,\n            -int256(_collateralIn),\n            int256(_poolAmountOut),\n            _balances\n        );\n    }\n\n    function removeLiquidity(\n        AbstractMarketFactory _marketFactory,\n        uint256 _marketId,\n        uint256 _lpTokensIn,\n        uint256 _minCollateralOut,\n        address _collateralRecipient\n    ) public returns (uint256 _collateralOut, uint256[] memory _balances) {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        require(_pool != BPool(0), \"Pool needs to be created\");\n\n        AbstractMarketFactory.Market memory _market = _marketFactory.getMarket(_marketId);\n\n        _pool.transferFrom(msg.sender, address(this), _lpTokensIn);\n\n        uint256[] memory exitPoolEstimate;\n        {\n            uint256[] memory minAmountsOut = new uint256[](_market.shareTokens.length);\n            exitPoolEstimate = _pool.calcExitPool(_lpTokensIn, minAmountsOut);\n            _pool.exitPool(_lpTokensIn, minAmountsOut);\n        }\n\n        // Find the number of sets to sell.\n        uint256 _setsToSell = MAX_UINT;\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            uint256 _acquiredTokenBalance = exitPoolEstimate[i];\n            if (_acquiredTokenBalance < _setsToSell) _setsToSell = _acquiredTokenBalance;\n        }\n\n        // Must be a multiple of share factor.\n        _setsToSell = (_setsToSell / _marketFactory.shareFactor()) * _marketFactory.shareFactor();\n\n        bool _resolved = _marketFactory.isMarketResolved(_marketId);\n        if (_resolved) {\n            _collateralOut = _marketFactory.claimWinnings(_marketId, _collateralRecipient);\n        } else {\n            _collateralOut = _marketFactory.burnShares(_marketId, _setsToSell, _collateralRecipient);\n        }\n        require(_collateralOut > _minCollateralOut, \"Amount of collateral returned too low.\");\n\n        // Transfer the remaining shares back to _collateralRecipient.\n        _balances = new uint256[](_market.shareTokens.length);\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            OwnedERC20 _token = _market.shareTokens[i];\n            if (_resolved && _token == _market.winner) continue; // all winning shares claimed when market is resolved\n            _balances[i] = exitPoolEstimate[i] - _setsToSell;\n            if (_balances[i] > 0) {\n                _token.transfer(_collateralRecipient, _balances[i]);\n            }\n        }\n\n        emit LiquidityChanged(\n            address(_marketFactory),\n            _marketId,\n            msg.sender,\n            _collateralRecipient,\n            int256(_collateralOut),\n            -int256(_lpTokensIn),\n            _balances\n        );\n    }\n\n    function buy(\n        AbstractMarketFactory _marketFactory,\n        uint256 _marketId,\n        uint256 _outcome,\n        uint256 _collateralIn,\n        uint256 _minTokensOut\n    ) external returns (uint256) {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        require(_pool != BPool(0), \"Pool needs to be created\");\n\n        AbstractMarketFactory.Market memory _market = _marketFactory.getMarket(_marketId);\n\n        IERC20Full _collateral = _marketFactory.collateral();\n        _collateral.transferFrom(msg.sender, address(this), _collateralIn);\n        uint256 _sets = _marketFactory.calcShares(_collateralIn);\n        _marketFactory.mintShares(_marketId, _sets, address(this));\n\n        uint256 _totalDesiredOutcome = _sets;\n        {\n            OwnedERC20 _desiredToken = _market.shareTokens[_outcome];\n\n            for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n                if (i == _outcome) continue;\n                OwnedERC20 _token = _market.shareTokens[i];\n                (uint256 _acquiredToken, ) =\n                    _pool.swapExactAmountIn(address(_token), _sets, address(_desiredToken), 0, MAX_UINT);\n                _totalDesiredOutcome += _acquiredToken;\n            }\n            require(_totalDesiredOutcome >= _minTokensOut, \"Slippage exceeded\");\n\n            _desiredToken.transfer(msg.sender, _totalDesiredOutcome);\n        }\n\n        emit SharesSwapped(\n            address(_marketFactory),\n            _marketId,\n            msg.sender,\n            _outcome,\n            -int256(_collateralIn),\n            int256(_totalDesiredOutcome),\n            bdiv(_sets, _totalDesiredOutcome)\n        );\n\n        return _totalDesiredOutcome;\n    }\n\n    function sellForCollateral(\n        AbstractMarketFactory _marketFactory,\n        uint256 _marketId,\n        uint256 _outcome,\n        uint256[] memory _shareTokensIn,\n        uint256 _minSetsOut\n    ) external returns (uint256) {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        require(_pool != BPool(0), \"Pool needs to be created\");\n        AbstractMarketFactory.Market memory _market = _marketFactory.getMarket(_marketId);\n\n        uint256 _setsOut = MAX_UINT;\n        uint256 _totalUndesiredTokensIn = 0;\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            _totalUndesiredTokensIn += _shareTokensIn[i];\n        }\n\n        {\n            _market.shareTokens[_outcome].transferFrom(msg.sender, address(this), _totalUndesiredTokensIn);\n            _market.shareTokens[_outcome].approve(address(_pool), MAX_UINT);\n\n            for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n                if (i == _outcome) continue;\n                OwnedERC20 _token = _market.shareTokens[i];\n                (uint256 tokenAmountOut, ) =\n                    _pool.swapExactAmountIn(\n                        address(_market.shareTokens[_outcome]),\n                        _shareTokensIn[i],\n                        address(_token),\n                        0,\n                        MAX_UINT\n                    );\n\n                //Ensure tokenAmountOut is a multiple of shareFactor.\n                tokenAmountOut = (tokenAmountOut / _marketFactory.shareFactor()) * _marketFactory.shareFactor();\n                if (tokenAmountOut < _setsOut) _setsOut = tokenAmountOut;\n            }\n\n            require(_setsOut >= _minSetsOut, \"Minimum sets not available.\");\n            _marketFactory.burnShares(_marketId, _setsOut, msg.sender);\n        }\n\n        // Transfer undesired token balance back.\n        for (uint256 i = 0; i < _market.shareTokens.length; i++) {\n            OwnedERC20 _token = _market.shareTokens[i];\n            uint256 _balance = _token.balanceOf(address(this));\n            if (_balance > 0) {\n                _token.transfer(msg.sender, _balance);\n            }\n        }\n\n        uint256 _collateralOut = _marketFactory.calcCost(_setsOut);\n        emit SharesSwapped(\n            address(_marketFactory),\n            _marketId,\n            msg.sender,\n            _outcome,\n            int256(_collateralOut),\n            -int256(_totalUndesiredTokensIn),\n            bdiv(_setsOut, _totalUndesiredTokensIn)\n        );\n\n        return _collateralOut;\n    }\n\n    // Returns an array of token values for the outcomes of the market, relative to the first outcome.\n    // So the first outcome is 10**18 and all others are higher or lower.\n    // Prices can be derived due to the fact that the total of all outcome shares equals one collateral, possibly with a scaling factor,\n    function tokenRatios(AbstractMarketFactory _marketFactory, uint256 _marketId)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        // Pool does not exist. Do not want to revert because multicall.\n        if (_pool == BPool(0)) {\n            return new uint256[](0);\n        }\n\n        AbstractMarketFactory.Market memory _market = _marketFactory.getMarket(_marketId);\n        address _basisToken = address(_market.shareTokens[0]);\n        uint256[] memory _ratios = new uint256[](_market.shareTokens.length);\n        _ratios[0] = 10**18;\n        for (uint256 i = 1; i < _market.shareTokens.length; i++) {\n            uint256 _price = _pool.getSpotPrice(_basisToken, address(_market.shareTokens[i]));\n            _ratios[i] = _price;\n        }\n        return _ratios;\n    }\n\n    function getPoolBalances(AbstractMarketFactory _marketFactory, uint256 _marketId)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        // Pool does not exist. Do not want to revert because multicall.\n        if (_pool == BPool(0)) {\n            return new uint256[](0);\n        }\n\n        address[] memory _tokens = _pool.getCurrentTokens();\n        uint256[] memory _balances = new uint256[](_tokens.length);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            _balances[i] = _pool.getBalance(_tokens[i]);\n        }\n        return _balances;\n    }\n\n    function getPoolWeights(AbstractMarketFactory _marketFactory, uint256 _marketId)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        // Pool does not exist. Do not want to revert because multicall.\n        if (_pool == BPool(0)) {\n            return new uint256[](0);\n        }\n\n        address[] memory _tokens = _pool.getCurrentTokens();\n        uint256[] memory _weights = new uint256[](_tokens.length);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            _weights[i] = _pool.getDenormalizedWeight(_tokens[i]);\n        }\n        return _weights;\n    }\n\n    function getSwapFee(AbstractMarketFactory _marketFactory, uint256 _marketId) external view returns (uint256) {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        return _pool.getSwapFee();\n    }\n\n    function getPoolTokenBalance(\n        AbstractMarketFactory _marketFactory,\n        uint256 _marketId,\n        address whom\n    ) external view returns (uint256) {\n        BPool _pool = pools[address(_marketFactory)][_marketId];\n        return _pool.balanceOf(whom);\n    }\n\n    function getPool(AbstractMarketFactory _marketFactory, uint256 _marketId) external view returns (BPool) {\n        return pools[address(_marketFactory)][_marketId];\n    }\n}\n"
    },
    "contracts/balancer/BFactory.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is disstributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\n// Builds new BPools, logging their addresses and providing `isBPool(address) -> (bool)`\n\nimport \"./BPool.sol\";\n\ncontract BFactory is BBronze {\n    event LOG_NEW_POOL(address indexed caller, address indexed pool);\n\n    event LOG_BLABS(address indexed caller, address indexed blabs);\n\n    mapping(address => bool) private _isBPool;\n\n    function isBPool(address b) external view returns (bool) {\n        return _isBPool[b];\n    }\n\n    function newBPool() external returns (BPool) {\n        BPool bpool = new BPool();\n        _isBPool[address(bpool)] = true;\n        emit LOG_NEW_POOL(msg.sender, address(bpool));\n        bpool.setController(msg.sender);\n        return bpool;\n    }\n\n    address private _blabs;\n\n    constructor() {\n        _blabs = msg.sender;\n    }\n\n    function getBLabs() external view returns (address) {\n        return _blabs;\n    }\n\n    function setBLabs(address b) external {\n        require(msg.sender == _blabs, \"ERR_NOT_BLABS\");\n        emit LOG_BLABS(msg.sender, b);\n        _blabs = b;\n    }\n\n    function collect(BPool pool) external {\n        require(msg.sender == _blabs, \"ERR_NOT_BLABS\");\n        uint256 collected = IERC20Balancer(pool).balanceOf(address(this));\n        bool xfer = pool.transfer(_blabs, collected);\n        require(xfer, \"ERR_ERC20_FAILED\");\n    }\n}\n"
    },
    "contracts/libraries/SafeMathUint256.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\n/**\n * @title SafeMathUint256\n * @dev Uint256 math operations with safety checks that throw on error\n */\nlibrary SafeMathUint256 {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        return a - b;\n    }\n\n    function subS(\n        uint256 a,\n        uint256 b,\n        string memory message\n    ) internal pure returns (uint256) {\n        require(b <= a, message);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a <= b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a >= b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            uint256 x = (y + 1) / 2;\n            z = y;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function getUint256Min() internal pure returns (uint256) {\n        return 0;\n    }\n\n    function getUint256Max() internal pure returns (uint256) {\n        // 2 ** 256 - 1\n        return 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    }\n\n    function isMultipleOf(uint256 a, uint256 b) internal pure returns (bool) {\n        return a % b == 0;\n    }\n\n    // Float [fixed point] Operations\n    function fxpMul(\n        uint256 a,\n        uint256 b,\n        uint256 base\n    ) internal pure returns (uint256) {\n        return div(mul(a, b), base);\n    }\n\n    function fxpDiv(\n        uint256 a,\n        uint256 b,\n        uint256 base\n    ) internal pure returns (uint256) {\n        return div(mul(a, base), b);\n    }\n}\n"
    },
    "contracts/turbo/AbstractMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./TurboShareTokenFactory.sol\";\nimport \"./FeePot.sol\";\n\nabstract contract AbstractMarketFactory is TurboShareTokenFactory, Ownable {\n    using SafeMathUint256 for uint256;\n\n    // Should always have ID. Others are optional.\n    // event MarketCreated(uint256 id, address settlementAddress, uint256 endTime, ...);\n\n    // Should always have ID. Others are optional.\n    // event MarketResolved(uint256 id, ...);\n\n    event SharesMinted(uint256 id, uint256 amount, address receiver);\n    event SharesBurned(uint256 id, uint256 amount, address receiver);\n    event WinningsClaimed(\n        uint256 id,\n        address winningOutcome,\n        uint256 amount,\n        uint256 settlementFee,\n        uint256 payout,\n        address indexed receiver\n    );\n\n    event SettlementFeeClaimed(address settlementAddress, uint256 amount, address indexed receiver);\n    event ProtocolFeeClaimed(address protocol, uint256 amount);\n\n    event ProtocolChanged(address protocol);\n    event ProtocolFeeChanged(uint256 fee);\n    event SettlementFeeChanged(uint256 fee);\n    event StakerFeeChanged(uint256 fee);\n\n    IERC20Full public collateral;\n    FeePot public feePot;\n\n    // fees are out of 1e18 and only apply to new markets\n    uint256 public stakerFee;\n    uint256 public settlementFee;\n    uint256 public protocolFee;\n\n    address public protocol; // collects protocol fees\n\n    uint256 public accumulatedProtocolFee = 0;\n    // settlement address => amount of collateral\n    mapping(address => uint256) public accumulatedSettlementFees;\n\n    // How many shares equals one collateral.\n    // Necessary to account for math errors from small numbers in balancer.\n    // shares = collateral / shareFactor\n    // collateral = shares * shareFactor\n    uint256 public shareFactor;\n\n    struct Market {\n        address settlementAddress;\n        OwnedERC20[] shareTokens;\n        uint256 endTime;\n        OwnedERC20 winner;\n        uint256 settlementFee;\n        uint256 protocolFee;\n        uint256 stakerFee;\n        uint256 creationTimestamp;\n    }\n    Market[] internal markets;\n\n    uint256 private constant MAX_UINT = 2**256 - 1;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256 _stakerFee,\n        uint256 _settlementFee,\n        address _protocol,\n        uint256 _protocolFee\n    ) {\n        owner = _owner; // controls fees for new markets\n        collateral = _collateral;\n        shareFactor = _shareFactor;\n        feePot = _feePot;\n        stakerFee = _stakerFee;\n        settlementFee = _settlementFee;\n        protocol = _protocol;\n        protocolFee = _protocolFee;\n\n        _collateral.approve(address(_feePot), MAX_UINT);\n\n        // First market is always empty so that marketid zero means \"no market\"\n        string[] memory _nothing = new string[](0);\n        markets.push(makeMarket(address(0), _nothing, _nothing, 0));\n    }\n\n    // function createMarket(address _settlementAddress, uint256 _endTime, ...) public returns (uint256);\n\n    function resolveMarket(uint256 _id) public virtual;\n\n    // Returns an empty struct if the market doesn't exist.\n    // Can check market existence before calling this by comparing _id against markets.length.\n    // Can check market existence of the return struct by checking that shareTokens[0] isn't the null address\n    function getMarket(uint256 _id) public view returns (Market memory) {\n        if (_id >= markets.length) {\n            return Market(address(0), new OwnedERC20[](0), 0, OwnedERC20(0), 0, 0, 0, 0);\n        } else {\n            return markets[_id];\n        }\n    }\n\n    function marketCount() public view returns (uint256) {\n        return markets.length;\n    }\n\n    // Returns factory-specific details about a market.\n    // function getMarketDetails(uint256 _id) public view returns (MarketDetails memory);\n\n    function mintShares(\n        uint256 _id,\n        uint256 _shareToMint,\n        address _receiver\n    ) public {\n        require(markets.length > _id, \"No such market\");\n        require(!isMarketResolved(_id), \"Cannot mint shares for resolved market\");\n\n        uint256 _cost = calcCost(_shareToMint);\n        collateral.transferFrom(msg.sender, address(this), _cost);\n\n        Market memory _market = markets[_id];\n        for (uint256 _i = 0; _i < _market.shareTokens.length; _i++) {\n            _market.shareTokens[_i].trustedMint(_receiver, _shareToMint);\n        }\n\n        emit SharesMinted(_id, _shareToMint, _receiver);\n    }\n\n    function burnShares(\n        uint256 _id,\n        uint256 _sharesToBurn,\n        address _receiver\n    ) public returns (uint256) {\n        require(markets.length > _id, \"No such market\");\n        require(!isMarketResolved(_id), \"Cannot burn shares for resolved market\");\n\n        Market memory _market = markets[_id];\n        for (uint256 _i = 0; _i < _market.shareTokens.length; _i++) {\n            // errors if sender doesn't have enough shares\n            _market.shareTokens[_i].trustedBurn(msg.sender, _sharesToBurn);\n        }\n\n        uint256 _payout = calcCost(_sharesToBurn);\n        uint256 _protocolFee = _payout.mul(_market.protocolFee).div(10**18);\n        uint256 _stakerFee = _payout.mul(_market.stakerFee).div(10**18);\n        _payout = _payout.sub(_protocolFee).sub(_stakerFee);\n\n        accumulatedProtocolFee += _protocolFee;\n        collateral.transfer(_receiver, _payout);\n        feePot.depositFees(_stakerFee);\n\n        emit SharesBurned(_id, _sharesToBurn, msg.sender);\n        return _payout;\n    }\n\n    function claimWinnings(uint256 _id, address _receiver) public returns (uint256) {\n        if (!isMarketResolved(_id)) {\n            // errors if market does not exist or is not resolved or resolvable\n            resolveMarket(_id);\n        }\n\n        Market memory _market = markets[_id];\n        uint256 _winningShares = _market.winner.trustedBurnAll(msg.sender);\n        _winningShares = (_winningShares / shareFactor) * shareFactor; // remove unusable dust\n\n        uint256 _payout = calcCost(_winningShares); // will fail if there are no winnings to claim\n        uint256 _settlementFee = _payout.mul(_market.settlementFee).div(10**18);\n        _payout = _payout.sub(_settlementFee);\n\n        accumulatedSettlementFees[_market.settlementAddress] += _settlementFee;\n        collateral.transfer(_receiver, _payout);\n\n        emit WinningsClaimed(_id, address(_market.winner), _winningShares, _settlementFee, _payout, _receiver);\n        return _payout;\n    }\n\n    function claimManyWinnings(uint256[] memory _ids, address _receiver) public returns (uint256) {\n        uint256 _totalWinnings = 0;\n        for (uint256 i = 0; i < _ids.length; i++) {\n            _totalWinnings = _totalWinnings.add(claimWinnings(_ids[i], _receiver));\n        }\n        return _totalWinnings;\n    }\n\n    function claimSettlementFees(address _receiver) public returns (uint256) {\n        uint256 _fees = accumulatedSettlementFees[msg.sender];\n        if (_fees > 0) {\n            accumulatedSettlementFees[msg.sender] = 0;\n            collateral.transfer(_receiver, _fees);\n            emit SettlementFeeClaimed(msg.sender, _fees, _receiver);\n        }\n        return _fees;\n    }\n\n    function claimProtocolFees() public returns (uint256) {\n        require(msg.sender == protocol || msg.sender == address(this), \"Only protocol can claim protocol fee\");\n        uint256 _fees = accumulatedProtocolFee;\n        if (_fees > 0) {\n            accumulatedProtocolFee = 0;\n            collateral.transfer(protocol, _fees);\n            emit ProtocolFeeClaimed(protocol, _fees);\n        }\n        return _fees;\n    }\n\n    function setSettlementFee(uint256 _newFee) external onlyOwner {\n        settlementFee = _newFee;\n        emit SettlementFeeChanged(_newFee);\n    }\n\n    function setStakerFee(uint256 _newFee) external onlyOwner {\n        stakerFee = _newFee;\n        emit StakerFeeChanged(_newFee);\n    }\n\n    function setProtocolFee(uint256 _newFee) external onlyOwner {\n        protocolFee = _newFee;\n        emit ProtocolFeeChanged(_newFee);\n    }\n\n    function setProtocol(address _newProtocol, bool _claimFirst) external onlyOwner {\n        if (_claimFirst) {\n            claimProtocolFees();\n        }\n        protocol = _newProtocol;\n        emit ProtocolChanged(_newProtocol);\n    }\n\n    function makeMarket(\n        address _settlementAddress,\n        string[] memory _names,\n        string[] memory _symbols,\n        uint256 _endTime\n    ) internal returns (Market memory _market) {\n        _market = Market(\n            _settlementAddress,\n            createShareTokens(_names, _symbols, address(this)),\n            _endTime,\n            OwnedERC20(0),\n            settlementFee,\n            protocolFee,\n            stakerFee,\n            block.timestamp\n        );\n    }\n\n    function isMarketResolved(uint256 _id) public view returns (bool) {\n        Market memory _market = markets[_id];\n        return _market.winner != OwnedERC20(0);\n    }\n\n    // Only usable off-chain. Gas cost can easily eclipse block limit.\n    function listUnresolvedMarkets() public view returns (uint256[] memory) {\n        uint256 _totalUnresolved = 0;\n        for (uint256 i = 0; i < markets.length; i++) {\n            if (!isMarketResolved(i)) {\n                _totalUnresolved++;\n            }\n        }\n\n        uint256[] memory _marketIds = new uint256[](_totalUnresolved);\n\n        uint256 n = 0;\n        for (uint256 i = 0; i < markets.length; i++) {\n            if (n >= _totalUnresolved) break;\n\n            if (!isMarketResolved(i)) {\n                _marketIds[n] = i;\n                n++;\n            }\n        }\n\n        return _marketIds;\n    }\n\n    // shares => collateral\n    function calcCost(uint256 _shares) public view returns (uint256) {\n        require(\n            _shares >= shareFactor && _shares % shareFactor == 0,\n            \"Shares must be both greater than (or equal to) and divisible by shareFactor\"\n        );\n        return _shares / shareFactor;\n    }\n\n    // collateral => shares\n    function calcShares(uint256 _collateralIn) public view returns (uint256) {\n        return _collateralIn * shareFactor;\n    }\n\n    function onTransferOwnership(address, address) internal override {}\n}\n"
    },
    "contracts/balancer/BPool.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"./BToken.sol\";\nimport \"./BMath.sol\";\n\ncontract BPool is BBronze, BToken, BMath {\n    struct Record {\n        bool bound; // is token bound to pool\n        uint256 index; // private\n        uint256 denorm; // denormalized weight\n        uint256 balance;\n    }\n\n    event LOG_SWAP(\n        address indexed caller,\n        address indexed tokenIn,\n        address indexed tokenOut,\n        uint256 tokenAmountIn,\n        uint256 tokenAmountOut\n    );\n\n    event LOG_JOIN(address indexed caller, address indexed tokenIn, uint256 tokenAmountIn);\n\n    event LOG_EXIT(address indexed caller, address indexed tokenOut, uint256 tokenAmountOut);\n\n    event LOG_CALL(bytes4 indexed sig, address indexed caller, bytes data) anonymous;\n\n    modifier _logs_() {\n        emit LOG_CALL(msg.sig, msg.sender, msg.data);\n        _;\n    }\n\n    modifier _lock_() {\n        require(!_mutex, \"ERR_REENTRY\");\n        _mutex = true;\n        _;\n        _mutex = false;\n    }\n\n    modifier _viewlock_() {\n        require(!_mutex, \"ERR_REENTRY\");\n        _;\n    }\n\n    bool private _mutex;\n\n    address private _factory; // BFactory address to push token exitFee to\n    address private _controller; // has CONTROL role\n    bool private _publicSwap; // true if PUBLIC can call SWAP functions\n\n    // `setSwapFee` and `finalize` require CONTROL\n    // `finalize` sets `PUBLIC can SWAP`, `PUBLIC can JOIN`\n    uint256 private _swapFee;\n    bool private _finalized;\n\n    address[] private _tokens;\n    mapping(address => Record) private _records;\n    uint256 private _totalWeight;\n\n    constructor() {\n        _controller = msg.sender;\n        _factory = msg.sender;\n        _swapFee = MIN_FEE;\n        _publicSwap = false;\n        _finalized = false;\n    }\n\n    function isPublicSwap() external view returns (bool) {\n        return _publicSwap;\n    }\n\n    function isFinalized() external view returns (bool) {\n        return _finalized;\n    }\n\n    function isBound(address t) external view returns (bool) {\n        return _records[t].bound;\n    }\n\n    function getNumTokens() external view returns (uint256) {\n        return _tokens.length;\n    }\n\n    function getCurrentTokens() external view _viewlock_ returns (address[] memory tokens) {\n        return _tokens;\n    }\n\n    function getFinalTokens() external view _viewlock_ returns (address[] memory tokens) {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n        return _tokens;\n    }\n\n    function getDenormalizedWeight(address token) external view _viewlock_ returns (uint256) {\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\n        return _records[token].denorm;\n    }\n\n    function getTotalDenormalizedWeight() external view _viewlock_ returns (uint256) {\n        return _totalWeight;\n    }\n\n    function getNormalizedWeight(address token) external view _viewlock_ returns (uint256) {\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\n        uint256 denorm = _records[token].denorm;\n        return bdiv(denorm, _totalWeight);\n    }\n\n    function getBalance(address token) external view _viewlock_ returns (uint256) {\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\n        return _records[token].balance;\n    }\n\n    function getSwapFee() external view _viewlock_ returns (uint256) {\n        return _swapFee;\n    }\n\n    function getController() external view _viewlock_ returns (address) {\n        return _controller;\n    }\n\n    function setSwapFee(uint256 swapFee) external _logs_ _lock_ {\n        require(!_finalized, \"ERR_IS_FINALIZED\");\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        require(swapFee >= MIN_FEE, \"ERR_MIN_FEE\");\n        require(swapFee <= MAX_FEE, \"ERR_MAX_FEE\");\n        _swapFee = swapFee;\n    }\n\n    function setController(address manager) external _logs_ _lock_ {\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        _controller = manager;\n    }\n\n    function setPublicSwap(bool public_) external _logs_ _lock_ {\n        require(!_finalized, \"ERR_IS_FINALIZED\");\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        _publicSwap = public_;\n    }\n\n    function finalize() external _logs_ _lock_ {\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        require(!_finalized, \"ERR_IS_FINALIZED\");\n        require(_tokens.length >= MIN_BOUND_TOKENS, \"ERR_MIN_TOKENS\");\n\n        _finalized = true;\n        _publicSwap = true;\n\n        _mintPoolShare(INIT_POOL_SUPPLY);\n        _pushPoolShare(msg.sender, INIT_POOL_SUPPLY);\n    }\n\n    function bind(\n        address token,\n        uint256 balance,\n        uint256 denorm\n    )\n        external\n        _logs_ // _lock_  Bind does not lock because it jumps to `rebind`, which does\n    {\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        require(!_records[token].bound, \"ERR_IS_BOUND\");\n        require(!_finalized, \"ERR_IS_FINALIZED\");\n\n        require(_tokens.length < MAX_BOUND_TOKENS, \"ERR_MAX_TOKENS\");\n\n        _records[token] = Record({\n            bound: true,\n            index: _tokens.length,\n            denorm: 0, // balance and denorm will be validated\n            balance: 0 // and set by `rebind`\n        });\n        _tokens.push(token);\n        rebind(token, balance, denorm);\n    }\n\n    function rebind(\n        address token,\n        uint256 balance,\n        uint256 denorm\n    ) public _logs_ _lock_ {\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\n        require(!_finalized, \"ERR_IS_FINALIZED\");\n\n        require(denorm >= MIN_WEIGHT, \"ERR_MIN_WEIGHT\");\n        require(denorm <= MAX_WEIGHT, \"ERR_MAX_WEIGHT\");\n        require(balance >= MIN_BALANCE, \"ERR_MIN_BALANCE\");\n\n        // Adjust the denorm and totalWeight\n        uint256 oldWeight = _records[token].denorm;\n        if (denorm > oldWeight) {\n            _totalWeight = badd(_totalWeight, bsub(denorm, oldWeight));\n            require(_totalWeight <= MAX_TOTAL_WEIGHT, \"ERR_MAX_TOTAL_WEIGHT\");\n        } else if (denorm < oldWeight) {\n            _totalWeight = bsub(_totalWeight, bsub(oldWeight, denorm));\n        }\n        _records[token].denorm = denorm;\n\n        // Adjust the balance record and actual token balance\n        uint256 oldBalance = _records[token].balance;\n        _records[token].balance = balance;\n        if (balance > oldBalance) {\n            _pullUnderlying(token, msg.sender, bsub(balance, oldBalance));\n        } else if (balance < oldBalance) {\n            // In this case liquidity is being withdrawn, so charge EXIT_FEE\n            uint256 tokenBalanceWithdrawn = bsub(oldBalance, balance);\n            uint256 tokenExitFee = bmul(tokenBalanceWithdrawn, EXIT_FEE);\n            _pushUnderlying(token, msg.sender, bsub(tokenBalanceWithdrawn, tokenExitFee));\n            _pushUnderlying(token, _factory, tokenExitFee);\n        }\n    }\n\n    function unbind(address token) external _logs_ _lock_ {\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\n        require(!_finalized, \"ERR_IS_FINALIZED\");\n\n        uint256 tokenBalance = _records[token].balance;\n        uint256 tokenExitFee = bmul(tokenBalance, EXIT_FEE);\n\n        _totalWeight = bsub(_totalWeight, _records[token].denorm);\n\n        // Swap the token-to-unbind with the last token,\n        // then delete the last token\n        uint256 index = _records[token].index;\n        uint256 last = _tokens.length - 1;\n        _tokens[index] = _tokens[last];\n        _records[_tokens[index]].index = index;\n        _tokens.pop();\n        _records[token] = Record({bound: false, index: 0, denorm: 0, balance: 0});\n\n        _pushUnderlying(token, msg.sender, bsub(tokenBalance, tokenExitFee));\n        _pushUnderlying(token, _factory, tokenExitFee);\n    }\n\n    // Absorb any tokens that have been sent to this contract into the pool\n    function gulp(address token) external _logs_ _lock_ {\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\n        _records[token].balance = IERC20Balancer(token).balanceOf(address(this));\n    }\n\n    function getSpotPrice(address tokenIn, address tokenOut) external view _viewlock_ returns (uint256 spotPrice) {\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\n        Record storage inRecord = _records[tokenIn];\n        Record storage outRecord = _records[tokenOut];\n        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, _swapFee);\n    }\n\n    function getSpotPriceSansFee(address tokenIn, address tokenOut)\n        external\n        view\n        _viewlock_\n        returns (uint256 spotPrice)\n    {\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\n        Record storage inRecord = _records[tokenIn];\n        Record storage outRecord = _records[tokenOut];\n        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, 0);\n    }\n\n    function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external _logs_ _lock_ {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n\n        uint256 poolTotal = totalSupply();\n        uint256 ratio = bdiv(poolAmountOut, poolTotal);\n        require(ratio != 0, \"ERR_MATH_APPROX\");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address t = _tokens[i];\n            uint256 bal = _records[t].balance;\n            uint256 tokenAmountIn = bmul(ratio, bal);\n            require(tokenAmountIn != 0, \"ERR_MATH_APPROX\");\n            require(tokenAmountIn <= maxAmountsIn[i], \"ERR_LIMIT_IN\");\n            _records[t].balance = badd(_records[t].balance, tokenAmountIn);\n            emit LOG_JOIN(msg.sender, t, tokenAmountIn);\n            _pullUnderlying(t, msg.sender, tokenAmountIn);\n        }\n        _mintPoolShare(poolAmountOut);\n        _pushPoolShare(msg.sender, poolAmountOut);\n    }\n\n    function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external _logs_ _lock_ {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n\n        uint256 poolTotal = totalSupply();\n        uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\n        uint256 pAiAfterExitFee = bsub(poolAmountIn, exitFee);\n        uint256 ratio = bdiv(pAiAfterExitFee, poolTotal);\n        require(ratio != 0, \"ERR_MATH_APPROX\");\n\n        _pullPoolShare(msg.sender, poolAmountIn);\n        _pushPoolShare(_factory, exitFee);\n        _burnPoolShare(pAiAfterExitFee);\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address t = _tokens[i];\n            uint256 bal = _records[t].balance;\n            uint256 tokenAmountOut = bmul(ratio, bal);\n            require(tokenAmountOut != 0, \"ERR_MATH_APPROX\");\n            require(tokenAmountOut >= minAmountsOut[i], \"ERR_LIMIT_OUT\");\n            _records[t].balance = bsub(_records[t].balance, tokenAmountOut);\n            emit LOG_EXIT(msg.sender, t, tokenAmountOut);\n            _pushUnderlying(t, msg.sender, tokenAmountOut);\n        }\n    }\n\n    function calcExitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n\n        uint256 poolTotal = totalSupply();\n        uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\n        uint256 pAiAfterExitFee = bsub(poolAmountIn, exitFee);\n        uint256 ratio = bdiv(pAiAfterExitFee, poolTotal);\n\n        uint256[] memory _amounts = new uint256[](_tokens.length * 2);\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address t = _tokens[i];\n            uint256 bal = _records[t].balance;\n\n            _amounts[i] = bmul(ratio, bal);\n            _amounts[_tokens.length + i] = minAmountsOut[i];\n            require(_amounts[i] >= minAmountsOut[i], \"ERR_LIMIT_OUT\");\n        }\n\n        return _amounts;\n    }\n\n    function swapExactAmountIn(\n        address tokenIn,\n        uint256 tokenAmountIn,\n        address tokenOut,\n        uint256 minAmountOut,\n        uint256 maxPrice\n    ) external _logs_ _lock_ returns (uint256 tokenAmountOut, uint256 spotPriceAfter) {\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\n        require(_publicSwap, \"ERR_SWAP_NOT_PUBLIC\");\n\n        Record storage inRecord = _records[address(tokenIn)];\n        Record storage outRecord = _records[address(tokenOut)];\n\n        require(tokenAmountIn <= bmul(inRecord.balance, MAX_IN_RATIO), \"ERR_MAX_IN_RATIO\");\n\n        uint256 spotPriceBefore =\n            calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, _swapFee);\n        require(spotPriceBefore <= maxPrice, \"ERR_BAD_LIMIT_PRICE\");\n\n        tokenAmountOut = calcOutGivenIn(\n            inRecord.balance,\n            inRecord.denorm,\n            outRecord.balance,\n            outRecord.denorm,\n            tokenAmountIn,\n            _swapFee\n        );\n        require(tokenAmountOut >= minAmountOut, \"ERR_LIMIT_OUT\");\n\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n\n        spotPriceAfter = calcSpotPrice(\n            inRecord.balance,\n            inRecord.denorm,\n            outRecord.balance,\n            outRecord.denorm,\n            _swapFee\n        );\n        require(spotPriceAfter >= spotPriceBefore, \"ERR_MATH_APPROX\");\n        require(spotPriceAfter <= maxPrice, \"ERR_LIMIT_PRICE\");\n        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), \"ERR_MATH_APPROX\");\n\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\n\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n\n        return (tokenAmountOut, spotPriceAfter);\n    }\n\n    function swapExactAmountOut(\n        address tokenIn,\n        uint256 maxAmountIn,\n        address tokenOut,\n        uint256 tokenAmountOut,\n        uint256 maxPrice\n    ) external _logs_ _lock_ returns (uint256 tokenAmountIn, uint256 spotPriceAfter) {\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\n        require(_publicSwap, \"ERR_SWAP_NOT_PUBLIC\");\n\n        Record storage inRecord = _records[address(tokenIn)];\n        Record storage outRecord = _records[address(tokenOut)];\n\n        require(tokenAmountOut <= bmul(outRecord.balance, MAX_OUT_RATIO), \"ERR_MAX_OUT_RATIO\");\n\n        uint256 spotPriceBefore =\n            calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, _swapFee);\n        require(spotPriceBefore <= maxPrice, \"ERR_BAD_LIMIT_PRICE\");\n\n        tokenAmountIn = calcInGivenOut(\n            inRecord.balance,\n            inRecord.denorm,\n            outRecord.balance,\n            outRecord.denorm,\n            tokenAmountOut,\n            _swapFee\n        );\n        require(tokenAmountIn <= maxAmountIn, \"ERR_LIMIT_IN\");\n\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n\n        spotPriceAfter = calcSpotPrice(\n            inRecord.balance,\n            inRecord.denorm,\n            outRecord.balance,\n            outRecord.denorm,\n            _swapFee\n        );\n        require(spotPriceAfter >= spotPriceBefore, \"ERR_MATH_APPROX\");\n        require(spotPriceAfter <= maxPrice, \"ERR_LIMIT_PRICE\");\n        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), \"ERR_MATH_APPROX\");\n\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\n\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n\n        return (tokenAmountIn, spotPriceAfter);\n    }\n\n    function joinswapExternAmountIn(\n        address tokenIn,\n        uint256 tokenAmountIn,\n        uint256 minPoolAmountOut\n    ) external _logs_ _lock_ returns (uint256 poolAmountOut) {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n        require(tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \"ERR_MAX_IN_RATIO\");\n\n        Record storage inRecord = _records[tokenIn];\n\n        poolAmountOut = calcPoolOutGivenSingleIn(\n            inRecord.balance,\n            inRecord.denorm,\n            _totalSupply,\n            _totalWeight,\n            tokenAmountIn,\n            _swapFee\n        );\n\n        require(poolAmountOut >= minPoolAmountOut, \"ERR_LIMIT_OUT\");\n\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\n\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\n\n        _mintPoolShare(poolAmountOut);\n        _pushPoolShare(msg.sender, poolAmountOut);\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n\n        return poolAmountOut;\n    }\n\n    function joinswapPoolAmountOut(\n        address tokenIn,\n        uint256 poolAmountOut,\n        uint256 maxAmountIn\n    ) external _logs_ _lock_ returns (uint256 tokenAmountIn) {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n\n        Record storage inRecord = _records[tokenIn];\n\n        tokenAmountIn = calcSingleInGivenPoolOut(\n            inRecord.balance,\n            inRecord.denorm,\n            _totalSupply,\n            _totalWeight,\n            poolAmountOut,\n            _swapFee\n        );\n\n        require(tokenAmountIn != 0, \"ERR_MATH_APPROX\");\n        require(tokenAmountIn <= maxAmountIn, \"ERR_LIMIT_IN\");\n\n        require(tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \"ERR_MAX_IN_RATIO\");\n\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\n\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\n\n        _mintPoolShare(poolAmountOut);\n        _pushPoolShare(msg.sender, poolAmountOut);\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n\n        return tokenAmountIn;\n    }\n\n    function exitswapPoolAmountIn(\n        address tokenOut,\n        uint256 poolAmountIn,\n        uint256 minAmountOut\n    ) external _logs_ _lock_ returns (uint256 tokenAmountOut) {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\n\n        Record storage outRecord = _records[tokenOut];\n\n        tokenAmountOut = calcSingleOutGivenPoolIn(\n            outRecord.balance,\n            outRecord.denorm,\n            _totalSupply,\n            _totalWeight,\n            poolAmountIn,\n            _swapFee\n        );\n\n        require(tokenAmountOut >= minAmountOut, \"ERR_LIMIT_OUT\");\n\n        require(tokenAmountOut <= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \"ERR_MAX_OUT_RATIO\");\n\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n\n        uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\n\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\n\n        _pullPoolShare(msg.sender, poolAmountIn);\n        _burnPoolShare(bsub(poolAmountIn, exitFee));\n        _pushPoolShare(_factory, exitFee);\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n\n        return tokenAmountOut;\n    }\n\n    function exitswapExternAmountOut(\n        address tokenOut,\n        uint256 tokenAmountOut,\n        uint256 maxPoolAmountIn\n    ) external _logs_ _lock_ returns (uint256 poolAmountIn) {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\n        require(tokenAmountOut <= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \"ERR_MAX_OUT_RATIO\");\n\n        Record storage outRecord = _records[tokenOut];\n\n        poolAmountIn = calcPoolInGivenSingleOut(\n            outRecord.balance,\n            outRecord.denorm,\n            _totalSupply,\n            _totalWeight,\n            tokenAmountOut,\n            _swapFee\n        );\n\n        require(poolAmountIn != 0, \"ERR_MATH_APPROX\");\n        require(poolAmountIn <= maxPoolAmountIn, \"ERR_LIMIT_IN\");\n\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n\n        uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\n\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\n\n        _pullPoolShare(msg.sender, poolAmountIn);\n        _burnPoolShare(bsub(poolAmountIn, exitFee));\n        _pushPoolShare(_factory, exitFee);\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n\n        return poolAmountIn;\n    }\n\n    // ==\n    // 'Underlying' token-manipulation functions make external calls but are NOT locked\n    // You must `_lock_` or otherwise ensure reentry-safety\n\n    function _pullUnderlying(\n        address erc20,\n        address from,\n        uint256 amount\n    ) internal {\n        bool xfer = IERC20Balancer(erc20).transferFrom(from, address(this), amount);\n        require(xfer, \"ERR_ERC20_FALSE\");\n    }\n\n    function _pushUnderlying(\n        address erc20,\n        address to,\n        uint256 amount\n    ) internal {\n        bool xfer = IERC20Balancer(erc20).transfer(to, amount);\n        require(xfer, \"ERR_ERC20_FALSE\");\n    }\n\n    function _pullPoolShare(address from, uint256 amount) internal {\n        _pull(from, amount);\n    }\n\n    function _pushPoolShare(address to, uint256 amount) internal {\n        _push(to, amount);\n    }\n\n    function _mintPoolShare(uint256 amount) internal {\n        _mint(amount);\n    }\n\n    function _burnPoolShare(uint256 amount) internal {\n        _burn(amount);\n    }\n}\n"
    },
    "contracts/balancer/BToken.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"./BNum.sol\";\n\ninterface IERC20Balancer {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address whom) external view returns (uint256);\n\n    function allowance(address src, address dst) external view returns (uint256);\n\n    function approve(address dst, uint256 amt) external returns (bool);\n\n    function transfer(address dst, uint256 amt) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amt\n    ) external returns (bool);\n}\n\ncontract BTokenBase is BNum {\n    mapping(address => uint256) internal _balance;\n    mapping(address => mapping(address => uint256)) internal _allowance;\n    uint256 internal _totalSupply;\n\n    event Approval(address indexed src, address indexed dst, uint256 amt);\n    event Transfer(address indexed src, address indexed dst, uint256 amt);\n\n    function _mint(uint256 amt) internal {\n        _balance[address(this)] = badd(_balance[address(this)], amt);\n        _totalSupply = badd(_totalSupply, amt);\n        emit Transfer(address(0), address(this), amt);\n    }\n\n    function _burn(uint256 amt) internal {\n        require(_balance[address(this)] >= amt, \"ERR_INSUFFICIENT_BAL\");\n        _balance[address(this)] = bsub(_balance[address(this)], amt);\n        _totalSupply = bsub(_totalSupply, amt);\n        emit Transfer(address(this), address(0), amt);\n    }\n\n    function _move(\n        address src,\n        address dst,\n        uint256 amt\n    ) internal {\n        require(_balance[src] >= amt, \"ERR_INSUFFICIENT_BAL\");\n        _balance[src] = bsub(_balance[src], amt);\n        _balance[dst] = badd(_balance[dst], amt);\n        emit Transfer(src, dst, amt);\n    }\n\n    function _push(address to, uint256 amt) internal {\n        _move(address(this), to, amt);\n    }\n\n    function _pull(address from, uint256 amt) internal {\n        _move(from, address(this), amt);\n    }\n}\n\ncontract BToken is BTokenBase, IERC20Balancer {\n    string private _name = \"Balancer Pool Token\";\n    string private _symbol = \"BPT\";\n    uint8 private _decimals = 18;\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function allowance(address src, address dst) external view override returns (uint256) {\n        return _allowance[src][dst];\n    }\n\n    function balanceOf(address whom) external view override returns (uint256) {\n        return _balance[whom];\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function approve(address dst, uint256 amt) external override returns (bool) {\n        _allowance[msg.sender][dst] = amt;\n        emit Approval(msg.sender, dst, amt);\n        return true;\n    }\n\n    function increaseApproval(address dst, uint256 amt) external returns (bool) {\n        _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\n        return true;\n    }\n\n    function decreaseApproval(address dst, uint256 amt) external returns (bool) {\n        uint256 oldValue = _allowance[msg.sender][dst];\n        if (amt > oldValue) {\n            _allowance[msg.sender][dst] = 0;\n        } else {\n            _allowance[msg.sender][dst] = bsub(oldValue, amt);\n        }\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\n        return true;\n    }\n\n    function transfer(address dst, uint256 amt) external override returns (bool) {\n        _move(msg.sender, dst, amt);\n        return true;\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amt\n    ) external override returns (bool) {\n        require(msg.sender == src || amt <= _allowance[src][msg.sender], \"ERR_BTOKEN_BAD_CALLER\");\n        _move(src, dst, amt);\n        if (msg.sender != src && _allowance[src][msg.sender] != uint256(-1)) {\n            _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\n            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\n        }\n        return true;\n    }\n}\n"
    },
    "contracts/balancer/BMath.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"./BNum.sol\";\n\ncontract BMath is BBronze, BConst, BNum {\n    /**********************************************************************************************\n    // calcSpotPrice                                                                             //\n    // sP = spotPrice                                                                            //\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\n    // wO = tokenWeightOut                                                                       //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n    function calcSpotPrice(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 swapFee\n    ) public pure returns (uint256 spotPrice) {\n        uint256 numer = bdiv(tokenBalanceIn, tokenWeightIn);\n        uint256 denom = bdiv(tokenBalanceOut, tokenWeightOut);\n        uint256 ratio = bdiv(numer, denom);\n        uint256 scale = bdiv(BONE, bsub(BONE, swapFee));\n        return (spotPrice = bmul(ratio, scale));\n    }\n\n    /**********************************************************************************************\n    // calcOutGivenIn                                                                            //\n    // aO = tokenAmountOut                                                                       //\n    // bO = tokenBalanceOut                                                                      //\n    // bI = tokenBalanceIn              /      /            bI             \\    (wI / wO) \\      //\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\n    // wI = tokenWeightIn               \\      \\ ( bI + ( aI * ( 1 - sF )) /              /      //\n    // wO = tokenWeightOut                                                                       //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n    function calcOutGivenIn(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 tokenAmountIn,\n        uint256 swapFee\n    ) public pure returns (uint256 tokenAmountOut) {\n        uint256 weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\n        uint256 adjustedIn = bsub(BONE, swapFee);\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\n        uint256 y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\n        uint256 foo = bpow(y, weightRatio);\n        uint256 bar = bsub(BONE, foo);\n        tokenAmountOut = bmul(tokenBalanceOut, bar);\n        return tokenAmountOut;\n    }\n\n    /**********************************************************************************************\n    // calcInGivenOut                                                                            //\n    // aI = tokenAmountIn                                                                        //\n    // bO = tokenBalanceOut               /  /     bO      \\    (wO / wI)      \\                 //\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\n    // aO = tokenAmountOut    aI =        \\  \\ ( bO - aO ) /                   /                 //\n    // wI = tokenWeightIn           --------------------------------------------                 //\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n    function calcInGivenOut(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 tokenAmountOut,\n        uint256 swapFee\n    ) public pure returns (uint256 tokenAmountIn) {\n        uint256 weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\n        uint256 diff = bsub(tokenBalanceOut, tokenAmountOut);\n        uint256 y = bdiv(tokenBalanceOut, diff);\n        uint256 foo = bpow(y, weightRatio);\n        foo = bsub(foo, BONE);\n        tokenAmountIn = bsub(BONE, swapFee);\n        tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\n        return tokenAmountIn;\n    }\n\n    /**********************************************************************************************\n    // calcPoolOutGivenSingleIn                                                                  //\n    // pAo = poolAmountOut         /                                              \\              //\n    // tAi = tokenAmountIn        ///      /     //    wI \\      \\\\       \\     wI \\             //\n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\    --  \\            //\n    // tW = totalWeight     pAo=||  \\      \\     \\\\    tW /      //         | ^ tW   | * pS - pS //\n    // tBi = tokenBalanceIn      \\\\  ------------------------------------- /        /            //\n    // pS = poolSupply            \\\\                    tBi               /        /             //\n    // sF = swapFee                \\                                              /              //\n    **********************************************************************************************/\n\n    // Charge the trading fee for the proportion of tokenAi\n    ///  which is implicitly traded to the other pool tokens.\n    // That proportion is (1- weightTokenIn)\n    // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\n\n    function calcPoolOutGivenSingleIn(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 tokenAmountIn,\n        uint256 swapFee\n    ) public pure returns (uint256 poolAmountOut) {\n        uint256 normalizedWeight = bdiv(tokenWeightIn, totalWeight);\n        uint256 zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\n        uint256 tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BONE, zaz));\n\n        uint256 newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\n        uint256 tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\n\n        // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\n        uint256 poolRatio = bpow(tokenInRatio, normalizedWeight);\n        uint256 newPoolSupply = bmul(poolRatio, poolSupply);\n        poolAmountOut = bsub(newPoolSupply, poolSupply);\n        return poolAmountOut;\n    }\n\n    /**********************************************************************************************\n    // calcSingleInGivenPoolOut                                                                  //\n    // tAi = tokenAmountIn              //(pS + pAo)\\     /    1    \\\\                           //\n    // pS = poolSupply                 || ---------  | ^ | --------- || * bI - bI                //\n    // pAo = poolAmountOut              \\\\    pS    /     \\(wI / tW)//                           //\n    // bI = balanceIn          tAi =  --------------------------------------------               //\n    // wI = weightIn                              /      wI  \\                                   //\n    // tW = totalWeight                          |  1 - ----  |  * sF                            //\n    // sF = swapFee                               \\      tW  /                                   //\n    **********************************************************************************************/\n    function calcSingleInGivenPoolOut(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 poolAmountOut,\n        uint256 swapFee\n    ) public pure returns (uint256 tokenAmountIn) {\n        uint256 normalizedWeight = bdiv(tokenWeightIn, totalWeight);\n        uint256 newPoolSupply = badd(poolSupply, poolAmountOut);\n        uint256 poolRatio = bdiv(newPoolSupply, poolSupply);\n\n        //uint newBalTi = poolRatio^(1/weightTi) * balTi;\n        uint256 boo = bdiv(BONE, normalizedWeight);\n        uint256 tokenInRatio = bpow(poolRatio, boo);\n        uint256 newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\n        uint256 tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\n        // Do reverse order of fees charged in joinswap_ExternAmountIn, this way\n        //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\n        //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\n        uint256 zar = bmul(bsub(BONE, normalizedWeight), swapFee);\n        tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));\n        return tokenAmountIn;\n    }\n\n    /**********************************************************************************************\n    // calcSingleOutGivenPoolIn                                                                  //\n    // tAo = tokenAmountOut            /      /                                             \\\\   //\n    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\     /    1    \\      \\\\  //\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\n    // ps = poolSupply                \\      \\\\          pS           /     \\(wO / tW)/      //  //\n    // wI = tokenWeightIn      tAo =   \\      \\                                             //   //\n    // tW = totalWeight                    /     /      wO \\       \\                             //\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\n    // eF = exitFee                        \\     \\      tW /       /                             //\n    **********************************************************************************************/\n    function calcSingleOutGivenPoolIn(\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 poolAmountIn,\n        uint256 swapFee\n    ) public pure returns (uint256 tokenAmountOut) {\n        uint256 normalizedWeight = bdiv(tokenWeightOut, totalWeight);\n        // charge exit fee on the pool token side\n        // pAiAfterExitFee = pAi*(1-exitFee)\n        uint256 poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BONE, EXIT_FEE));\n        uint256 newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\n        uint256 poolRatio = bdiv(newPoolSupply, poolSupply);\n\n        // newBalTo = poolRatio^(1/weightTo) * balTo;\n        uint256 tokenOutRatio = bpow(poolRatio, bdiv(BONE, normalizedWeight));\n        uint256 newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\n\n        uint256 tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);\n\n        // charge swap fee on the output token side\n        //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\n        uint256 zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\n        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BONE, zaz));\n        return tokenAmountOut;\n    }\n\n    /**********************************************************************************************\n    // calcPoolInGivenSingleOut                                                                  //\n    // pAi = poolAmountIn               // /               tAo             \\\\     / wO \\     \\   //\n    // bO = tokenBalanceOut            // | bO - -------------------------- |\\   | ---- |     \\  //\n    // tAo = tokenAmountOut      pS - ||   \\     1 - ((1 - (tO / tW)) * sF)/  | ^ \\ tW /  * pS | //\n    // ps = poolSupply                 \\\\ -----------------------------------/                /  //\n    // wO = tokenWeightOut  pAi =       \\\\               bO                 /                /   //\n    // tW = totalWeight           -------------------------------------------------------------  //\n    // sF = swapFee                                        ( 1 - eF )                            //\n    // eF = exitFee                                                                              //\n    **********************************************************************************************/\n    function calcPoolInGivenSingleOut(\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 tokenAmountOut,\n        uint256 swapFee\n    ) public pure returns (uint256 poolAmountIn) {\n        // charge swap fee on the output token side\n        uint256 normalizedWeight = bdiv(tokenWeightOut, totalWeight);\n        //uint tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;\n        uint256 zoo = bsub(BONE, normalizedWeight);\n        uint256 zar = bmul(zoo, swapFee);\n        uint256 tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BONE, zar));\n\n        uint256 newTokenBalanceOut = bsub(tokenBalanceOut, tokenAmountOutBeforeSwapFee);\n        uint256 tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\n\n        //uint newPoolSupply = (ratioTo ^ weightTo) * poolSupply;\n        uint256 poolRatio = bpow(tokenOutRatio, normalizedWeight);\n        uint256 newPoolSupply = bmul(poolRatio, poolSupply);\n        uint256 poolAmountInAfterExitFee = bsub(poolSupply, newPoolSupply);\n\n        // charge exit fee on the pool token side\n        // pAi = pAiAfterExitFee/(1-exitFee)\n        poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BONE, EXIT_FEE));\n        return poolAmountIn;\n    }\n}\n"
    },
    "contracts/libraries/IERC20Full.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IERC20Full is IERC20 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/turbo/TurboShareTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./OwnedShareToken.sol\";\n\nabstract contract TurboShareTokenFactory {\n    function createShareTokens(\n        string[] memory _names,\n        string[] memory _symbols,\n        address _owner\n    ) internal returns (OwnedERC20[] memory) {\n        uint256 _numOutcomes = _names.length;\n        OwnedERC20[] memory _tokens = new OwnedERC20[](_numOutcomes);\n\n        for (uint256 _i = 0; _i < _numOutcomes; _i++) {\n            _tokens[_i] = new OwnedERC20(_names[_i], _symbols[_i], _owner);\n        }\n        return _tokens;\n    }\n}\n"
    },
    "contracts/turbo/FeePot.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../libraries/SafeMathUint256.sol\";\nimport \"../libraries/IERC20Full.sol\";\n\ncontract FeePot is ERC20 {\n    using SafeMathUint256 for uint256;\n\n    uint256 internal constant magnitude = 2**128;\n\n    IERC20Full public collateral;\n    IERC20Full public reputationToken;\n\n    uint256 public magnifiedFeesPerShare;\n\n    mapping(address => uint256) public magnifiedFeesCorrections;\n    mapping(address => uint256) public storedFees;\n\n    uint256 public feeReserve;\n\n    constructor(IERC20Full _collateral, IERC20Full _reputationToken)\n        ERC20(\n            string(abi.encodePacked(\"S_\", _reputationToken.symbol())),\n            string(abi.encodePacked(\"S_\", _reputationToken.symbol()))\n        )\n    {\n        collateral = _collateral;\n        reputationToken = _reputationToken;\n\n        require(_collateral != IERC20Full(0));\n    }\n\n    function depositFees(uint256 _amount) public returns (bool) {\n        collateral.transferFrom(msg.sender, address(this), _amount);\n        uint256 _totalSupply = totalSupply(); // after collateral.transferFrom to prevent reentrancy causing stale totalSupply\n        if (_totalSupply == 0) {\n            feeReserve = feeReserve.add(_amount);\n            return true;\n        }\n        if (feeReserve > 0) {\n            _amount = _amount.add(feeReserve);\n            feeReserve = 0;\n        }\n        magnifiedFeesPerShare = magnifiedFeesPerShare.add((_amount).mul(magnitude) / _totalSupply);\n        return true;\n    }\n\n    function withdrawableFeesOf(address _owner) public view returns (uint256) {\n        return earnedFeesOf(_owner).add(storedFees[_owner]);\n    }\n\n    function earnedFeesOf(address _owner) public view returns (uint256) {\n        uint256 _ownerBalance = balanceOf(_owner);\n        uint256 _magnifiedFees = magnifiedFeesPerShare.mul(_ownerBalance);\n        return _magnifiedFees.sub(magnifiedFeesCorrections[_owner]) / magnitude;\n    }\n\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal override {\n        storedFees[_from] = storedFees[_from].add(earnedFeesOf(_from));\n        super._transfer(_from, _to, _amount);\n\n        magnifiedFeesCorrections[_from] = magnifiedFeesPerShare.mul(balanceOf(_from));\n        magnifiedFeesCorrections[_to] = magnifiedFeesCorrections[_to].add(magnifiedFeesPerShare.mul(_amount));\n    }\n\n    function stake(uint256 _amount) external returns (bool) {\n        reputationToken.transferFrom(msg.sender, address(this), _amount);\n        _mint(msg.sender, _amount);\n        magnifiedFeesCorrections[msg.sender] = magnifiedFeesCorrections[msg.sender].add(\n            magnifiedFeesPerShare.mul(_amount)\n        );\n        return true;\n    }\n\n    function exit(uint256 _amount) external returns (bool) {\n        redeemInternal(msg.sender);\n        _burn(msg.sender, _amount);\n        reputationToken.transfer(msg.sender, _amount);\n        magnifiedFeesCorrections[msg.sender] = magnifiedFeesPerShare.mul(balanceOf(msg.sender));\n        return true;\n    }\n\n    function redeem() public returns (bool) {\n        redeemInternal(msg.sender);\n        magnifiedFeesCorrections[msg.sender] = magnifiedFeesPerShare.mul(balanceOf(msg.sender));\n        return true;\n    }\n\n    function redeemInternal(address _account) internal {\n        uint256 _withdrawableFees = withdrawableFeesOf(_account);\n        if (_withdrawableFees > 0) {\n            storedFees[_account] = 0;\n            collateral.transfer(_account, _withdrawableFees);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/turbo/OwnedShareToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../libraries/Ownable.sol\";\n\ncontract OwnedERC20 is ERC20, Ownable {\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        address _owner\n    ) ERC20(name_, symbol_) {\n        owner = _owner;\n    }\n\n    function trustedTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external onlyOwner {\n        _transfer(_from, _to, _amount);\n    }\n\n    function trustedMint(address _target, uint256 _amount) external onlyOwner {\n        _mint(_target, _amount);\n    }\n\n    function trustedBurn(address _target, uint256 _amount) external onlyOwner {\n        _burn(_target, _amount);\n    }\n\n    function trustedBurnAll(address _target) external onlyOwner returns (uint256) {\n        uint256 _balance = balanceOf(_target);\n        _burn(_target, _balance);\n        return _balance;\n    }\n\n    function onTransferOwnership(address, address) internal override {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/libraries/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"./IOwnable.sol\";\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\nabstract contract Ownable is IOwnable {\n    address internal owner;\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor() {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function getOwner() public view override returns (address) {\n        return owner;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param _newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address _newOwner) public override onlyOwner returns (bool) {\n        require(_newOwner != address(0));\n        onTransferOwnership(owner, _newOwner);\n        owner = _newOwner;\n        return true;\n    }\n\n    // Subclasses of this token may want to send additional logs through the centralized Augur log emitter contract\n    function onTransferOwnership(address, address) internal virtual;\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/libraries/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\ninterface IOwnable {\n    function getOwner() external view returns (address);\n\n    function transferOwnership(address _newOwner) external returns (bool);\n}\n"
    },
    "contracts/turbo/TrustedMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactory.sol\";\nimport \"./FeePot.sol\";\n\ncontract TrustedMarketFactory is AbstractMarketFactory {\n    using SafeMathUint256 for uint256;\n\n    event MarketCreated(uint256 id, address creator, uint256 _endTime, string description, string[] outcomes);\n    event MarketResolved(uint256 id, address winner);\n\n    struct MarketDetails {\n        string description;\n    }\n    MarketDetails[] internal marketDetails;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256 _stakerFee,\n        uint256 _settlementFee,\n        address _protocol,\n        uint256 _protocolFee\n    )\n        AbstractMarketFactory(\n            _owner,\n            _collateral,\n            _shareFactor,\n            _feePot,\n            _stakerFee,\n            _settlementFee,\n            _protocol,\n            _protocolFee\n        )\n    {}\n\n    function createMarket(\n        address _creator,\n        uint256 _endTime,\n        string calldata _description,\n        string[] calldata _names,\n        string[] calldata _symbols\n    ) public onlyOwner returns (uint256) {\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _names, _symbols, _endTime));\n        marketDetails.push(MarketDetails(_description));\n\n        emit MarketCreated(_id, _creator, _endTime, _description, _symbols);\n        return _id;\n    }\n\n    function resolveMarket(uint256) public pure override {\n        require(false, \"Only the TrustedMarketFactory owner can resolve the market, using trustedResolveMarket\");\n    }\n\n    function trustedResolveMarket(uint256 _id, uint256 _winningOutcome) public onlyOwner {\n        OwnedERC20 _winner = markets[_id].shareTokens[_winningOutcome];\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function getMarketDetails(uint256 _id) public view returns (MarketDetails memory) {\n        return marketDetails[_id];\n    }\n}\n"
    },
    "contracts/turbo/SportsLinkMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactory.sol\";\nimport \"./FeePot.sol\";\nimport \"../libraries/SafeMathInt256.sol\";\n\ncontract SportsLinkMarketFactory is AbstractMarketFactory {\n    using SafeMathUint256 for uint256;\n    using SafeMathInt256 for int256;\n\n    event MarketCreated(\n        uint256 id,\n        address creator,\n        uint256 endTime,\n        MarketType marketType,\n        uint256 indexed eventId,\n        uint256 homeTeamId,\n        uint256 awayTeamId,\n        uint256 estimatedStartTime,\n        int256 score\n    );\n    event MarketResolved(uint256 id, address winner);\n    event LinkNodeChanged(address newLinkNode);\n\n    enum MarketType {HeadToHead, Spread, OverUnder}\n    enum HeadToHeadOutcome {\n        NoContest, // 0\n        Away, // 1\n        Home // 2\n    }\n    enum SpreadOutcome {\n        NoContest, // 0\n        Away, // 1\n        Home // 2\n    }\n    enum OverUnderOutcome {\n        NoContest, // 0\n        Over, // 1\n        Under // 2\n    }\n    struct MarketDetails {\n        uint256 eventId;\n        uint256 homeTeamId;\n        uint256 awayTeamId;\n        uint256 estimatedStartTime;\n        MarketType marketType;\n        EventStatus eventStatus;\n        // This value depends on the marketType.\n        // HeadToHead: ignored\n        // Spread: the home team spread\n        // OverUnder: total score in game\n        int256 value0;\n    }\n    // MarketId => MarketDetails\n    mapping(uint256 => MarketDetails) internal marketDetails;\n\n    enum EventStatus {Unknown, Scheduled, Final, Postponed, Canceled}\n    struct EventDetails {\n        uint256[3] markets;\n        uint256 startTime;\n        uint256 homeScore;\n        uint256 awayScore;\n        EventStatus status;\n        // If there is a resolution time then the market is resolved but not necessarily finalized.\n        // A market is finalized when its last two score updates were identical.\n        // Score updates must occur after a period of time spedcified by resolutionBuffer.\n        // This mechanism exists to reduce the risk of bad scores being sent by the API then later corrected.\n        // The downside is slower resolution.\n        uint256 resolutionTime; // time since last score update\n        bool finalized; // true after event resolves and has stable scores\n    }\n    // EventId => EventDetails\n    mapping(uint256 => EventDetails) public events;\n    uint256[] public listOfEvents;\n\n    address public linkNode;\n    uint256 public sportId;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256 _stakerFee,\n        uint256 _settlementFee,\n        address _protocol,\n        uint256 _protocolFee,\n        address _linkNode,\n        uint256 _sportId\n    )\n        AbstractMarketFactory(\n            _owner,\n            _collateral,\n            _shareFactor,\n            _feePot,\n            _stakerFee,\n            _settlementFee,\n            _protocol,\n            _protocolFee\n        )\n    {\n        linkNode = _linkNode;\n        sportId = _sportId;\n    }\n\n    function createMarket(bytes32 _payload) public returns (uint256[3] memory _ids) {\n        require(msg.sender == linkNode, \"Only link node can create markets\");\n\n        (\n            uint256 _eventId,\n            uint256 _homeTeamId,\n            uint256 _awayTeamId,\n            uint256 _startTimestamp,\n            int256 _homeSpread,\n            uint256 _totalScore,\n            bool _makeSpread,\n            bool _makeTotalScore\n        ) = decodeCreation(_payload);\n        address _creator = msg.sender;\n        uint256 _endTime = _startTimestamp.add(60 * 8); // 8 hours\n\n        _ids = events[_eventId].markets;\n\n        if (_ids[0] == 0) {\n            _ids[0] = createHeadToHeadMarket(_creator, _endTime, _eventId, _homeTeamId, _awayTeamId, _startTimestamp);\n        }\n\n        if (_ids[1] == 0 && _makeSpread) {\n            // spread market hasn't been created and is ready to be created\n            _ids[1] = createSpreadMarket(\n                _creator,\n                _endTime,\n                _eventId,\n                _homeTeamId,\n                _awayTeamId,\n                _startTimestamp,\n                _homeSpread\n            );\n        }\n\n        if (_ids[2] == 0 && _makeTotalScore) {\n            // over-under market hasn't been created and is ready to be created\n            _ids[2] = createOverUnderMarket(\n                _creator,\n                _endTime,\n                _eventId,\n                _homeTeamId,\n                _awayTeamId,\n                _startTimestamp,\n                _totalScore\n            );\n        }\n\n        events[_eventId].status = EventStatus.Scheduled;\n        events[_eventId].startTime = _startTimestamp;\n        events[_eventId].markets = _ids;\n        listOfEvents.push(_eventId);\n    }\n\n    function createHeadToHeadMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(HeadToHeadOutcome.NoContest)] = \"No Contest\";\n        _outcomes[uint256(HeadToHeadOutcome.Away)] = \"Away\";\n        _outcomes[uint256(HeadToHeadOutcome.Home)] = \"Home\";\n\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime));\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.HeadToHead,\n            EventStatus.Scheduled,\n            0\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.HeadToHead,\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            0\n        );\n        return _id;\n    }\n\n    function createSpreadMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256 _homeSpread\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(SpreadOutcome.NoContest)] = \"No Contest\";\n        _outcomes[uint256(SpreadOutcome.Away)] = \"Away\";\n        _outcomes[uint256(SpreadOutcome.Home)] = \"Home\";\n\n        // The spread is a quantity of tenths. So 55 is 5.5 and -6 is -60.\n        // If the spread is a whole number then make it a half point more extreme, to eliminate ties.\n        // So 50 becomes 55, -60 becomes -65, and 0 becomes 5.\n        if (_homeSpread >= 0 && _homeSpread % 10 == 0) {\n            _homeSpread += 5;\n        } else if (_homeSpread < 0 && (-_homeSpread) % 10 == 0) {\n            _homeSpread -= 5;\n        }\n\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime));\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.Spread,\n            EventStatus.Scheduled,\n            _homeSpread\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.Spread,\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            _homeSpread\n        );\n        return _id;\n    }\n\n    function createOverUnderMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        uint256 _overUnderTotal\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[uint256(OverUnderOutcome.NoContest)] = \"No Contest\";\n        _outcomes[uint256(OverUnderOutcome.Over)] = \"Over\";\n        _outcomes[uint256(OverUnderOutcome.Under)] = \"Under\";\n\n        // The total is a quantity of tenths. So 55 is 5.5 and -6 is -60.\n        // If the total is a whole number then make it a half point higher, to eliminate ties.\n        // So 50 becomes 55 and 0 becomes 5.\n        if (_overUnderTotal >= 0 && _overUnderTotal % 10 == 0) {\n            _overUnderTotal += 5;\n        }\n\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime));\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.OverUnder,\n            EventStatus.Scheduled,\n            int256(_overUnderTotal)\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.OverUnder,\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            int256(_overUnderTotal)\n        );\n        return _id;\n    }\n\n    function resolveMarket(uint256) public pure override {\n        require(false, \"Only the link node can resolve the market, using trustedResolveMarkets\");\n    }\n\n    function trustedResolveMarkets(bytes32 _payload) public {\n        require(msg.sender == linkNode, \"Only link node can resolve markets\");\n\n        (uint256 _eventId, uint256 _eventStatus, uint256 _homeScore, uint256 _awayScore) = decodeResolution(_payload);\n\n        EventDetails storage _event = events[_eventId];\n        uint256[3] memory _ids = _event.markets;\n\n        require(_ids[0] != 0 || _ids[1] != 0 || _ids[2] != 0, \"Cannot resolve markets that weren't created\");\n\n        require(EventStatus(_eventStatus) != EventStatus.Scheduled, \"cannot resolve SCHEDULED markets\");\n\n        // resolve markets as No Contest\n        if (EventStatus(_eventStatus) != EventStatus.Final) {\n            for (uint256 i = 0; i < _ids.length; i++) {\n                uint256 _id = _ids[i];\n                if (_id == 0) continue; // skip non-created markets\n                OwnedERC20 _winner = markets[_id].shareTokens[0]; // 0th outcome is No Contest for all market types\n                markets[_id].winner = _winner;\n                emit MarketResolved(_id, address(_winner));\n            }\n            return;\n        }\n\n        // only resolve markets that were created\n        if (_ids[0] != 0) {\n            resolveHeadToHeadMarket(_ids[0], _homeScore, _awayScore);\n        }\n        if (_ids[1] != 0) {\n            resolveSpreadMarket(_ids[1], _homeScore, _awayScore);\n        }\n        if (_ids[2] != 0) {\n            resolveOverUnderMarket(_ids[2], _homeScore, _awayScore);\n        }\n    }\n\n    function resolveHeadToHeadMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        OwnedERC20 _winner;\n        if (_homeScore > _awayScore) {\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.Home)]; // home team won\n        } else if (_homeScore < _awayScore) {\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.Away)]; // away team won\n        } else {\n            _winner = markets[_id].shareTokens[uint256(HeadToHeadOutcome.NoContest)]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function resolveSpreadMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        MarketDetails memory _details = marketDetails[_id];\n        int256 _targetSpread = _details.value0;\n\n        int256 _actualSpread = int256(_homeScore).sub(int256(_awayScore));\n\n        OwnedERC20 _winner;\n        if (_actualSpread > _targetSpread) {\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.Home)]; // home spread greater\n        } else if (_actualSpread < _targetSpread) {\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.Away)]; // home spread lesser\n        } else {\n            _winner = markets[_id].shareTokens[uint256(SpreadOutcome.NoContest)]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function resolveOverUnderMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        MarketDetails memory _details = marketDetails[_id];\n        int256 _targetTotal = _details.value0;\n\n        int256 _actualTotal = int256(_homeScore).add(int256(_awayScore));\n\n        OwnedERC20 _winner;\n        if (_actualTotal > _targetTotal) {\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.Over)]; // over\n        } else if (_actualTotal < _targetTotal) {\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.Under)]; // under\n        } else {\n            _winner = markets[_id].shareTokens[uint256(OverUnderOutcome.NoContest)]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function getMarketDetails(uint256 _marketId) public view returns (MarketDetails memory) {\n        return marketDetails[_marketId];\n    }\n\n    function setLinkNode(address _newLinkNode) external onlyOwner {\n        linkNode = _newLinkNode;\n        emit LinkNodeChanged(_newLinkNode);\n    }\n\n    function getEventMarkets(uint256 _eventId) external view returns (uint256[3] memory) {\n        uint256[3] memory _event = events[_eventId].markets;\n        return _event;\n    }\n\n    // Events can be partially registered, by only creating some markets.\n    // This returns true only if an event is fully registered.\n    function isEventRegistered(uint256 _eventId) public view returns (bool) {\n        uint256[3] memory _event = events[_eventId].markets;\n        return _event[0] != 0 && _event[1] != 0 && _event[2] != 0;\n    }\n\n    function isEventResolved(uint256 _eventId) public view returns (bool) {\n        // check the event's head-to-head market since it will always exist if the event's markets exist\n        uint256 _marketId = events[_eventId].markets[0];\n        return isMarketResolved(_marketId);\n    }\n\n    function encodeCreation(\n        uint128 _eventId,\n        uint16 _homeTeamId,\n        uint16 _awayTeamId,\n        uint32 _startTimestamp,\n        int16 _homeSpread,\n        uint16 _totalScore,\n        bool _createSpread,\n        bool _createTotal\n    ) external pure returns (bytes32 _payload) {\n        uint8 _creationFlags;\n\n        if (_createSpread) {\n            _creationFlags += 1; // 0b0000000x\n        }\n        if (_createTotal) {\n            _creationFlags += 2; // 0b000000x0\n        }\n\n        bytes memory _a =\n            abi.encodePacked(\n                _eventId,\n                _homeTeamId,\n                _awayTeamId,\n                _startTimestamp,\n                _homeSpread,\n                _totalScore,\n                _creationFlags\n            );\n        assembly {\n            _payload := mload(add(_a, 32))\n        }\n    }\n\n    function decodeCreation(bytes32 _payload)\n        public\n        pure\n        returns (\n            uint128 _eventId,\n            uint16 _homeTeamId,\n            uint16 _awayTeamId,\n            uint32 _startTimestamp,\n            int16 _homeSpread,\n            uint16 _totalScore,\n            bool _createSpread,\n            bool _createTotal\n        )\n    {\n        uint256 _temp = uint256(_payload);\n        uint8 _creationFlags;\n        // prettier-ignore\n        {\n            _eventId        = uint128(_temp >> 128);\n            _homeTeamId     = uint16((_temp << 128)                                >> (256 - 16));\n            _awayTeamId     = uint16((_temp << (128 + 16))                         >> (256 - 16));\n            _startTimestamp = uint32((_temp << (128 + 16 + 16))                    >> (256 - 32));\n            _homeSpread     = int16 ((_temp << (128 + 16 + 16 + 32))               >> (256 - 16));\n            _totalScore     = uint16((_temp << (128 + 16 + 16 + 32 + 16))          >> (256 - 16));\n            _creationFlags  = uint8 ((_temp << (128 + 16 + 16 + 32 + 16 + 16))     >> (256 -  8));\n\n            // Lowest bit is _createSpread.\n            // Second-lowest bit is _createTotal.\n            _createSpread = _creationFlags & 0x1 != 0; // 0b0000000x\n            _createTotal = _creationFlags & 0x2 != 0;  // 0b000000x0\n        }\n    }\n\n    function encodeResolution(\n        uint128 _eventId,\n        uint8 _eventStatus,\n        uint16 _homeScore,\n        uint16 _awayScore\n    ) external pure returns (bytes32 _payload) {\n        bytes memory _a = abi.encodePacked(_eventId, _eventStatus, _homeScore, _awayScore);\n        assembly {\n            _payload := mload(add(_a, 32))\n        }\n    }\n\n    function decodeResolution(bytes32 _payload)\n        public\n        pure\n        returns (\n            uint128 _eventId,\n            uint8 _eventStatus,\n            uint16 _homeScore,\n            uint16 _awayScore\n        )\n    {\n        uint256 _temp = uint256(_payload);\n        // prettier-ignore\n        {\n            _eventId     = uint128(_temp >> 128);\n            _eventStatus = uint8 ((_temp << 128)            >> (256 - 8));\n            _homeScore   = uint16((_temp << (128 + 8))      >> (256 - 16));\n            _awayScore   = uint16((_temp << (128 + 8 + 16)) >> (256 - 16));\n        }\n    }\n\n    // Only usable off-chain. Gas cost can easily eclipse block limit.\n    // Lists all events that could be resolved with a call to resolveEvent.\n    // Not all will be resolvable because this does not ensure the game ended.\n    function listResolvableEvents() external view returns (uint256[] memory) {\n        uint256 _totalResolvable = countResolvableEvents();\n        uint256[] memory _resolvableEvents = new uint256[](_totalResolvable);\n\n        uint256 n = 0;\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\n            if (n > _totalResolvable) break;\n            uint256 _eventId = listOfEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _resolvableEvents[n] = _eventId;\n                n++;\n            }\n        }\n\n        return _resolvableEvents;\n    }\n\n    function countResolvableEvents() internal view returns (uint256) {\n        uint256 _totalResolvable = 0;\n        for (uint256 i = 0; i < listOfEvents.length; i++) {\n            uint256 _eventId = listOfEvents[i];\n            if (isEventResolvable(_eventId)) {\n                _totalResolvable++;\n            }\n        }\n        return _totalResolvable;\n    }\n\n    // Returns true if a call to resolveEvent is potentially useful.\n    function isEventResolvable(uint256 _eventId) internal view returns (bool) {\n        EventDetails memory _event = events[_eventId];\n\n        bool _unresolved = false; // default because non-existing markets aren't resolvable\n        for (uint256 i = 0; i < _event.markets.length; i++) {\n            uint256 _marketId = _event.markets[i];\n            if (_marketId != 0 && !isMarketResolved(_marketId)) {\n                _unresolved = true;\n                break;\n            }\n        }\n\n        return _unresolved;\n    }\n}\n"
    },
    "contracts/libraries/SafeMathInt256.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\n/**\n * @title SafeMathInt256\n * @dev Int256 math operations with safety checks that throw on error\n */\nlibrary SafeMathInt256 {\n    // Signed ints with n bits can range from -2**(n-1) to (2**(n-1) - 1)\n    int256 private constant INT256_MIN = -2**(255);\n    int256 private constant INT256_MAX = (2**(255) - 1);\n\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a * b;\n        require(a == 0 || c / a == b);\n        return c;\n    }\n\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        // No need to check for dividing by 0 -- Solidity automatically throws on division by 0\n        int256 c = a / b;\n        return c;\n    }\n\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        require(((a >= 0) && (b >= a - INT256_MAX)) || ((a < 0) && (b <= a - INT256_MIN)));\n        return a - b;\n    }\n\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        require(((a >= 0) && (b <= INT256_MAX - a)) || ((a < 0) && (b >= INT256_MIN - a)));\n        return a + b;\n    }\n\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        if (a <= b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        if (a >= b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    function abs(int256 a) internal pure returns (int256) {\n        if (a < 0) {\n            return -a;\n        }\n        return a;\n    }\n\n    function getInt256Min() internal pure returns (int256) {\n        return INT256_MIN;\n    }\n\n    function getInt256Max() internal pure returns (int256) {\n        return INT256_MAX;\n    }\n\n    // Float [fixed point] Operations\n    function fxpMul(\n        int256 a,\n        int256 b,\n        int256 base\n    ) internal pure returns (int256) {\n        return div(mul(a, b), base);\n    }\n\n    function fxpDiv(\n        int256 a,\n        int256 b,\n        int256 base\n    ) internal pure returns (int256) {\n        return div(mul(a, base), b);\n    }\n\n    function sqrt(int256 y) internal pure returns (int256 z) {\n        if (y > 3) {\n            int256 x = (y + 1) / 2;\n            z = y;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n"
    },
    "contracts/turbo/SportsLinkProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"../libraries/Ownable.sol\";\nimport \"./SportsLinkMarketFactory.sol\";\n\n// The replay functionality only works under a test env because an owner is needed.\n// In production, the owner can be set to the link node for potential future work.\ncontract SportsLinkProxy is Ownable {\n    // Link API\n\n    function createMarket(bytes32 _payload) public returns (uint256[3] memory _ids) {\n        require(msg.sender == linkNode, \"Only link node can create markets\");\n        creationPayloads.push(_payload);\n        return marketFactory.createMarket(_payload);\n    }\n\n    function trustedResolveMarkets(bytes32 _payload) public {\n        require(msg.sender == linkNode, \"Only link node can resolve markets\");\n        resolutionPayloads.push(_payload);\n        return marketFactory.trustedResolveMarkets(_payload);\n    }\n\n    function getEventMarkets(uint256 _eventId) external view returns (uint256[3] memory) {\n        return marketFactory.getEventMarkets(_eventId);\n    }\n\n    function isEventRegistered(uint256 _eventId) public view returns (bool) {\n        return marketFactory.isEventRegistered(_eventId);\n    }\n\n    function isEventResolved(uint256 _eventId) public view returns (bool) {\n        return marketFactory.isEventResolved(_eventId);\n    }\n\n    // Replay\n    // The replay strategy is to start at the latest market and decement until error.\n\n    function replayCreate(uint256 i) public onlyOwner {\n        marketFactory.createMarket(creationPayloads[i]);\n    }\n\n    function replayResolve(uint256 i) public onlyOwner {\n        marketFactory.trustedResolveMarkets(resolutionPayloads[i]);\n    }\n\n    function creationPayloadsLength() public view returns (uint256) {\n        return creationPayloads.length;\n    }\n\n    function resolutionPayloadsLength() public view returns (uint256) {\n        return resolutionPayloads.length;\n    }\n\n    // Misc\n\n    SportsLinkMarketFactory public marketFactory;\n    address public linkNode;\n    bytes32[] public creationPayloads;\n    bytes32[] public resolutionPayloads;\n\n    constructor(\n        address _owner,\n        SportsLinkMarketFactory _marketFactory,\n        address _linkNode\n    ) {\n        owner = _owner; // test controller\n        marketFactory = _marketFactory;\n        linkNode = _linkNode;\n    }\n\n    function setMarketFactory(SportsLinkMarketFactory _newAddress) external onlyOwner {\n        marketFactory = _newAddress;\n    }\n\n    function setLinkNode(address _newLinkNode) external onlyOwner {\n        linkNode = _newLinkNode;\n    }\n\n    function onTransferOwnership(address, address) internal override {}\n}\n"
    },
    "contracts/libraries/PlaceholderReputationToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title Cash\n * @dev Test contract for collateral\n */\ncontract PlaceholderReputationToken is ERC20 {\n    uint8 private _decimals;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) ERC20(name_, symbol_) {\n        _decimals = decimals_;\n    }\n\n    function decimals() public view virtual override(ERC20) returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "contracts/turbo/PriceMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactory.sol\";\nimport \"./FeePot.sol\";\nimport \"../libraries/IERC20Full.sol\";\n\n// IMPORTANT: This can *ONLY* be used for testing.\n//            The spot price is extremely manipulable.\ncontract TestPriceMarketFactory is AbstractMarketFactory {\n    using SafeMathUint256 for uint256;\n\n    event MarketCreated(uint256 id, address creator, uint256 endTime, uint256 spotPrice);\n    event MarketResolved(uint256 id, address winner);\n\n    BPool pool;\n    IERC20Full tokenIn;\n    IERC20Full tokenOut;\n\n    struct MarketDetails {\n        uint256 spotPrice;\n        uint256 resolvedSpotPrice;\n    }\n    MarketDetails[] internal marketDetails;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256 _stakerFee,\n        uint256 _settlementFee,\n        address _protocol,\n        uint256 _protocolFee,\n        BPool _pool,\n        IERC20Full _tokenIn,\n        IERC20Full _tokenOut\n    )\n        AbstractMarketFactory(\n            _owner,\n            _collateral,\n            _shareFactor,\n            _feePot,\n            _stakerFee,\n            _settlementFee,\n            _protocol,\n            _protocolFee\n        )\n    {\n        pool = _pool;\n        tokenIn = _tokenIn;\n        tokenOut = _tokenOut;\n    }\n\n    function createMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _spotPrice\n    ) public returns (uint256) {\n        require(_endTime > block.timestamp, \"Market must end in the future\");\n\n        string[] memory _names = new string[](2);\n        _names[0] = string(\"Low\");\n        _names[1] = string(\"High\");\n        string[] memory _symbols = new string[](2);\n        _symbols[0] = string(\"LOW\");\n        _symbols[1] = string(\"HIGH\");\n\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _names, _symbols, _endTime));\n        marketDetails.push(MarketDetails(_spotPrice, 0));\n\n        emit MarketCreated(_id, _creator, _endTime, _spotPrice);\n        return _id;\n    }\n\n    function resolveMarket(uint256 _id) public override {\n        Market storage _market = markets[_id];\n        MarketDetails storage _marketDetails = marketDetails[_id];\n        require(_market.endTime > 0, \"No such market\");\n        require(_market.endTime > block.timestamp, \"Market cannot be resolved until its endTime\");\n\n        uint256 _resolvedSpotPrice = pool.getSpotPriceSansFee(address(tokenIn), address(tokenOut));\n        _marketDetails.resolvedSpotPrice = _resolvedSpotPrice;\n\n        if (_resolvedSpotPrice < _marketDetails.spotPrice) {\n            _market.winner = _market.shareTokens[0]; // LOW\n        } else {\n            _market.winner = _market.shareTokens[1]; // HIGH\n        }\n\n        emit MarketResolved(_id, address(_market.winner));\n    }\n\n    function getMarketDetails(uint256 _id) public view returns (MarketDetails memory) {\n        return marketDetails[_id];\n    }\n}\n"
    },
    "contracts/turbo/MMALinkMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactory.sol\";\nimport \"./FeePot.sol\";\nimport \"../libraries/SafeMathInt256.sol\";\n\ncontract MMALinkMarketFactory is AbstractMarketFactory {\n    using SafeMathUint256 for uint256;\n    using SafeMathInt256 for int256;\n\n    event MarketCreated(\n        uint256 id,\n        address creator,\n        uint256 endTime,\n        MarketType marketType,\n        uint256 indexed eventId,\n        uint256 homeTeamId,\n        uint256 awayTeamId,\n        uint256 estimatedStarTime,\n        int256 score\n    );\n    event MarketResolved(uint256 id, address winner);\n\n    event LinkNodeChanged(address newLinkNode);\n\n    enum MarketType {HeadToHead, Spread, OverUnder}\n    enum EventStatus {Unknown, Scheduled, Final, Postponed, Canceled}\n\n    struct MarketDetails {\n        uint256 eventId;\n        uint256 homeTeamId;\n        uint256 awayTeamId;\n        uint256 estimatedStartTime;\n        MarketType marketType;\n        EventStatus eventStatus;\n        // This value depends on the marketType.\n        // HeadToHead: ignored\n        // Spread: the home team spread\n        // OverUnder: total score in game\n        int256 value0;\n    }\n    // MarketId => MarketDetails\n    mapping(uint256 => MarketDetails) internal marketDetails;\n    // EventId => [MarketId]\n    mapping(uint256 => uint256[3]) public events;\n\n    address public linkNode;\n    uint256 public sportId;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256 _stakerFee,\n        uint256 _settlementFee,\n        address _protocol,\n        uint256 _protocolFee,\n        address _linkNode,\n        uint256 _sportId\n    )\n        AbstractMarketFactory(\n            _owner,\n            _collateral,\n            _shareFactor,\n            _feePot,\n            _stakerFee,\n            _settlementFee,\n            _protocol,\n            _protocolFee\n        )\n    {\n        linkNode = _linkNode;\n        sportId = _sportId;\n    }\n\n    function createMarket(bytes32 _payload) public returns (uint256[3] memory _ids) {\n        require(msg.sender == linkNode, \"Only link node can create markets\");\n\n        (\n            uint256 _eventId,\n            uint256 _homeTeamId,\n            uint256 _awayTeamId,\n            uint256 _startTimestamp,\n            int256 _homeSpread,\n            uint256 _totalScore,\n            bool _makeSpread,\n            bool _makeTotalScore\n        ) = decodeCreation(_payload);\n        address _creator = msg.sender;\n        uint256 _endTime = _startTimestamp.add(60 * 8); // 8 hours\n\n        _ids = events[_eventId];\n\n        if (_ids[0] == 0) {\n            _ids[0] = createHeadToHeadMarket(_creator, _endTime, _eventId, _homeTeamId, _awayTeamId, _startTimestamp);\n        }\n\n        if (_ids[1] == 0 && _makeSpread) {\n            // spread market hasn't been created and is ready to be created\n            _ids[1] = createSpreadMarket(\n                _creator,\n                _endTime,\n                _eventId,\n                _homeTeamId,\n                _awayTeamId,\n                _startTimestamp,\n                _homeSpread\n            );\n        }\n\n        if (_ids[2] == 0 && _makeTotalScore) {\n            // over-under market hasn't been created and is ready to be created\n            _ids[2] = createOverUnderMarket(\n                _creator,\n                _endTime,\n                _eventId,\n                _homeTeamId,\n                _awayTeamId,\n                _startTimestamp,\n                _totalScore\n            );\n        }\n\n        events[_eventId] = _ids;\n    }\n\n    function createHeadToHeadMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[0] = \"No Contest\";\n        _outcomes[1] = \"Away\";\n        _outcomes[2] = \"Home\";\n\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime));\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.HeadToHead,\n            EventStatus.Scheduled,\n            0\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.HeadToHead,\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            0\n        );\n        return _id;\n    }\n\n    function createSpreadMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        int256 _homeSpread\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[0] = \"No Contest\";\n        _outcomes[1] = \"Away\";\n        _outcomes[2] = \"Home\";\n\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime));\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.Spread,\n            EventStatus.Scheduled,\n            _homeSpread\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.Spread,\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            _homeSpread\n        );\n        return _id;\n    }\n\n    function createOverUnderMarket(\n        address _creator,\n        uint256 _endTime,\n        uint256 _eventId,\n        uint256 _homeTeamId,\n        uint256 _awayTeamId,\n        uint256 _startTimestamp,\n        uint256 _overUnderTotal\n    ) internal returns (uint256) {\n        string[] memory _outcomes = new string[](3);\n        _outcomes[0] = \"No Contest\";\n        _outcomes[1] = \"Over\";\n        _outcomes[2] = \"Under\";\n\n        uint256 _id = markets.length;\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _endTime));\n        marketDetails[_id] = MarketDetails(\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            MarketType.OverUnder,\n            EventStatus.Scheduled,\n            int256(_overUnderTotal)\n        );\n        emit MarketCreated(\n            _id,\n            _creator,\n            _endTime,\n            MarketType.OverUnder,\n            _eventId,\n            _homeTeamId,\n            _awayTeamId,\n            _startTimestamp,\n            int256(_overUnderTotal)\n        );\n        return _id;\n    }\n\n    function resolveMarket(uint256) public pure override {\n        require(false, \"Only the link node can resolve the market, using trustedResolveMarkets\");\n    }\n\n    function trustedResolveMarkets(bytes32 _payload) public {\n        require(msg.sender == linkNode, \"Only link node can resolve markets\");\n\n        (uint256 _eventId, uint256 _eventStatus, uint256 _homeScore, uint256 _awayScore) = decodeResolution(_payload);\n        uint256[3] memory _ids = events[_eventId];\n        require(_ids[0] != 0 || _ids[1] != 0 || _ids[2] != 0, \"Cannot resolve markets that weren't created\");\n\n        require(EventStatus(_eventStatus) != EventStatus.Scheduled, \"cannot resolve SCHEDULED markets\");\n\n        // resolve markets as No Contest\n        if (EventStatus(_eventStatus) != EventStatus.Final) {\n            for (uint256 i = 0; i < _ids.length; i++) {\n                uint256 _id = _ids[1];\n                if (_id == 0) continue; // skip non-created markets\n                markets[_id].winner = markets[_id].shareTokens[0];\n            }\n            return;\n        }\n\n        // only resolve markets that were created\n        if (_ids[0] != 0) {\n            resolveHeadToHeadMarket(_ids[0], _homeScore, _awayScore);\n        }\n        if (_ids[1] != 0) {\n            resolveSpreadMarket(_ids[1], _homeScore, _awayScore);\n        }\n        if (_ids[2] != 0) {\n            resolveOverUnderMarket(_ids[2], _homeScore, _awayScore);\n        }\n    }\n\n    function resolveHeadToHeadMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        OwnedERC20 _winner;\n        if (_homeScore > _awayScore) {\n            _winner = markets[_id].shareTokens[2]; // home team won\n        } else if (_homeScore < _awayScore) {\n            _winner = markets[_id].shareTokens[1]; // away team won\n        } else {\n            _winner = markets[_id].shareTokens[0]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function resolveSpreadMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        MarketDetails memory _details = marketDetails[_id];\n        int256 _targetSpread = _details.value0;\n\n        int256 _actualSpread = int256(_homeScore).sub(int256(_awayScore));\n\n        OwnedERC20 _winner;\n        if (_actualSpread > _targetSpread) {\n            _winner = markets[_id].shareTokens[2]; // home spread greater\n        } else if (_actualSpread < _targetSpread) {\n            _winner = markets[_id].shareTokens[1]; // home spread lesser\n        } else {\n            _winner = markets[_id].shareTokens[0]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function resolveOverUnderMarket(\n        uint256 _id,\n        uint256 _homeScore,\n        uint256 _awayScore\n    ) internal {\n        MarketDetails memory _details = marketDetails[_id];\n        int256 _targetTotal = _details.value0;\n\n        int256 _actualTotal = int256(_homeScore).add(int256(_awayScore));\n\n        OwnedERC20 _winner;\n        if (_actualTotal > _targetTotal) {\n            _winner = markets[_id].shareTokens[1]; // over\n        } else if (_actualTotal < _targetTotal) {\n            _winner = markets[_id].shareTokens[2]; // under\n        } else {\n            _winner = markets[_id].shareTokens[0]; // no contest\n        }\n\n        markets[_id].winner = _winner;\n        emit MarketResolved(_id, address(_winner));\n    }\n\n    function getMarketDetails(uint256 _marketId) public view returns (MarketDetails memory) {\n        return marketDetails[_marketId];\n    }\n\n    function setLinkNode(address _newLinkNode) external onlyOwner {\n        linkNode = _newLinkNode;\n        emit LinkNodeChanged(_newLinkNode);\n    }\n\n    function getEventMarkets(uint256 _eventId) external view returns (uint256[3] memory) {\n        uint256[3] memory _event = events[_eventId];\n        return _event;\n    }\n\n    // Events can be partially registered, by only creating some markets.\n    // This returns true only if an event is fully registered.\n    function isEventRegistered(uint256 _eventId) public view returns (bool) {\n        uint256[3] memory _event = events[_eventId];\n        return _event[0] != 0 && _event[1] != 0 && _event[2] != 0;\n    }\n\n    function isEventResolved(uint256 _eventId) public view returns (bool) {\n        // check the event's head-to-head market since it will always exist if of the event's markets exist\n        uint256 _marketId = events[_eventId][0];\n        return isMarketResolved(_marketId);\n    }\n\n    function encodeCreation(\n        uint128 _eventId,\n        uint16 _homeTeamId,\n        uint16 _awayTeamId,\n        uint32 _startTimestamp,\n        int16 _homeSpread,\n        uint16 _totalScore,\n        bool _createSpread,\n        bool _createTotal\n    ) external pure returns (bytes32 _payload) {\n        uint8 _creationFlags;\n\n        if (_createSpread) {\n            _creationFlags += 1; // 0b0000000x\n        }\n        if (_createTotal) {\n            _creationFlags += 2; // 0b000000x0\n        }\n\n        bytes memory _a =\n            abi.encodePacked(\n                _eventId,\n                _homeTeamId,\n                _awayTeamId,\n                _startTimestamp,\n                _homeSpread,\n                _totalScore,\n                _creationFlags\n            );\n        assembly {\n            _payload := mload(add(_a, 32))\n        }\n    }\n\n    function decodeCreation(bytes32 _payload)\n        public\n        pure\n        returns (\n            uint128 _eventId,\n            uint16 _homeTeamId,\n            uint16 _awayTeamId,\n            uint32 _startTimestamp,\n            int16 _homeSpread,\n            uint16 _totalScore,\n            bool _createSpread,\n            bool _createTotal\n        )\n    {\n        uint256 _temp = uint256(_payload);\n        uint8 _creationFlags;\n        // prettier-ignore\n        {\n            _eventId        = uint128(_temp >> 128);\n            _homeTeamId     = uint16((_temp << 128)                                >> (256 - 16));\n            _awayTeamId     = uint16((_temp << (128 + 16))                         >> (256 - 16));\n            _startTimestamp = uint32((_temp << (128 + 16 + 16))                    >> (256 - 32));\n            _homeSpread     = int16 ((_temp << (128 + 16 + 16 + 32))               >> (256 - 16));\n            _totalScore     = uint16((_temp << (128 + 16 + 16 + 32 + 16))          >> (256 - 16));\n            _creationFlags  = uint8 ((_temp << (128 + 16 + 16 + 32 + 16 + 16))     >> (256 -  8));\n\n            // Lowest bit is _createSpread.\n            // Second-lowest bit is _createTotal.\n            _createSpread = _creationFlags & 0x1 != 0; // 0b0000000x\n            _createTotal = _creationFlags & 0x2 != 0;  // 0b000000x0\n        }\n    }\n\n    function encodeResolution(\n        uint128 _eventId,\n        uint8 _eventStatus,\n        uint16 _homeScore,\n        uint16 _awayScore\n    ) external pure returns (bytes32 _payload) {\n        bytes memory _a = abi.encodePacked(_eventId, _eventStatus, _homeScore, _awayScore);\n        assembly {\n            _payload := mload(add(_a, 32))\n        }\n    }\n\n    function decodeResolution(bytes32 _payload)\n        public\n        pure\n        returns (\n            uint128 _eventId,\n            uint8 _eventStatus,\n            uint16 _homeScore,\n            uint16 _awayScore\n        )\n    {\n        uint256 _temp = uint256(_payload);\n        // prettier-ignore\n        {\n            _eventId     = uint128(_temp >> 128);\n            _eventStatus = uint8 ((_temp << 128)            >> (256 - 8));\n            _homeScore   = uint16((_temp << (128 + 8))      >> (256 - 16));\n            _awayScore   = uint16((_temp << (128 + 8 + 16)) >> (256 - 16));\n        }\n    }\n}\n"
    },
    "contracts/turbo/CryptoMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../libraries/IERC20Full.sol\";\nimport \"../balancer/BPool.sol\";\nimport \"./AbstractMarketFactory.sol\";\nimport \"./FeePot.sol\";\nimport \"../libraries/SafeMathInt256.sol\";\n\nimport \"@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol\";\n\ncontract CryptoMarketFactory is AbstractMarketFactory {\n    using SafeMathUint256 for uint256;\n    using SafeMathInt256 for int256;\n\n    event MarketCreated(\n        uint256 id,\n        address creator,\n        uint256 indexed endTime,\n        MarketType marketType,\n        uint256 indexed coinIndex,\n        uint256 price\n    );\n    event MarketResolved(uint256 id, address winner);\n\n    struct Coin {\n        string name;\n        AggregatorV3Interface priceFeed;\n        uint256 price;\n        uint8 imprecision; // how many decimals to truncate\n        uint256[1] currentMarkets;\n    }\n    Coin[] public coins;\n\n    enum MarketType {\n        PriceUpDown // 0\n    }\n    enum PriceUpDownOutcome {\n        Above, // 0\n        NotAbove // 1\n    }\n    struct MarketDetails {\n        MarketType marketType;\n        uint256 coinIndex;\n        uint256 price;\n    }\n    // MarketId => MarketDetails\n    mapping(uint256 => MarketDetails) internal marketDetails;\n\n    address public linkNode; // market creator and resolver\n\n    uint256 public nextResolutionTime;\n\n    constructor(\n        address _owner,\n        IERC20Full _collateral,\n        uint256 _shareFactor,\n        FeePot _feePot,\n        uint256 _stakerFee,\n        uint256 _settlementFee,\n        address _protocol,\n        uint256 _protocolFee,\n        address _linkNode,\n        uint256 _firstResolutionTime\n    )\n        AbstractMarketFactory(\n            _owner,\n            _collateral,\n            _shareFactor,\n            _feePot,\n            _stakerFee,\n            _settlementFee,\n            _protocol,\n            _protocolFee\n        )\n    {\n        linkNode = _linkNode;\n        nextResolutionTime = _firstResolutionTime;\n\n        string memory _name = \"\";\n        coins.push(makeCoin(_name, AggregatorV3Interface(0), 0));\n    }\n\n    function getMarketDetails(uint256 _marketId) public view returns (MarketDetails memory) {\n        return marketDetails[_marketId];\n    }\n\n    // NOTE: Trusts the owner not to add a coin twice.\n    // Returns the coin index.\n    function addCoin(\n        string calldata _name,\n        AggregatorV3Interface _priceFeed,\n        uint8 _imprecision\n    ) external onlyOwner returns (uint256 _coinIndex) {\n        Coin memory _coin = makeCoin(_name, _priceFeed, _imprecision);\n        _coinIndex = coins.length;\n        coins.push(_coin);\n\n        createAndResolveMarketsForCoin(_coinIndex);\n    }\n\n    function getCoin(uint256 _coinIndex) public view returns (Coin memory _coin) {\n        _coin = coins[_coinIndex];\n    }\n\n    function getCoins() public view returns (Coin[] memory _coins) {\n        _coins = new Coin[](coins.length);\n        // Skip first coin because it's always the zeroed-out fake coin.\n        for (uint256 i = 1; i < coins.length; i++) {\n            _coins[i] = coins[i];\n        }\n    }\n\n    // Iterates over all coins.\n    // If markets do not exist for coin, create them.\n    // If markets for coin are ready to resolve, resolve them and create new markets.\n    // Else, error.\n    function createAndResolveMarkets(uint256 _nextResolutionTime) public {\n        require(msg.sender == linkNode, \"Only link node can create markets\");\n        // If market creation was stopped then it can be started again.\n        // If market creation wasn't stopped then you must wait for market end time to resolve.\n        require(nextResolutionTime == 0 || block.timestamp >= nextResolutionTime, \"Must wait for market resolution\");\n\n        nextResolutionTime = _nextResolutionTime;\n\n        // Start at 1 to skip the fake Coin in the 0 index\n        for (uint256 i = 1; i < coins.length; i++) {\n            createAndResolveMarketsForCoin(i);\n        }\n    }\n\n    function createAndResolveMarketsForCoin(uint256 _coinIndex) internal {\n        Coin memory _coin = coins[_coinIndex];\n        uint256 _newPrice = getPrice(_coin);\n\n        // resolve markets\n        if (_coin.currentMarkets[uint256(MarketType.PriceUpDown)] != 0) {\n            resolvePriceUpDownMarket(_coin, _newPrice);\n        }\n\n        // update price only AFTER resolution\n        coins[_coinIndex].price = _newPrice;\n\n        // link node sets nextResolutionTime to zero to signify \"do not create markets after resolution\"\n        if (nextResolutionTime == 0) {\n            return;\n        }\n\n        // create markets\n        coins[_coinIndex].currentMarkets[uint256(MarketType.PriceUpDown)] = createPriceUpDownMarket(\n            _coinIndex,\n            linkNode,\n            _newPrice\n        );\n    }\n\n    function resolvePriceUpDownMarket(Coin memory _coin, uint256 _newPrice) internal {\n        uint256 _marketId = _coin.currentMarkets[uint256(MarketType.PriceUpDown)];\n\n        OwnedERC20 _winner;\n        if (_newPrice > _coin.price) {\n            _winner = markets[_marketId].shareTokens[uint256(PriceUpDownOutcome.Above)];\n        } else {\n            _winner = markets[_marketId].shareTokens[uint256(PriceUpDownOutcome.NotAbove)];\n        }\n\n        markets[_marketId].winner = _winner;\n        emit MarketResolved(_marketId, address(_winner));\n    }\n\n    function createPriceUpDownMarket(\n        uint256 _coinIndex,\n        address _creator,\n        uint256 _newPrice\n    ) internal returns (uint256 _id) {\n        string[] memory _outcomes = new string[](2);\n        _outcomes[uint256(PriceUpDownOutcome.Above)] = \"Above\";\n        _outcomes[uint256(PriceUpDownOutcome.NotAbove)] = \"Not Above\";\n\n        uint256 _nextResolutionTime = nextResolutionTime;\n        _id = markets.length;\n        markets.push(makeMarket(_creator, _outcomes, _outcomes, _nextResolutionTime));\n        marketDetails[_id] = MarketDetails(MarketType.PriceUpDown, _coinIndex, _newPrice);\n        emit MarketCreated(_id, _creator, _nextResolutionTime, MarketType.PriceUpDown, _coinIndex, _newPrice);\n    }\n\n    function getPrice(Coin memory _coin) internal view returns (uint256) {\n        (, int256 _price, , , ) = _coin.priceFeed.latestRoundData();\n        require(_price >= 0, \"Price from feed is negative\");\n\n        // The precision is how many decimals the price has. Zero is dollars, 2 includes cents, 3 is tenths of a cent, etc.\n        // Our resolution rules want a certain precision. Like BTC is to the dollar and MATIC is to the cent.\n        // If somehow the decimals are larger than the desired precision then add zeroes to the end to meet the precision.\n        // This does not change the resolution outcome but does guard against decimals() changing and therefore altering the basis.\n\n        uint256 _truncatedPrice;\n        uint8 _precision = _coin.priceFeed.decimals(); // probably constant but that isn't guaranteed, so query each time\n        if (_precision > _coin.imprecision) {\n            uint8 _truncate = _precision - _coin.imprecision;\n            _truncatedPrice = uint256(_price) / (10**_truncate);\n        } else if (_precision < _coin.imprecision) {\n            uint8 _greaten = _coin.imprecision - _precision;\n            _truncatedPrice = uint256(_price) * (10**_greaten);\n        } else {\n            _truncatedPrice = uint256(_price);\n        }\n\n        // Round up because that cleanly fits Above/Not-Above.\n        if (_truncatedPrice == uint256(_price)) {\n            return _truncatedPrice;\n        } else {\n            return _truncatedPrice + 1;\n        }\n    }\n\n    function makeCoin(\n        string memory _name,\n        AggregatorV3Interface _priceFeed,\n        uint8 _imprecision\n    ) internal pure returns (Coin memory _coin) {\n        uint256[1] memory _currentMarkets = [uint256(0)];\n        _coin = Coin(_name, _priceFeed, 0, _imprecision, _currentMarkets);\n    }\n\n    function resolveMarket(uint256) public pure override {\n        require(false, \"Use createAndResolveMarkets\");\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
    },
    "contracts/libraries/FakePriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol\";\n\ncontract FakePriceFeed is AggregatorV3Interface {\n    uint8 decimals_;\n    string description_;\n    uint256 version_;\n\n    struct Round {\n        uint80 roundId;\n        int256 answer;\n        uint256 startedAt;\n        uint256 updatedAt;\n        uint80 answeredInRound;\n    }\n    mapping(uint80 => Round) rounds;\n    uint80 latestRoundId;\n\n    constructor(\n        uint8 _decimals,\n        string memory _description,\n        uint256 _version\n    ) {\n        decimals_ = _decimals;\n        description_ = _description;\n        version_ = _version;\n    }\n\n    function decimals() external view override returns (uint8) {\n        return decimals_;\n    }\n\n    function description() external view override returns (string memory) {\n        return description_;\n    }\n\n    function version() external view override returns (uint256) {\n        return version_;\n    }\n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(uint80 roundId_)\n        public\n        view\n        override\n        returns (\n            uint80 _roundId,\n            int256 _answer,\n            uint256 _startedAt,\n            uint256 _updatedAt,\n            uint80 _answeredInRound\n        )\n    {\n        Round memory _round = rounds[roundId_];\n        _roundId = _round.roundId;\n        _answer = _round.answer;\n        _startedAt = _round.startedAt;\n        _updatedAt = _round.updatedAt;\n        _answeredInRound = _round.answeredInRound;\n    }\n\n    function latestRoundData()\n        public\n        view\n        override\n        returns (\n            uint80 _roundId,\n            int256 _answer,\n            uint256 _startedAt,\n            uint256 _updatedAt,\n            uint80 _answeredInRound\n        )\n    {\n        return getRoundData(latestRoundId);\n    }\n\n    function addRound(\n        uint80 _roundId,\n        int256 _answer,\n        uint256 _startedAt,\n        uint256 _updatedAt,\n        uint80 _answeredInRound\n    ) external {\n        rounds[_roundId] = Round(_roundId, _answer, _startedAt, _updatedAt, _answeredInRound);\n        latestRoundId = _roundId;\n    }\n}\n"
    },
    "contracts/balancer/BPoolForTesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"./BFactory.sol\";\nimport \"../libraries/IERC20Full.sol\";\nimport \"../libraries/Cash.sol\";\n\ncontract BPoolForTesting {\n    BFactory private bFactory;\n    BPool private bPool;\n    uint256 private constant MAX_UINT = 2**256 - 1;\n\n    constructor(BFactory _bFactory) {\n        bFactory = _bFactory;\n    }\n\n    function createBPoolForTesting(\n        Cash[] calldata _tokens,\n        uint256[] calldata _initialLiquidity,\n        uint256[] calldata _weights\n    ) external returns (BPool) {\n        require(\n            _tokens.length == _weights.length && _tokens.length == _initialLiquidity.length,\n            \"Tokens, weights and initial liquidity should all have the same length.\"\n        );\n\n        bPool = bFactory.newBPool();\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            _tokens[i].approve(address(bPool), MAX_UINT);\n            bPool.bind(address(_tokens[i]), _initialLiquidity[i], _weights[i]);\n        }\n\n        bPool.finalize();\n\n        return bPool;\n    }\n\n    function getBPool() external view returns (BPool) {\n        return bPool;\n    }\n}\n"
    },
    "contracts/libraries/Cash.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title Cash\n * @dev Test contract for collateral\n */\ncontract Cash is ERC20 {\n    uint8 private _decimals;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) ERC20(name_, symbol_) {\n        _decimals = decimals_;\n    }\n\n    function decimals() public view virtual override(ERC20) returns (uint8) {\n        return _decimals;\n    }\n\n    function faucet(uint256 _amount) public returns (bool) {\n        _mint(msg.sender, _amount);\n        return true;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}